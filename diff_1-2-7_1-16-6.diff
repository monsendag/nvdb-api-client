diff --git a/src/main/java/no/vegvesen/nvdbapi/client/ClientConfiguration.java b/src/main/java/no/vegvesen/nvdbapi/client/ClientConfiguration.java
new file mode 100644
index 0000000..c65f453
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/ClientConfiguration.java
@@ -0,0 +1,69 @@
+package no.vegvesen.nvdbapi.client;
+
+import java.util.Objects;
+
+public class ClientConfiguration {
+    private final int readTimeout;
+    private final int connectTimeout;
+
+    private ClientConfiguration(int readTimeout, int connectTimeout) {
+        this.readTimeout = readTimeout;
+        this.connectTimeout = connectTimeout;
+    }
+
+    public int getReadTimeout() {
+        return readTimeout;
+    }
+
+    public int getConnectTimeout() {
+        return connectTimeout;
+    }
+
+    public static final class ClientConfigurationBuilder {
+        private int readTimeout = 0;
+        private int connectTimeout = 0;
+
+        private ClientConfigurationBuilder() {
+        }
+
+        public static ClientConfigurationBuilder builder() {
+            return new ClientConfigurationBuilder();
+        }
+
+        /**
+         * @param readTimeout in millis. Set the read timeout for the jersey client.
+         * @return builder
+         */
+        public ClientConfigurationBuilder withReadTimeout(int readTimeout) {
+            this.readTimeout = readTimeout;
+            return this;
+        }
+
+        /**
+         * @param connectTimeout in millis. Set the connect timeout for the jersey client.
+         * @return builder
+         */
+        public ClientConfigurationBuilder withConnectTimeout(int connectTimeout) {
+            this.connectTimeout = connectTimeout;
+            return this;
+        }
+
+        public ClientConfiguration build() {
+            return new ClientConfiguration(readTimeout, connectTimeout);
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        ClientConfiguration that = (ClientConfiguration) o;
+        return readTimeout == that.readTimeout &&
+                connectTimeout == that.connectTimeout;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(readTimeout, connectTimeout);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/ProxyConfig.java b/src/main/java/no/vegvesen/nvdbapi/client/ProxyConfig.java
similarity index 95%
rename from src/main/java/no/vegvesen/nvdbapi/client/clients/ProxyConfig.java
rename to src/main/java/no/vegvesen/nvdbapi/client/ProxyConfig.java
index 21ce4f4..77d1e13 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/ProxyConfig.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/ProxyConfig.java
@@ -1,4 +1,4 @@
-package no.vegvesen.nvdbapi.client.clients;
+package no.vegvesen.nvdbapi.client;
 
 import no.vegvesen.nvdbapi.client.util.Strings;
 
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/AbstractJerseyClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/AbstractJerseyClient.java
index a3f0d24..aeb0993 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/AbstractJerseyClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/AbstractJerseyClient.java
@@ -25,99 +25,45 @@
 
 package no.vegvesen.nvdbapi.client.clients;
 
-import com.google.gson.Gson;
-import no.vegvesen.nvdbapi.client.util.Strings;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import javax.ws.rs.client.Client;
-import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.UriBuilder;
 import java.io.Serializable;
-import java.net.URL;
-import java.net.URLDecoder;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Optional;
+import java.util.function.Consumer;
 
 abstract class AbstractJerseyClient implements AutoCloseable, Serializable {
-    private final Logger log = LoggerFactory.getLogger(getClass());
     private final String baseUrl;
     private final Client client;
+    private final Consumer<AbstractJerseyClient> onClose;
     private boolean isClosed;
 
-    protected AbstractJerseyClient(String baseUrl, Client client) {
+    AbstractJerseyClient(String baseUrl,
+                         Client client,
+                         Consumer<AbstractJerseyClient> onClose) {
         this.baseUrl = baseUrl;
         this.client = client;
+        this.onClose = onClose;
     }
 
-    protected Client getClient() {
+    Client getClient() {
         return client;
     }
 
-    protected UriBuilder start() {
+    UriBuilder start() {
         return UriBuilder.fromUri(baseUrl);
     }
 
-    protected void logEntity(Object obj) {
-        logEntity("{}", obj);
-    }
-
-    protected void logEntity(String logMessage, Object obj) {
-        log.debug(logMessage, Optional.ofNullable(obj).map(o -> new Gson().toJson(o)));
-    }
-
-    protected static Map<String, String> splitQuery(String url) {
-        try {
-            Map<String, String> query_pairs = new LinkedHashMap<>();
-            String query = new URL(url).getQuery();
-            String[] pairs = query.split("&");
-            for (String pair : pairs) {
-                int idx = pair.indexOf("=");
-                query_pairs.put(URLDecoder.decode(pair.substring(0, idx), "UTF-8"), URLDecoder.decode(pair.substring(idx + 1), "UTF-8"));
-            }
-            return query_pairs;
-        } catch (Exception ex) {
-            throw new RuntimeException(ex);
-        }
-    }
-
-    private String extractLink(MultivaluedMap<String, String> headers, String rel) {
-        if (!headers.containsKey("Link")) {
-            return null;
-        }
-
-        return headers.get("Link")
-                .stream().filter(l -> isLink(l, rel))
-                .findFirst().map(s -> s.substring(0, s.lastIndexOf(";")).trim()).orElse(null);
-    }
-
-    private boolean isLink(String val, String rel) {
-        if (Strings.isNullOrEmpty(val)) {
-            return false;
-        }
-
-        String withoutSpaces = val.replaceAll(" ", "");
-        int idx = withoutSpaces.lastIndexOf("rel=");
-        if (idx < 0) {
-            return false;
-        }
-
-        String actualRel = withoutSpaces.substring(idx + "rel=".length());
-        return actualRel.equalsIgnoreCase(rel);
-    }
-
     public boolean isClosed() {
         return isClosed;
     }
 
     @Override
-    public void close() throws Exception {
+    public void close() {
         if (isClosed) {
             return;
         }
-
         client.close();
+        onClose.accept(this);
         isClosed = true;
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/AreaClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/AreaClient.java
index 8949b57..5b80888 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/AreaClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/AreaClient.java
@@ -28,8 +28,8 @@ package no.vegvesen.nvdbapi.client.clients;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
 import no.vegvesen.nvdbapi.client.gson.AreaParser;
+import no.vegvesen.nvdbapi.client.model.Page;
 import no.vegvesen.nvdbapi.client.model.Projection;
 import no.vegvesen.nvdbapi.client.model.areas.*;
 
@@ -38,20 +38,25 @@ import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.UriBuilder;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.function.Consumer;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
+
 public class AreaClient extends AbstractJerseyClient {
 
-    protected AreaClient(String baseUrl, Client client) {
-        super(baseUrl, client);
+    AreaClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
     }
 
     public List<Municipality> getMunicipalities(boolean includeBoundingBox, boolean includeCenterPoint, boolean includeObjectLink, Projection projection) {
         WebTarget target = getClient().target(areaRoot().path("kommuner"));
 
-        return getAreas(includeBoundingBox, includeCenterPoint, includeObjectLink, projection, target).map(AreaParser::parseMun).collect(Collectors.toList());
+        return getAreas(includeBoundingBox, includeCenterPoint, includeObjectLink, projection, target)
+            .map(rt(AreaParser::parseMun))
+            .collect(Collectors.toList());
     }
 
     public List<Municipality> getMunicipalities() {
@@ -61,23 +66,15 @@ public class AreaClient extends AbstractJerseyClient {
     public List<County> getCountys(boolean includeBoundingBox, boolean includeCenterPoint, boolean includeObjectLink, Projection projection) {
         WebTarget target = getClient().target(areaRoot().path("fylker"));
 
-        return getAreas(includeBoundingBox, includeCenterPoint, includeObjectLink, projection, target).map(AreaParser::parseCounty).collect(Collectors.toList());
+        return getAreas(includeBoundingBox, includeCenterPoint, includeObjectLink, projection, target)
+            .map(rt(AreaParser::parseCounty))
+            .collect(Collectors.toList());
     }
 
     public List<County> getCountys() {
         return getCountys(true, true, false, null);
     }
 
-    public List<Region> getRegions(boolean includeBoundingBox, boolean includeCenterPoint, boolean includeObjectLink, Projection projection) {
-        WebTarget target = getClient().target(areaRoot().path("regioner"));
-
-        return getAreas(includeBoundingBox, includeCenterPoint, includeObjectLink, projection, target).map(AreaParser::parseRegion).collect(Collectors.toList());
-    }
-
-    public List<Region> getRegions() {
-        return getRegions(true, true, false, null);
-    }
-
     public List<Route> getNationalRoutes(boolean includeObjectLink) {
         UriBuilder path = areaRoot().path("riksvegruter");
 
@@ -85,39 +82,53 @@ public class AreaClient extends AbstractJerseyClient {
 
         WebTarget target = getClient().target(path);
 
-        return getAreas(target).map(AreaParser::parseRoute).collect(Collectors.toList());
+        return getAreas(target)
+            .map(rt(AreaParser::parseRoute))
+            .collect(Collectors.toList());
     }
 
-    public List<Route> getNationalRoutes() {
-        return getNationalRoutes(false);
+    public StreetsResult getStreets(StreetRequest request) {
+        WebTarget target = getStreetWebTarget(request.includeObjectLink());
+
+        return new StreetsResult(target, Page.defaults().withCount(request.getPageSize()));
     }
 
-    public List<ContractArea> getContractAreas(boolean includeObjectLink) {
-        UriBuilder path = areaRoot().path("kontraktsomrader");
+    public AsyncStreetsResult getStreetsAsync(StreetRequest request) {
+        WebTarget target = getStreetWebTarget(request.includeObjectLink());
 
-        if (includeObjectLink) path.queryParam("inkluder", getIncludeParameter(false, false, true));
+        return new AsyncStreetsResult(target, Page.defaults().withCount(request.getPageSize()));
+    }
 
-        WebTarget target = getClient().target(path);
+    public StreetsResult getStreets() {
+        return getStreets(new StreetRequest(1000, true));
+    }
+
+    private WebTarget getStreetWebTarget(boolean includeObjectLink) {
+        UriBuilder path = areaRoot().path("gater");
 
-        return getAreas(target).map(AreaParser::parseContractArea).collect(Collectors.toList());
+        if (includeObjectLink) path.queryParam("inkluder", getIncludeParameter(false, false, true));
+
+        return getClient().target(path);
     }
 
-    public List<ContractArea> getContractAreas() {
-        return getContractAreas(false);
+    public List<Route> getNationalRoutes() {
+        return getNationalRoutes(false);
     }
 
-    public List<RoadDepartment> getRoadDepartments(boolean includeObjectLink) {
-        UriBuilder path = areaRoot().path("vegavdelinger");
+    public List<ContractArea> getContractAreas(boolean includeObjectLink) {
+        UriBuilder path = areaRoot().path("kontraktsomrader");
 
         if (includeObjectLink) path.queryParam("inkluder", getIncludeParameter(false, false, true));
 
         WebTarget target = getClient().target(path);
 
-        return getAreas(target).map(AreaParser::parseDepartment).collect(Collectors.toList());
+        return getAreas(target)
+            .map(rt(AreaParser::parseContractArea))
+            .collect(Collectors.toList());
     }
 
-    public List<RoadDepartment> getRoadDepartments() {
-        return getRoadDepartments(false);
+    public List<ContractArea> getContractAreas() {
+        return getContractAreas(false);
     }
 
     private Stream<JsonObject> getAreas(boolean includeBoundingBox, boolean includeCenterPoint, boolean includeObjectLink, Projection projection, WebTarget target) {
@@ -153,12 +164,26 @@ public class AreaClient extends AbstractJerseyClient {
             inkluder.add("vegobjekt");
         }
 
-        return inkluder.stream().collect(Collectors.joining(","));
+        return String.join(",", inkluder);
     }
 
     private UriBuilder areaRoot() {
         return start().path("omrader");
     }
 
+    public static class StreetsResult extends GenericResultSet<ExtendedStreet> {
+
+        public StreetsResult(WebTarget baseTarget,
+                                 Page currentPage) {
+            super(baseTarget, currentPage, "gater", rt(AreaParser::parseStreet));
+        }
+    }
+
+    public static class AsyncStreetsResult extends AsyncResult<ExtendedStreet> {
 
+        public AsyncStreetsResult(WebTarget baseTarget,
+                                      Page currentPage) {
+            super(baseTarget, currentPage, rt(AreaParser::parseStreet));
+        }
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/AsyncArrayResult.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/AsyncArrayResult.java
new file mode 100644
index 0000000..5b834bd
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/AsyncArrayResult.java
@@ -0,0 +1,93 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import com.google.gson.Gson;
+import com.google.gson.JsonObject;
+import com.google.gson.internal.Streams;
+import com.google.gson.stream.JsonReader;
+import no.vegvesen.nvdbapi.client.exceptions.ClientException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.FluxSink;
+
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.function.Function;
+
+public class AsyncArrayResult<T> {
+    private static final Logger logger = LoggerFactory.getLogger(GenericResultSet.class);
+
+    private final WebTarget baseTarget;
+    private final Function<JsonObject, T> parser;
+    private final ExecutorService executorService;
+    private final Gson gson;
+
+    public AsyncArrayResult(WebTarget baseTarget,
+                            Function<JsonObject, T> parser) {
+        this.baseTarget = baseTarget;
+        this.parser = parser;
+        executorService = Executors.newSingleThreadExecutor();
+        gson = new Gson();
+    }
+
+    public Flux<T> get() {
+        return Flux.create(sink -> executorService.execute(() -> {
+            try {
+                doPage(sink);
+            } catch (Exception e) {
+                sink.error(e);
+            } finally {
+                sink.complete();
+                executorService.shutdown();
+            }
+        }));
+    }
+
+    private void doPage(FluxSink<T> sink) throws IOException {
+        WebTarget actualTarget = baseTarget;
+
+        logger.debug("Invoking {}", actualTarget.getUri());
+        Invocation inv = actualTarget.request()
+            .accept(JerseyHelper.MEDIA_TYPE)
+            .buildGet();
+        try(Response response = JerseyHelper.execute(inv, Response.class)) {
+
+            if (!JerseyHelper.isSuccess(response)) {
+                sink.error(JerseyHelper.parseError(response));
+            }
+            String requestId = response.getHeaderString("X-REQUEST-ID");
+
+            try(JsonReader reader = gson.newJsonReader(
+                new InputStreamReader(
+                    new BufferedInputStream(
+                        (InputStream) response.getEntity()), StandardCharsets.UTF_8))) {
+                reader.beginArray();
+                while (reader.hasNext()) {
+                    sink.next(
+                        parser.apply(
+                            Streams.parse(reader).getAsJsonObject()));
+                }
+                reader.endArray();
+
+                /*
+                 Not sure why reader.skipValue() is needed.
+                 If it's left out MalformedChunkCodingException: CRLF expected at end of chunk
+                 some times occurs.
+                 https://stackoverflow.com/questions/8635112/java-malformedchunkcodingexception
+                 */
+                reader.skipValue();
+            } catch (Exception e) {
+                throw new ClientException(response.getStatus(), requestId, Collections.emptyList(), e);
+            }
+        }
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/AsyncResult.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/AsyncResult.java
index 649f34a..386dc4f 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/AsyncResult.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/AsyncResult.java
@@ -3,7 +3,7 @@ package no.vegvesen.nvdbapi.client.clients;
 import com.google.gson.*;
 import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonReader;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
+import no.vegvesen.nvdbapi.client.exceptions.ClientException;
 import no.vegvesen.nvdbapi.client.gson.GsonUtil;
 import no.vegvesen.nvdbapi.client.model.Page;
 import org.slf4j.Logger;
@@ -18,6 +18,8 @@ import java.io.BufferedInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.function.Function;
@@ -38,7 +40,7 @@ public class AsyncResult<T> {
                        Function<JsonObject, T> parser) {
         this.baseTarget = baseTarget;
         this.parser = parser;
-        this.page = page.withCount(7500);
+        this.page = page;
         executorService = Executors.newSingleThreadExecutor();
         gson = new Gson();
     }
@@ -72,11 +74,12 @@ public class AsyncResult<T> {
                 sink.error(JerseyHelper.parseError(response));
                 return new PagingIndicator(false, currentPage);
             }
+            String requestId = response.getHeaderString("X-REQUEST-ID");
 
             try(JsonReader reader = gson.newJsonReader(
                     new InputStreamReader(
                             new BufferedInputStream(
-                            (InputStream) response.getEntity())))) {
+                            (InputStream) response.getEntity()), StandardCharsets.UTF_8))) {
                 reader.beginObject();
                 reader.nextName();
                 reader.beginArray();
@@ -96,7 +99,17 @@ public class AsyncResult<T> {
                 // no next page if last token and next token are equal
                 boolean hasNext = nextToken != null && (!nextToken.equals(token));
                 reader.endObject();
+
+                /*
+                 Not use why reader.skipValue() is needed.
+                 If it's left out MalformedChunkCodingException: CRLF expected at end of chunk
+                 some times occurs.
+                 https://stackoverflow.com/questions/8635112/java-malformedchunkcodingexception
+                 */
+                reader.skipValue();
                 return new PagingIndicator(hasNext, currentPage.withStart(nextToken));
+            } catch (Exception e) {
+                throw new ClientException(response.getStatus(), requestId, Collections.emptyList(), e);
             }
         }
     }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/AuthClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/AuthClient.java
new file mode 100644
index 0000000..e670200
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/AuthClient.java
@@ -0,0 +1,65 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.UriBuilder;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Consumer;
+
+import static java.util.Collections.singletonMap;
+import static javax.ws.rs.core.MediaType.APPLICATION_JSON_TYPE;
+
+class AuthClient extends AbstractJerseyClient {
+    AuthClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
+    }
+
+    public Login login(String username, String password) {
+        return login(username, password, "employee");
+    }
+
+    public Login login(String username, String password, String userType) {
+        UriBuilder path = start()
+            .path("auth")
+            .path("login");
+        WebTarget target = getClient().target(path);
+        try {
+            Login.AuthTokens authTokens = target.request()
+                    .post(Entity.entity(credentialsJson(username, password, userType), APPLICATION_JSON_TYPE), Login.AuthTokens.class);
+            return Login.success(authTokens);
+        } catch (Exception e) {
+            return Login.failed(e.getMessage());
+        }
+    }
+
+
+    public Login refresh(String refreshToken) {
+        UriBuilder path = start()
+            .path("auth")
+            .path("refresh");
+        WebTarget target = getClient().target(path);
+        try {
+            Login.AuthTokens authTokens = target.request()
+                .post(Entity.entity(refreshJson(refreshToken), APPLICATION_JSON_TYPE), Login.AuthTokens.class);
+            return Login.success(authTokens);
+        } catch (Exception e) {
+            return Login.failed(e.getMessage());
+        }
+    }
+
+    private Map<String, String> refreshJson(String refreshToken) {
+        return singletonMap("refreshToken", refreshToken);
+    }
+
+
+    private Map<String, String> credentialsJson(String username, String password, String userType) {
+        Map<String, String> credentials = new HashMap<>();
+        credentials.put("username", username);
+        credentials.put("password", password);
+        credentials.put("user_type", userType);
+        return credentials;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/ClientFactory.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/ClientFactory.java
index a9e33da..1e834c6 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/ClientFactory.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/ClientFactory.java
@@ -25,13 +25,30 @@
 
 package no.vegvesen.nvdbapi.client.clients;
 
-import no.vegvesen.nvdbapi.client.clients.filters.RequestHeaderFilter;
-import no.vegvesen.nvdbapi.client.gson.GsonMessageBodyHandler;
-import no.vegvesen.nvdbapi.client.model.datakatalog.Datakatalog;
-import no.vegvesen.nvdbapi.client.util.LoggingFilter;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.lang.reflect.Proxy;
+import java.net.URL;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.jar.Attributes;
+import java.util.jar.Manifest;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import com.google.gson.stream.JsonReader;
+import org.apache.http.conn.HttpClientConnectionManager;
 import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
+import org.apache.http.pool.ConnPoolControl;
 import org.glassfish.jersey.apache.connector.ApacheClientProperties;
-//import org.glassfish.jersey.apache.connector.ApacheConnectorProvider;
+import org.glassfish.jersey.apache.connector.ApacheConnectorProvider;
 import org.glassfish.jersey.client.ClientConfig;
 import org.glassfish.jersey.client.ClientProperties;
 import org.glassfish.jersey.message.DeflateEncoder;
@@ -39,60 +56,224 @@ import org.glassfish.jersey.message.GZipEncoder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.ws.rs.client.Client;
-import javax.ws.rs.client.ClientBuilder;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Optional;
+import no.vegvesen.nvdbapi.client.ClientConfiguration;
+import no.vegvesen.nvdbapi.client.ProxyConfig;
+import no.vegvesen.nvdbapi.client.gson.GsonMessageBodyHandler;
+import no.vegvesen.nvdbapi.client.model.datakatalog.Datakatalog;
+import no.vegvesen.nvdbapi.client.model.datakatalog.Version;
+import no.vegvesen.nvdbapi.client.util.LoggingFilter;
+
+import static java.nio.file.StandardOpenOption.CREATE;
+import static java.util.Objects.isNull;
 
 public final class ClientFactory implements AutoCloseable {
     private final String baseUrl;
     private final String userAgent;
     private final String xClientName;
+    private final String xSession;
 
-    private final String apiRevision = "application/vnd.vegvesen.nvdb-v2-rev2+json";
+    static final String apiRevision = "application/vnd.vegvesen.nvdb-v3-rev2+json";
     private final ProxyConfig proxyConfig;
+    private final ClientConfiguration clientConfig;
 
     private Datakatalog datakatalog;
-    private List<AbstractJerseyClient> clients;
+    private Version datakatalogVersion;
+    private final Map<Class<? extends AbstractJerseyClient>, AbstractJerseyClient> clients;
     private boolean isClosed;
     private final Logger debugLogger;
-    private PoolingHttpClientConnectionManager connectionManager;
+    private final PoolingHttpClientConnectionManager connectionManager;
+    /*
+     * Each of or Clients have their own {@code javax.ws.rs.client.Client}, that share a
+     * {@code org.apache.http.impl.conn.PoolingHttpClientConnectionManager}.
+     * If {@code close()} is called on our client, the connection manager is shutdown.
+     */
+    private final HttpClientConnectionManager notCloseableConnectionManager;
 
-    public ClientFactory(String baseUrl, String userAgent, String xClientName) {
-        this(baseUrl, userAgent, xClientName, null, null);
+    private Login.AuthTokens authTokens;
+
+    /**
+     * @param baseUrl - what base url to use. For production: https://nvdbapiles-v3.atlas.vegvesen.no
+     * @param xClientName - a name describing/name of your consumer application.
+     */
+    public ClientFactory(String baseUrl, String xClientName) {
+        this(baseUrl, xClientName, (ProxyConfig) null);
+    }
+
+    /**
+     * @param baseUrl - what base url to use. For production: https://nvdbapiles-v3.atlas.vegvesen.no
+     * @param xClientName - a name describing/name of your consumer application.
+     * @param clientConfiguration - a client configuration for setting timeouts
+     */
+    public ClientFactory(String baseUrl, String xClientName, ClientConfiguration clientConfiguration) {
+        this(baseUrl, xClientName, null, null, clientConfiguration);
+    }
+
+    /**
+     * @param baseUrl - what base url to use. For production: https://nvdbapiles-v3.atlas.vegvesen.no
+     * @param xClientName - a name describing/name of your consumer application.
+     * @param proxyConfig - Config if traffic have to go through proxy.
+     */
+    public ClientFactory(String baseUrl, String xClientName, ProxyConfig proxyConfig) {
+        this(baseUrl, xClientName, null, proxyConfig);
+    }
+
+    /**
+     * @param baseUrl - what base url to use. For production: https://nvdbapiles-v3.atlas.vegvesen.no
+     * @param xClientName - a name describing/name of your consumer application.
+     * @param proxyConfig - Config if traffic have to go through proxy.
+     * @param clientConfiguration - a client configuration for setting timeouts
+     */
+    public ClientFactory(String baseUrl, String xClientName, ProxyConfig proxyConfig, ClientConfiguration clientConfiguration) {
+        this(baseUrl, xClientName, null, proxyConfig, clientConfiguration);
     }
 
-    public ClientFactory(String baseUrl, String userAgent, String xClientName, ProxyConfig proxyConfig) {
-        this(baseUrl, userAgent, xClientName, null, proxyConfig);
+    /**
+     * @param baseUrl - what base url to use. For production: https://nvdbapiles-v3.atlas.vegvesen.no
+     * @param xClientName - a name describing/name of your consumer application.
+     * @param xSession - something identifying this session. Used to tag a sequence of requests, such that
+     *                 if there are several instances that have the same xClientName it is possible to tell
+     *                 the requests of each instance apart.
+     *                 Use a uuid or something similar. not something that can identify a user, like username or email.
+     * @param proxyConfig - Config if traffic have to go through proxy.
+     */
+    public ClientFactory(String baseUrl, String xClientName, String xSession, ProxyConfig proxyConfig) {
+        this(baseUrl, xClientName, xSession, proxyConfig, null);
     }
 
-    public ClientFactory(String baseUrl, String userAgent, String xClientName, String debugLogName, ProxyConfig proxyConfig) {
+    /**
+     * @param baseUrl - what base url to use. For production: https://nvdbapiles-v3.atlas.vegvesen.no
+     * @param xClientName - a name describing/name of your consumer application.
+     * @param xSession - something identifying this session. Used to tag a sequence of requests, such that
+     *                 if there are several instances that have the same xClientName it is possible to tell
+     *                 the requests of each instance apart.
+     *                 Use a uuid or something similar. not something that can identify a user, like username or email.
+     * @param proxyConfig - Config if traffic have to go through proxy.
+     * @param clientConfig - a client configuration for setting timeouts
+     */
+    public ClientFactory(String baseUrl, String xClientName, String xSession, ProxyConfig proxyConfig, ClientConfiguration clientConfig) {
         this.baseUrl = baseUrl;
-        this.userAgent = userAgent;
         this.xClientName = xClientName;
-        this.debugLogger = Optional.ofNullable(debugLogName)
-                                   .filter(s -> s.trim().length() > 0)
-                                   .map(LoggerFactory::getLogger)
-                                   .orElse(null);
-        this.clients = new ArrayList<>();
+        this.xSession = Optional.ofNullable(xSession).orElseGet(this::getOrCreateSessionId);
+        this.userAgent = getUserAgent();
+        this.debugLogger = LoggerFactory.getLogger("no.vegvesen.nvdbapi.Client");
+        this.clients = new HashMap<>();
         this.connectionManager = new PoolingHttpClientConnectionManager();
+        this.notCloseableConnectionManager = getConnectionManager(connectionManager);
         this.proxyConfig = proxyConfig;
+        this.clientConfig = clientConfig;
     }
 
-    public ClientFactory(String baseUrl) {
-        this(baseUrl, null, null, null, null);
+    private String getUserAgent() {
+        return "nvdb-api-client-" + getClientVersion();
     }
 
     public boolean isClosed() {
         return isClosed;
     }
 
-    public RoadNetClient createRoadNetService() {
-        assertIsOpen();
-        RoadNetClient c = new RoadNetClient(baseUrl, createClient(getDatakatalog().getVersion().getVersion()));
-        clients.add(c);
-        return c;
+    /**
+     * Authenticate with username and password.
+     * If successful the {@code AuthTokens} recieved is used in followinf calls.
+     * @param username -
+     * @param password -
+     * @return {@code Login} containing either {@code AuthTokens} if successful or {@code Failure} if not
+     */
+    public Login login(String username, String password) {
+        try {
+            AuthClient client = getAuthClient();
+            Login login = client.login(username, password);
+            if(login.isSuccessful()) {
+                this.authTokens = login.authTokens;
+            }
+            return login;
+        } catch (Exception e) {
+            debugLogger.error("Login failed", e);
+            return Login.failed(e.getMessage());
+        }
+    }
+
+    /**
+     * Variant authentication for service accounts using username and password.
+     * If successful the {@code AuthTokens} recieved is used in followinf calls.
+     * @param username -
+     * @param password -
+     * @return {@code Login} containing either {@code AuthTokens} if successful or {@code Failure} if not
+     */
+    public Login serviceLogin(String username, String password) {
+        try {
+            AuthClient client = getAuthClient();
+            Login login = client.login(username, password,"serviceaccount");
+            if(login.isSuccessful()) {
+                this.authTokens = login.authTokens;
+            }
+            return login;
+        } catch (Exception e) {
+            debugLogger.error("Login failed", e);
+            return Login.failed(e.getMessage());
+        }
+    }
+
+    /**
+     * clear the ClientFactory's auth tokens.
+     */
+    public void logout() {
+        this.authTokens = null;
+    }
+
+    private AuthClient getAuthClient() {
+        return getOrCreateClient(AuthClient.class, AuthClient::new);
+    }
+
+    /**
+     * Use an existing refresh token to authenticate.
+     * @param refreshToken from a previous session
+     * @return {@code Login} containing either {@code AuthTokens} if successful or {@code Failure} if not
+     */
+    public Login refresh(String refreshToken) {
+        try {
+            AuthClient client = getAuthClient();
+            Login refresh = client.refresh(refreshToken);
+            if(refresh.isSuccessful()) {
+                this.authTokens = refresh.authTokens;
+            }
+            return refresh;
+        } catch (Exception e) {
+            debugLogger.error("Login failed", e);
+            return Login.failed(e.getMessage());
+        }
+    }
+
+    /**
+     * Refresh authentication using internal {@code AuthTokens}.
+     * @return {@code Login} containing either {@code AuthTokens} if successful or {@code Failure} if not
+     */
+    public Login refresh() {
+        if(isNull(this.authTokens)) {
+            throw new IllegalStateException("Tried to refresh without existing AuthTokens");
+        }
+
+        return refresh(this.authTokens.refreshToken);
+    }
+
+    /**
+     * @return a new instance of {@code RoadNetClient}, or existing if one exists
+     */
+    public RoadNetClient getRoadNetService() {
+        return getOrCreateClient(RoadNetClient.class, RoadNetClient::new);
+    }
+
+    /**
+     * @return a new instance of {@code SegmentedRoadNetClient}, or existing if one exists
+     */
+    public SegmentedRoadNetClient getSegmentedRoadNetService() {
+        return getOrCreateClient(SegmentedRoadNetClient.class, SegmentedRoadNetClient::new);
+    }
+
+    /**
+     * @return a new instance of {@code RoadNetRouteClient}, or existing if one exists
+     */
+    public RoadNetRouteClient getRoadNetRouteClient() {
+        return getOrCreateClient(RoadNetRouteClient.class, RoadNetRouteClient::new);
     }
 
     private void assertIsOpen() {
@@ -101,73 +282,103 @@ public final class ClientFactory implements AutoCloseable {
         }
     }
 
-    public DatakatalogClient createDatakatalogClient() {
-        assertIsOpen();
-        DatakatalogClient c = new DatakatalogClient(baseUrl, createClient(null));
-        clients.add(c);
-        return c;
+    /**
+     * @return a new instance of {@code DatakatalogClient}, or existing if one exists
+     */
+    public DatakatalogClient getDatakatalogClient() {
+        return getOrCreateClient(DatakatalogClient.class, DatakatalogClient::new);
     }
 
     public Datakatalog getDatakatalog() {
         if (datakatalog == null) {
-            datakatalog = createDatakatalogClient().getDatakalog();
+            datakatalog = getDatakatalogClient().getDatakalog();
         }
         return datakatalog;
     }
 
-    public AreaClient createAreaClient() {
-        assertIsOpen();
-        AreaClient c = new AreaClient(baseUrl, createClient(getDatakatalog().getVersion().getVersion()));
-        clients.add(c);
-        return c;
+    public Version getDatakatalogVersion() {
+        if (datakatalogVersion == null) {
+            datakatalogVersion = getDatakatalogClient().getVersion();
+        }
+        return datakatalogVersion;
     }
 
-    public RoadObjectClient createRoadObjectClient() {
-        assertIsOpen();
-        RoadObjectClient c = new RoadObjectClient(baseUrl, createClient(getDatakatalog().getVersion().getVersion()), getDatakatalog());
-        clients.add(c);
-        return c;
+    /**
+     * @return a new instance of {@code AreaClient}, or existing if one exists
+     */
+    public AreaClient getAreaClient() {
+        return getOrCreateClient(AreaClient.class, AreaClient::new);
     }
 
-    public PositionClient createPlacementClient() {
-        assertIsOpen();
-        PositionClient c = new PositionClient(baseUrl, createClient(getDatakatalog().getVersion().getVersion()));
-        clients.add(c);
-        return c;
+    /**
+     * @return a new instance of {@code RoadObjectClient}, or existing if one exists
+     */
+    public RoadObjectClient getRoadObjectClient() {
+        return getRoadObjectClient(DatakatalogPolicy.defaultPolicy());
     }
 
-    public RoadPlacementClient createRoadPlacementClient() {
-        assertIsOpen();
-        RoadPlacementClient c = new RoadPlacementClient(baseUrl, createClient(getDatakatalog().getVersion().getVersion()));
-        clients.add(c);
-        return c;
+    /**
+     * @param datakatalogPolicy How to handle that the Datakatalog is updated.
+     * @return a new instance of {@code RoadObjectClient}, or existing if one exists
+     */
+    public RoadObjectClient getRoadObjectClient(DatakatalogPolicy datakatalogPolicy) {
+        String version = getDatakatalogVersion().getVersion();
+        return getOrCreateClient(
+            RoadObjectClient.class,
+            RoadObjectClient::new,
+            config -> config.register(datakatalogPolicy.getFilter(version))
+        );
     }
 
-    public StatusClient createStatusClient() {
-        assertIsOpen();
-        StatusClient c = new StatusClient(baseUrl, createClient(null));
-        clients.add(c);
-        return c;
+    /**
+     * @return a new instance of {@code PositionClient}, or existing if one exists
+     */
+    public PositionClient getPlacementClient() {
+        return getOrCreateClient(PositionClient.class, PositionClient::new);
     }
 
-    private Client createClient(String datakatalogVersion) {
-        return createClient(datakatalogVersion, true);
+    /**
+     * @return a new instance of {@code RoadPlacementClient}, or existing if one exists
+     */
+    public RoadPlacementClient getRoadPlacementClient() {
+        return getOrCreateClient(RoadPlacementClient.class, RoadPlacementClient::new);
     }
 
-    private Client createClient(String datakatalogVersion, boolean enableCompression) {
-        ClientConfig config = new ClientConfig();
-        if (enableCompression) {
-            config.register(GZipEncoder.class);
-            config.register(DeflateEncoder.class);
-        }
+    /**
+     * @return a new instance of {@code StatusClient}, or existing if one exists
+     */
+    public StatusClient getStatusClient() {
+        return getOrCreateClient(StatusClient.class, StatusClient::new);
+    }
+
+    /**
+     * @return a new instance of {@code TransactionsClient}, or existing if one exists
+     */
+    public TransactionsClient getTransactionsClient(){
+        return getOrCreateClient(TransactionsClient.class, TransactionsClient::new);
+    }
+
+    private Client createClient() {
+        return createClient(Function.identity());
+    }
+
+    private Client createClient(Function<ClientConfig, ClientConfig> clientConfigCustomizer) {
+        ClientConfig config = new ClientConfig()
+            .register(GZipEncoder.class)
+            .register(DeflateEncoder.class)
+            .connectorProvider(new ApacheConnectorProvider())
+            .property(ApacheClientProperties.CONNECTION_MANAGER, notCloseableConnectionManager)
+            .register(GsonMessageBodyHandler.class)
+            .register(
+                new RequestHeaderFilter(
+                    userAgent,
+                    xClientName,
+                    xSession,
+                    apiRevision,
+                    () -> authTokens));
         if (debugLogger != null) {
             config.register(new LoggingFilter(debugLogger, true));
         }
-       // config.connectorProvider(new ApacheConnectorProvider());
-
-        config.property(ApacheClientProperties.CONNECTION_MANAGER, connectionManager);
-        config.register(GsonMessageBodyHandler.class);
-        config.register(new RequestHeaderFilter(userAgent, xClientName, datakatalogVersion, enableCompression, apiRevision));
 
         if (proxyConfig != null) {
             config.property(ClientProperties.PROXY_URI, proxyConfig.getUrl());
@@ -176,19 +387,143 @@ public final class ClientFactory implements AutoCloseable {
                 config.property(ClientProperties.PROXY_PASSWORD, proxyConfig.getPassword());
             }
         }
-        return ClientBuilder.newBuilder().withConfig(config).build();
+        if (clientConfig != null) {
+            config.property(ClientProperties.READ_TIMEOUT, clientConfig.getReadTimeout());
+            config.property(ClientProperties.CONNECT_TIMEOUT, clientConfig.getConnectTimeout());
+        }
+
+        return ClientBuilder.newBuilder()
+            .withConfig(
+                clientConfigCustomizer.apply(config)
+            )
+            .build();
     }
 
     @Override
     public void close() throws Exception {
-        if (!clients.isEmpty()) {
-            for (AbstractJerseyClient client : clients) {
-                if (!client.isClosed()) {
-                    client.close();
-                }
+        for (AbstractJerseyClient client : new ArrayList<>(clients.values())) {
+            if (!client.isClosed()) {
+                client.close();
             }
         }
         connectionManager.close();
         isClosed = true;
     }
+
+    private <T extends AbstractJerseyClient> T getOrCreateClient(
+        Class<T> type,
+        ClientConstructor<T> clientConstructor) {
+        return getOrCreateClient(type, clientConstructor, Function.identity());
+    }
+
+    @SuppressWarnings("unchecked")
+    private <T extends AbstractJerseyClient> T getOrCreateClient(
+        Class<T> type,
+        ClientConstructor<T> clientConstructor,
+        Function<ClientConfig, ClientConfig> clientConfigCustomizer) {
+        assertIsOpen();
+        return (T) clients.computeIfAbsent(
+            type,
+            aClass -> clientConstructor.apply(
+                baseUrl,
+                createClient(clientConfigCustomizer),
+                c -> clients.remove(type))
+        );
+    }
+
+    @FunctionalInterface
+    private interface ClientConstructor<C extends AbstractJerseyClient> {
+        C apply(String url, Client client, Consumer<AbstractJerseyClient> onClose);
+    }
+
+    private String getClientVersion() {
+        try {
+            Enumeration<URL> resources = getClass().getClassLoader()
+                .getResources("META-INF/MANIFEST.MF");
+            while (resources.hasMoreElements()) {
+                Manifest manifest = new Manifest(resources.nextElement().openStream());
+                Attributes attributes = manifest.getMainAttributes();
+                if("nvdb-api-client".equals(attributes.getValue("Implementation-Title"))) {
+                    return attributes.getValue("Implementation-Version");
+                }
+            }
+        } catch (IOException E) { /* ignore */ }
+        return "unknown";
+    }
+
+    private String getOrCreateSessionId() {
+        try {
+            File dotFolder = getClientHome();
+            File sessionIdFile = new File(dotFolder, "session");
+            if(sessionIdFile.exists()) {
+                return Files.readAllLines(sessionIdFile.toPath(), StandardCharsets.UTF_8).get(0);
+            } else {
+                String sessionId = UUID.randomUUID().toString();
+                Files.write(sessionIdFile.toPath(), sessionId.getBytes(StandardCharsets.UTF_8), CREATE);
+                return sessionId;
+            }
+        } catch (IOException e) {
+            return UUID.randomUUID().toString();
+        }
+    }
+
+    private static File getClientHome() {
+        String userHome = System.getProperty("java.io.tmpdir");
+        File dotFolder = new File(userHome, ".nvdb-api-read-v3");
+        if(!dotFolder.exists()) {
+            dotFolder.mkdir();
+        }
+        return dotFolder;
+    }
+
+    public static Optional<String> getEtag(String resource) {
+        File etagFile = new File(getClientHome(), resource.replace('/', '_') + ".etag");
+        if(etagFile.exists()) {
+            try {
+                return Optional.of(Files.readAllLines(etagFile.toPath(), StandardCharsets.UTF_8).get(0));
+            } catch (IOException e) {
+                LoggerFactory.getLogger(ClientFactory.class).error("Error getting etag for {}", resource, e);
+            }
+        }
+        return Optional.empty();
+    }
+
+    public static Optional<JsonElement> getResponse(String resource) {
+        File etagFile = new File(getClientHome(), resource.replace('/', '_') + ".json");
+        if(etagFile.exists()) {
+            try {
+                return Optional.of(
+                    JsonParser.parseReader(new JsonReader(new FileReader(etagFile)))
+                );
+            } catch (IOException e) {
+                LoggerFactory.getLogger(ClientFactory.class).error("Error getting body for {}", resource, e);
+            }
+        }
+        return Optional.empty();
+    }
+
+    public static void setEtag(String resource, String etag, String body) {
+        try {
+            String r = resource.replace('/', '_');
+            File etagFile = new File(getClientHome(), r + ".etag");
+            Files.write(etagFile.toPath(), etag.getBytes(StandardCharsets.UTF_8), CREATE);
+            File bodyFile = new File(getClientHome(), r + ".json");
+            Files.write(bodyFile.toPath(), body.getBytes(StandardCharsets.UTF_8), CREATE);
+        } catch (IOException e) {
+            LoggerFactory.getLogger(ClientFactory.class).error("Error setting etag for {}", resource, e);
+        }
+    }
+
+    private static HttpClientConnectionManager getConnectionManager(PoolingHttpClientConnectionManager connectionManager) {
+        return (HttpClientConnectionManager) Proxy.newProxyInstance(
+            PoolingHttpClientConnectionManager.class.getClassLoader(),
+            new Class[]{HttpClientConnectionManager.class, ConnPoolControl.class, Closeable.class},
+            (proxy, method, args) -> {
+                if(method.getName().equals("shutdown")) {
+                    return null;
+                } else {
+                    return method.invoke(connectionManager, args);
+                }
+            });
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogClient.java
index c3682ef..e8cbbe5 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogClient.java
@@ -27,7 +27,6 @@ package no.vegvesen.nvdbapi.client.clients;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
 import no.vegvesen.nvdbapi.client.gson.AttributeTypeParser;
 import no.vegvesen.nvdbapi.client.gson.FeatureTypeParser;
 import no.vegvesen.nvdbapi.client.gson.DatakatalogVersionParser;
@@ -40,16 +39,22 @@ import javax.ws.rs.client.Client;
 import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.UriBuilder;
 import java.util.*;
-import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
+import static java.util.Objects.isNull;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
+
 public class DatakatalogClient extends AbstractJerseyClient {
     private static final Logger LOG = LoggerFactory.getLogger(DatakatalogClient.class);
 
-    protected DatakatalogClient(String baseUrl, Client client) {
-        super(baseUrl, client);
+    private Map<String, DataType> dataTypes;
+
+    DatakatalogClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
     }
 
     public Version getVersion() {
@@ -61,25 +66,31 @@ public class DatakatalogClient extends AbstractJerseyClient {
     }
 
     public List<DataType> getDataTypes() {
+        return getDataTypeStream()
+                .collect(Collectors.toList());
+    }
+
+    private Stream<DataType> getDataTypeStream() {
         WebTarget target = getClient().target(endpoint()).path("datatyper");
-        JsonElement types = JerseyHelper.execute(target);
+        JsonElement types = JerseyHelper.executeOptional(target)
+            .orElseThrow(() -> new IllegalStateException("Could not get response for datatyper"));
         return StreamSupport.stream(types.getAsJsonArray().spliterator(), false)
-                .map(JsonElement::getAsJsonObject)
-                .map(AttributeTypeParser::parseDataType)
-                .collect(Collectors.toList());
+            .map(JsonElement::getAsJsonObject)
+            .map(rt(AttributeTypeParser::parseDataType));
     }
 
-    public Map<Integer, DataType> getDataTypeMap() {
-        return getDataTypes().stream()
-                             .collect(Collectors.toMap(DataType::getId, Function.identity()));
+    public Map<String, DataType> getDataTypeMap() {
+        return getDataTypeStream()
+                             .collect(Collectors.toMap(DataType::getName, Function.identity()));
     }
 
     public List<Unit> getUnits() {
         WebTarget target = getClient().target(endpoint()).path("enheter");
-        JsonElement units = JerseyHelper.execute(target);
+        JsonElement units = JerseyHelper.executeOptional(target)
+            .orElseThrow(() -> new IllegalStateException("Could not get response for enheter"));
         return StreamSupport.stream(units.getAsJsonArray().spliterator(), false)
                 .map(JsonElement::getAsJsonObject)
-                .map(AttributeTypeParser::parseUnit)
+                .map(rt(AttributeTypeParser::parseUnit))
                 .collect(Collectors.toList());
     }
 
@@ -88,7 +99,16 @@ public class DatakatalogClient extends AbstractJerseyClient {
         JsonElement units = JerseyHelper.execute(target);
         return StreamSupport.stream(units.getAsJsonArray().spliterator(), false)
                 .map(JsonElement::getAsJsonObject)
-                .map(FeatureTypeParser::parseCategory)
+                .map(rt(FeatureTypeParser::parseCategory))
+                .collect(Collectors.toList());
+    }
+
+    public List<AttributeTypeCategory> getAttributeTypeCategories() {
+        WebTarget target = getClient().target(endpoint()).path("egenskapstypekategorier");
+        JsonElement units = JerseyHelper.execute(target);
+        return StreamSupport.stream(units.getAsJsonArray().spliterator(), false)
+                .map(JsonElement::getAsJsonObject)
+                .map(rt(AttributeTypeParser::parseCategory))
                 .collect(Collectors.toList());
     }
 
@@ -97,27 +117,34 @@ public class DatakatalogClient extends AbstractJerseyClient {
                          .collect(Collectors.toMap(Unit::getId, Function.identity()));
     }
 
-    public Optional<AttributeType> getAttributeType(Map<Integer, DataType> dataTypes, int typeId) {
+    public Optional<AttributeType> getAttributeType(int typeId) {
+        initDataTypes();
         WebTarget target = getClient().target(endpoint()).path("egenskapstyper").path(Integer.toString(typeId));
         return JerseyHelper.executeOptional(target)
                            .map(JsonElement::getAsJsonObject)
                            .map(o -> AttributeTypeParser.parse(dataTypes, o));
     }
 
+    private void initDataTypes() {
+        if(isNull(this.dataTypes)) {
+            this.dataTypes = getDataTypeMap();
+        }
+    }
+
     public Datakatalog getDatakalog() {
         Version v = getVersion();
         List<Unit> units = getUnits();
-        Map<Integer, DataType> dataTypes = getDataTypeMap();
+        Map<String, DataType> dataTypes = getDataTypeMap();
 
-        List<FeatureType> featureTypes = getFeatureTypes(dataTypes, Include.ALL);
+        List<FeatureType> featureTypes = getFeatureTypes(Include.ALL);
         return new Datakatalog(v, featureTypes, units, dataTypes);
     }
 
-    public List<FeatureType> getFeatureTypes(Map<Integer, DataType> dataTypes, Include... informationToInclude) {
-        return getFeatureTypes(dataTypes, -1, informationToInclude);
+    public List<FeatureType> getFeatureTypes(Include... informationToInclude) {
+        return getFeatureTypes(-1, informationToInclude);
     }
 
-    public List<FeatureType> getFeatureTypes(Map<Integer, DataType> dataTypes, int category, Include... informationToInclude) {
+    public List<FeatureType> getFeatureTypes(int category, Include... informationToInclude) {
         UriBuilder url = endpoint();
         String includeArgument = getIncludeArgument(false, informationToInclude);
         if (includeArgument != null) url.queryParam("inkluder", includeArgument);
@@ -125,28 +152,33 @@ public class DatakatalogClient extends AbstractJerseyClient {
 
         WebTarget target = getClient().target(url);
 
-        List<FeatureType> types = new ArrayList<>();
         Stopwatch sw = Stopwatch.createStarted();
         JsonArray array = JerseyHelper.executeOptional(target)
                                       .map(JsonElement::getAsJsonArray)
                                       .get();
         long requestTime = sw.stop().elapsedMillis();
         sw = Stopwatch.createStarted();
-        array.forEach(e -> types.add(FeatureTypeParser.parse(dataTypes, e.getAsJsonObject())));
+        initDataTypes();
+
+        List<FeatureType> types = StreamSupport.stream(array.getAsJsonArray().spliterator(), false)
+            .map(JsonElement::getAsJsonObject)
+            .map(rt(o -> FeatureTypeParser.parse(this.dataTypes, o)))
+            .collect(Collectors.toList());
+
         long parsingTime = sw.stop().elapsedMillis();
         LOG.debug("Request execution took {} ms. Request parsing took {} ms. Total: {} ms.", requestTime, parsingTime, requestTime + parsingTime);
         return types;
     }
 
-    public Optional<FeatureType> getFeatureType(Map<Integer, DataType> types, int typeId, Include... informationToInclude) {
+    public Optional<FeatureType> getFeatureType(int typeId, Include... informationToInclude) {
         WebTarget target = getClient().target(endpoint().path(Integer.toString(typeId)));
 
         String includeArgument = getIncludeArgument(true, informationToInclude);
         if (includeArgument != null) target = target.queryParam("inkluder", includeArgument);
-
+        initDataTypes();
         return JerseyHelper.executeOptional(target)
                            .map(JsonElement::getAsJsonObject)
-                           .map(o -> FeatureTypeParser.parse(types, o));
+                           .map(rt(o -> FeatureTypeParser.parse(this.dataTypes, o)));
     }
 
     private static String getIncludeArgument(boolean singleRequest, Include... informationToInclude) {
@@ -175,6 +207,7 @@ public class DatakatalogClient extends AbstractJerseyClient {
         ATTRIBUTES("egenskapstyper"),
         ASSOCIATIONS("relasjonstyper"),
         GUIDANCE_PARAMETERS("styringsparametere"),
+        LOCATIONAL("stedfesting"),
         ALL("alle");
 
         private final String value;
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogFilter.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogFilter.java
new file mode 100644
index 0000000..58f5f80
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogFilter.java
@@ -0,0 +1,47 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.ws.rs.client.ClientRequestContext;
+import javax.ws.rs.client.ClientRequestFilter;
+import javax.ws.rs.client.ClientResponseContext;
+import javax.ws.rs.client.ClientResponseFilter;
+import javax.ws.rs.core.MultivaluedMap;
+import java.io.IOException;
+import java.util.Objects;
+
+class DatakatalogFilter implements ClientRequestFilter, ClientResponseFilter {
+    private static final Logger log = LoggerFactory.getLogger("no.vegvesen.nvdbapi.Client.Datakatalog");
+    private static final String DAKAT_VERSION = "X-Datakatalog-Versjon";
+    private final boolean sendDatakatalogVersion;
+    private final DatakatalogUpdateCallback callback;
+
+    private String dakatVersion;
+
+    DatakatalogFilter(String dakatVersion,
+                             boolean sendDatakatalogVersion,
+                             DatakatalogUpdateCallback callback) {
+        this.dakatVersion = dakatVersion;
+        this.sendDatakatalogVersion = sendDatakatalogVersion;
+        this.callback = callback;
+    }
+
+    @Override
+    public void filter(ClientRequestContext requestContext) throws IOException {
+        if (sendDatakatalogVersion && dakatVersion != null){
+            MultivaluedMap<String, Object> headers = requestContext.getHeaders();
+            headers.putSingle(DAKAT_VERSION, dakatVersion);
+        }
+    }
+
+    @Override
+    public void filter(ClientRequestContext requestContext, ClientResponseContext responseContext) throws IOException {
+        String dakatVersion = responseContext.getHeaderString(DAKAT_VERSION);
+        if(!Objects.equals(dakatVersion, this.dakatVersion) && dakatVersion != null) {
+            log.info("Datakatalog version changed from {} to {}", this.dakatVersion, dakatVersion);
+            this.dakatVersion = dakatVersion;
+            callback.onDatakatalogUpdate();
+        }
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogPolicy.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogPolicy.java
new file mode 100644
index 0000000..cf39d93
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogPolicy.java
@@ -0,0 +1,55 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+public class DatakatalogPolicy {
+    private final boolean sendDakatHeader;
+    private final DatakatalogUpdateCallback callback;
+
+    private DatakatalogPolicy(boolean sendDakatHeader, DatakatalogUpdateCallback callback) {
+        this.sendDakatHeader = sendDakatHeader;
+        this.callback = callback;
+    }
+
+    public static DatakatalogPolicy defaultPolicy() {
+        return DatakatalogPolicy.builder().build();
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public DatakatalogFilter getFilter(String datakatVersion) {
+        return new DatakatalogFilter(datakatVersion, sendDakatHeader, callback);
+    }
+
+    public static class Builder {
+        private boolean sendDakatHeader = false;
+        private DatakatalogUpdateCallback callback = () -> {};
+
+        private Builder() {}
+
+        /**
+         * NVDB API LES has a mechanism that checks header «X-Datakatalog-Versjon», and if it differs from the
+         * current version of Datakatalogen, returns HTTP 422: Nåværende datakatalogversjon i APIet er: {new version}
+         * @param sendDakatHeader - true if header «X-Datakatalog-Versjon» should be sent.
+         * @return this
+         */
+        public Builder sendDakatHeader(boolean sendDakatHeader) {
+            this.sendDakatHeader = sendDakatHeader;
+            return this;
+        }
+
+        /**
+         * The given callback is called when the version of Datakatalogen has changed.
+         * @param callback when Datakatalog version has changed.
+         * @return this
+         */
+        public Builder onDatakatalogUpdateCallback(DatakatalogUpdateCallback callback) {
+            this.callback = callback;
+            return this;
+        }
+
+        public DatakatalogPolicy build() {
+            return new DatakatalogPolicy(sendDakatHeader, callback);
+        }
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogUpdateCallback.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogUpdateCallback.java
new file mode 100644
index 0000000..c3fcb10
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/DatakatalogUpdateCallback.java
@@ -0,0 +1,6 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+@FunctionalInterface
+public interface DatakatalogUpdateCallback {
+    void onDatakatalogUpdate();
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/GenericResultSet.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/GenericResultSet.java
index 9f5c835..80e02e0 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/GenericResultSet.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/GenericResultSet.java
@@ -25,10 +25,8 @@
 
 package no.vegvesen.nvdbapi.client.clients;
 
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
+import com.google.gson.*;
+import no.vegvesen.nvdbapi.client.exceptions.ClientException;
 import no.vegvesen.nvdbapi.client.gson.GsonUtil;
 import no.vegvesen.nvdbapi.client.model.Page;
 import no.vegvesen.nvdbapi.client.model.ResultSet;
@@ -39,9 +37,12 @@ import org.slf4j.LoggerFactory;
 import javax.ws.rs.client.Invocation;
 import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.Response;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
@@ -52,14 +53,28 @@ public class GenericResultSet<T> implements ResultSet<T> {
 
     private final WebTarget baseTarget;
     private final Function<JsonObject, T> parser;
+    private final String objekterField;
     private Page currentPage;
     private String token;
     private boolean hasNext = true;
 
-    protected GenericResultSet(WebTarget baseTarget, Optional<Page> currentPage, Function<JsonObject, T> parser) {
+    protected GenericResultSet(WebTarget baseTarget,
+                               Page currentPage,
+                               Function<JsonObject, T> parser) {
         this.baseTarget = baseTarget;
         this.parser = parser;
-        this.currentPage = currentPage.orElse(null);
+        this.currentPage = currentPage;
+        this.objekterField = "objekter";
+    }
+
+    protected GenericResultSet(WebTarget baseTarget,
+                               Page currentPage,
+                               String objekterField,
+                               Function<JsonObject, T> parser) {
+        this.baseTarget = baseTarget;
+        this.parser = parser;
+        this.currentPage = currentPage;
+        this.objekterField = objekterField;
     }
 
     public List<T> getAll() {
@@ -86,42 +101,51 @@ public class GenericResultSet<T> implements ResultSet<T> {
         if (currentPage != null) actualTarget = applyPage(currentPage, baseTarget);
         logger.debug("Invoking {}", actualTarget.getUri());
         Invocation inv = actualTarget.request().accept(JerseyHelper.MEDIA_TYPE).buildGet();
-        Response response = JerseyHelper.execute(inv, Response.class);
 
-        if (!JerseyHelper.isSuccess(response)) {
-            throw JerseyHelper.parseError(response);
-        }
-
-        // Consume and parse response
-        String json = response.readEntity(String.class);
-        JsonObject currentResponse = new JsonParser().parse(json).getAsJsonObject();
-
-        int pageSizeParam = GsonUtil.parseIntMember(currentResponse, "metadata.returnert");
-        logger.debug("Page size returned was {}.", pageSizeParam);
-
-        if (logger.isTraceEnabled()){
-            logger.trace("Response: {}", currentResponse.toString());
-        }
-        List<JsonObject> l = StreamSupport.stream(currentResponse.getAsJsonArray("objekter").spliterator(), false)
-                                           .map(JsonElement::getAsJsonObject)
-                                           .collect(Collectors.toList());
-
-        // Prepare next request
-        String nextToken = GsonUtil.getNode(currentResponse, "metadata.neste.start")
-                                   .map(JsonElement::getAsString)
-                                   .orElse(null);
-        logger.debug("last token: {} next token: {}",token, nextToken);
-        // no next page if last token and next token are equal
-        hasNext = nextToken != null && (token == null || !nextToken.equals(token));
-        token = nextToken;
-        currentPage = Page.subPage(pageSizeParam, token);
-        logger.debug("Got {} features.", l.size());
-        if (!hasNext) {
-            logger.debug("Result set exhausted.");
+        try (Response response = JerseyHelper.execute(inv, Response.class)) {
+            if (!JerseyHelper.isSuccess(response)) {
+                throw JerseyHelper.parseError(response);
+            }
+            String requestId = response.getHeaderString("X-REQUEST-ID");
+
+            try {
+                JsonObject currentResponse =
+                        JsonParser.parseReader(new InputStreamReader((InputStream) response.getEntity(), StandardCharsets.UTF_8))
+                                .getAsJsonObject();
+
+                int numTotal = GsonUtil.parseIntMember(currentResponse, "metadata.antall");
+                int numReturned = GsonUtil.parseIntMember(currentResponse, "metadata.returnert");
+//              int numPerPage = GsonUtil.parseIntMember(currentResponse, "metadata.sidestørrelse");
+                logger.debug("Result size returned was {}.", numTotal);
+                logger.debug("Results in page returned was {}.", numReturned);
+//              logger.debug("Page size returned was {}.", numPerPage);
+
+                if (logger.isTraceEnabled()){
+                    logger.trace("Response: {}", currentResponse.toString());
+                }
+
+                // Prepare next request
+                String nextToken = GsonUtil.getNode(currentResponse, "metadata.neste.start")
+                        .map(JsonElement::getAsString)
+                        .orElse(null);
+                logger.debug("last token: {} next token: {}", token, nextToken);
+                // no next page if last token and next token are equal
+                hasNext = nextToken != null && (!nextToken.equals(token));
+                token = nextToken;
+                currentPage = currentPage.withStart(token);
+
+                if (!hasNext) {
+                    logger.debug("Result set exhausted.");
+                }
+                return StreamSupport
+                        .stream(currentResponse.getAsJsonArray(objekterField).spliterator(), false)
+                        .map(JsonElement::getAsJsonObject)
+                        .map(parser)
+                        .collect(Collectors.toList());
+            } catch (Exception e) {
+                throw new ClientException(response.getStatus(), requestId, Collections.emptyList(), e);
+            }
         }
-        return l.stream()
-                .map(parser)
-                .collect(Collectors.toList());
     }
 
     public String nextToken() {
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/util/JerseyHelper.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/JerseyHelper.java
similarity index 55%
rename from src/main/java/no/vegvesen/nvdbapi/client/clients/util/JerseyHelper.java
rename to src/main/java/no/vegvesen/nvdbapi/client/clients/JerseyHelper.java
index a7ac407..64b2b5f 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/util/JerseyHelper.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/JerseyHelper.java
@@ -23,7 +23,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.vegvesen.nvdbapi.client.clients.util;
+package no.vegvesen.nvdbapi.client.clients;
 
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
@@ -34,31 +34,40 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.client.Entity;
 import javax.ws.rs.client.Invocation;
 import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.GenericType;
+import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.Response;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 
-public class JerseyHelper {
+import static javax.ws.rs.core.HttpHeaders.IF_NONE_MATCH;
+import static no.vegvesen.nvdbapi.client.clients.ClientFactory.*;
+
+class JerseyHelper {
     private static final Logger logger = LoggerFactory.getLogger(JerseyHelper.class);
-    public static final String MEDIA_TYPE = "application/vnd.vegvesen.nvdb-v2+json";
+    static final String MEDIA_TYPE = apiRevision;
 
     private JerseyHelper() {}
 
-    public static boolean isSuccess(Response response) {
+    static boolean isSuccess(Response response) {
         return 200 <= response.getStatus() && response.getStatus() < 300;
     }
 
-    public static ClientException parseError(Response response) {
+    static ClientException parseError(Response response) {
         List<ApiError> errors = JsonExceptionParser.parse(response.readEntity(String.class));
-        return new ClientException(response.getStatus(), errors);
+        String requestId = response.getHeaderString("X-REQUEST-ID");
+        return new ClientException(response.getStatus(), requestId, errors);
     }
 
-    public static <T> T execute(Invocation inv, Class<T> responseClass) {
+    static <T> T execute(Invocation inv, Class<T> responseClass) {
         try {
             return inv.invoke(responseClass);
         } catch (WebApplicationException ex) {
@@ -67,24 +76,40 @@ public class JerseyHelper {
         }
     }
 
-    public static JsonElement execute(WebTarget target) {
-        return execute(target, MEDIA_TYPE);
+    static JsonElement execute(WebTarget target) {
+        return execute(target, null, MEDIA_TYPE);
+    }
+
+    static JsonElement execute(WebTarget target, Entity<?> entity) {
+        return execute(target, entity, MEDIA_TYPE);
     }
 
-    public static JsonElement execute(WebTarget target, String mediaType) {
-        Invocation invocation = target.request().accept(mediaType).buildGet();
+    static JsonElement execute(WebTarget target, Entity<?> entity, String mediaType) {
+
+        Invocation invocation;
+
+        if (entity != null) {
+            invocation = target.request().accept(mediaType).buildPost(entity);
+        } else {
+            invocation = target.request().accept(mediaType).buildGet();
+        }
+
         try(Response response = execute(invocation, Response.class)) {
 
             if (!isSuccess(response)) {
                 throw parseError(response);
             }
-
-            return new JsonParser().parse(
-                    new InputStreamReader((InputStream) response.getEntity()));
+            String requestId = response.getHeaderString("X-REQUEST-ID");
+            try {
+                return JsonParser.parseReader(
+                        new InputStreamReader((InputStream) response.getEntity(), StandardCharsets.UTF_8));
+            } catch (Exception e) {
+                throw new ClientException(response.getStatus(), requestId, Collections.emptyList(), e);
+            }
         }
     }
 
-    public static <T> T execute(Invocation inv, GenericType<T> responseType) {
+    static <T> T execute(Invocation inv, GenericType<T> responseType) {
         try {
             return inv.invoke(responseType);
         } catch (WebApplicationException ex) {
@@ -93,9 +118,17 @@ public class JerseyHelper {
         }
     }
 
-    public static Optional<JsonElement> executeOptional(WebTarget target) {
-        Invocation inv = target.request().buildGet();
+    static Optional<JsonElement> executeOptional(WebTarget target) {
+        Invocation.Builder request = target.request();
+        URI uri = target.getUri();
+        String path = uri.getPath() + uri.getQuery();
+        getEtag(path)
+            .ifPresent(etag -> request.header(IF_NONE_MATCH, etag));
+        Invocation inv = request.buildGet();
         try(Response response = execute(inv, Response.class)) {
+            if(response.getStatus() == Response.Status.NOT_MODIFIED.getStatusCode()) {
+                return getResponse(path);
+            }
 
             if (!isSuccess(response)) {
                 if (response.getStatus() == 404) {
@@ -107,10 +140,20 @@ public class JerseyHelper {
             if (response.getStatus() == 204) {
                 return Optional.empty();
             }
+            String requestId = response.getHeaderString("X-REQUEST-ID");
+            String etag = response.getHeaderString(HttpHeaders.ETAG);
+            if(etag != null) {
+                String body = response.readEntity(String.class);
+                setEtag(path, etag, body);
+                return Optional.of(
+                    JsonParser.parseString(body)
+                );
+            }
+
             try (InputStream is = response.readEntity(InputStream.class)) {
-                return Optional.of(new JsonParser().parse(new InputStreamReader(is)));
+                return Optional.of(JsonParser.parseReader(new InputStreamReader(is, StandardCharsets.UTF_8)));
             } catch (Exception e) {
-                throw new RuntimeException("Error parsing response", e);
+                throw new ClientException(response.getStatus(), requestId, Collections.emptyList(), e);
             }
         }
     }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/Login.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/Login.java
new file mode 100644
index 0000000..9219190
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/Login.java
@@ -0,0 +1,43 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import static java.util.Objects.nonNull;
+
+public class Login {
+    public final AuthTokens authTokens;
+    public final Failure failure;
+
+    private Login(AuthTokens authTokens, Failure failure) {
+        this.authTokens = authTokens;
+        this.failure = failure;
+    }
+
+    static Login failed(String message) {
+        return new Login(null, new Failure(message));
+    }
+
+    static Login success(AuthTokens authTokens) {
+        return new Login(authTokens, null);
+    }
+
+    public boolean isSuccessful() {
+        return nonNull(authTokens);
+    }
+
+    public static class AuthTokens {
+        public final String idToken;
+        public final String refreshToken;
+
+        AuthTokens(String idToken, String refreshToken) {
+            this.idToken = idToken;
+            this.refreshToken = refreshToken;
+        }
+    }
+
+    public static class Failure {
+        public final String message;
+
+        Failure(String message) {
+            this.message = message;
+        }
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/PositionClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/PositionClient.java
index bbc45e8..e6f55bc 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/PositionClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/PositionClient.java
@@ -27,7 +27,6 @@ package no.vegvesen.nvdbapi.client.clients;
 
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
 import no.vegvesen.nvdbapi.client.gson.PlacementParser;
 import no.vegvesen.nvdbapi.client.model.Position;
 
@@ -36,13 +35,16 @@ import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.UriBuilder;
 
 import java.util.List;
+import java.util.function.Consumer;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
 
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
+
 public class PositionClient extends AbstractJerseyClient {
 
-    public PositionClient(String baseurl, Client client) {
-        super(baseurl, client);
+    PositionClient(String baseurl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseurl, client, onClose);
     }
 
     public Position getPlacement(PositionRequest req) {
@@ -57,7 +59,7 @@ public class PositionClient extends AbstractJerseyClient {
         req.getMaxDistance().ifPresent(v -> url.queryParam("maks_avstand", v));
         req.getConnectionLinks().ifPresent(v -> url.queryParam("konnekteringslenker", v));
         req.getDetailedLinks().ifPresent(v -> url.queryParam("detaljerte_lenker", v));
-        req.getRoadRefFilters().ifPresent(v -> url.queryParam("vegreferanse", v));
+        req.getRoadRefFilters().ifPresent(v -> url.queryParam("vegsystemreferanse", v));
 
         WebTarget target = getClient().target(url);
 
@@ -66,7 +68,7 @@ public class PositionClient extends AbstractJerseyClient {
         List<Position.Result> collect =
                 StreamSupport.stream(results.spliterator(), false)
                              .map(JsonElement::getAsJsonObject)
-                             .map(PlacementParser::parsePosition)
+                             .map(rt(PlacementParser::parsePosition))
                              .collect(Collectors.toList());
         return new Position(collect);
     }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RefLinkRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RefLinkRequest.java
index 179d934..fa7e939 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RefLinkRequest.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RefLinkRequest.java
@@ -31,22 +31,22 @@ import java.util.Optional;
 
 public class RefLinkRequest {
 
-    private final int id;
+    private final long linksequenceId;
     private final double position;
     private final Projection projection;
 
-    public RefLinkRequest(int id, double position) {
-        this(id, position, null);
+    public RefLinkRequest(long linksequenceId, double position) {
+        this(linksequenceId, position, null);
     }
 
-    public RefLinkRequest(int id, double position, Projection projection) {
-        this.id = id;
+    public RefLinkRequest(long linksequenceId, double position, Projection projection) {
+        this.linksequenceId = linksequenceId;
         this.position = position;
         this.projection = projection;
     }
 
-    public int getId() {
-        return id;
+    public long getLinksequenceId() {
+        return linksequenceId;
     }
 
     public double getPosition() {
@@ -58,7 +58,7 @@ public class RefLinkRequest {
     }
 
     public String getQueryParam() {
-        return position + "@" + id;
+        return position + "@" + linksequenceId;
     }
 
     @Override
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/filters/RequestHeaderFilter.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RequestHeaderFilter.java
similarity index 68%
rename from src/main/java/no/vegvesen/nvdbapi/client/clients/filters/RequestHeaderFilter.java
rename to src/main/java/no/vegvesen/nvdbapi/client/clients/RequestHeaderFilter.java
index 65301d2..2c76dd5 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/filters/RequestHeaderFilter.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RequestHeaderFilter.java
@@ -23,45 +23,50 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.vegvesen.nvdbapi.client.clients.filters;
+package no.vegvesen.nvdbapi.client.clients;
 
 import javax.ws.rs.client.ClientRequestContext;
 import javax.ws.rs.client.ClientRequestFilter;
 import javax.ws.rs.core.HttpHeaders;
 import javax.ws.rs.core.MultivaluedMap;
-import java.io.IOException;
 import java.util.Arrays;
+import java.util.function.Supplier;
 
-public class RequestHeaderFilter implements ClientRequestFilter {
+class RequestHeaderFilter implements ClientRequestFilter {
     private static final String X_CLIENT = "X-Client";
-    private static final String DAKAT_VERSION = "X-Datakatalog-Versjon";
+    private static final String X_SESSION = "X-Client-Session";
 
     private final String userAgent;
     private final String xClientName;
-    private final String dakatVersion;
-    private final boolean enableCompression;
+    private final String xsessionId;
     private final String apiRevision;
+    private final Supplier<Login.AuthTokens> authTokensProvider;
 
-    public RequestHeaderFilter(String userAgent,
+    RequestHeaderFilter(String userAgent,
                                String xClientName,
-                               String dakatVersion,
-                               boolean enableCompression,
-                               String apiRevision) {
+                               String xsessionId,
+                               String apiRevision,
+                               Supplier<Login.AuthTokens> authTokensProvider) {
         this.userAgent = userAgent;
         this.xClientName = xClientName;
-        this.dakatVersion = dakatVersion;
-        this.enableCompression = enableCompression;
+        this.xsessionId = xsessionId;
         this.apiRevision = apiRevision;
+        this.authTokensProvider = authTokensProvider;
     }
 
     @Override
-    public void filter(ClientRequestContext requestContext) throws IOException {
+    public void filter(ClientRequestContext requestContext) {
         MultivaluedMap<String, Object> headers = requestContext.getHeaders();
         headers.putSingle(HttpHeaders.ACCEPT, apiRevision);
         headers.putSingle(HttpHeaders.USER_AGENT, userAgent);
-        if (enableCompression) headers.put(HttpHeaders.ACCEPT_ENCODING, Arrays.asList("gzip", "deflate"));
+        headers.put(HttpHeaders.ACCEPT_ENCODING, Arrays.asList("gzip", "deflate"));
 
         headers.putSingle(X_CLIENT, xClientName);
-        if (dakatVersion != null) headers.putSingle(DAKAT_VERSION, dakatVersion);
+        headers.putSingle(X_SESSION, xsessionId);
+
+        Login.AuthTokens authTokens = authTokensProvider.get();
+        if(authTokens != null) {
+            headers.putSingle(HttpHeaders.AUTHORIZATION, "Bearer " + authTokens.idToken);
+        }
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetClient.java
index efae272..c32e450 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetClient.java
@@ -25,77 +25,147 @@
 
 package no.vegvesen.nvdbapi.client.clients;
 
-import com.google.gson.JsonElement;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
-import no.vegvesen.nvdbapi.client.gson.LinkParser;
-import no.vegvesen.nvdbapi.client.model.Page;
-import no.vegvesen.nvdbapi.client.model.roadnet.Link;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import javax.ws.rs.client.Client;
-import javax.ws.rs.client.WebTarget;
-import javax.ws.rs.core.UriBuilder;
 import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
+import java.util.function.Consumer;
 import java.util.stream.Collectors;
-import java.util.stream.StreamSupport;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.UriBuilder;
 
-public class RoadNetClient extends AbstractJerseyClient {
-    private static final Logger LOG = LoggerFactory.getLogger(RoadNetClient.class);
+import com.google.gson.JsonElement;
 
-    public RoadNetClient(String baseUrl, Client client) {
-        super(baseUrl, client);
+import no.vegvesen.nvdbapi.client.gson.RoadNetParser;
+import no.vegvesen.nvdbapi.client.model.Page;
+import no.vegvesen.nvdbapi.client.model.roadnet.LinkSequence;
+import no.vegvesen.nvdbapi.client.model.roadnet.Node;
+import no.vegvesen.nvdbapi.client.model.roadnet.TopologyLevel;
+
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
+
+public class RoadNetClient extends AbstractJerseyClient {
+    RoadNetClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
     }
 
-    public List<Link> getLinks(int id) {
-        UriBuilder path = endpoint().path("/lenker").path(Integer.toString(id));
+    public LinkSequence getLinkSequence(long linksequenceId) {
+        UriBuilder path = endpoint().path("/veglenkesekvenser").path(Long.toString(linksequenceId));
+        WebTarget target = getClient().target(path);
+        JsonElement result = JerseyHelper.execute(target);
+
+        return rt(RoadNetParser::parseLinkSequence).apply(result.getAsJsonObject());
+    }
 
+    public Node getNode(long nodeId) {
+        UriBuilder path = endpoint().path("/noder").path(Long.toString(nodeId));
         WebTarget target = getClient().target(path);
         JsonElement result = JerseyHelper.execute(target);
-        return StreamSupport.stream(result.getAsJsonArray().spliterator(), false)
-                            .map(e -> LinkParser.parse(e.getAsJsonObject()))
-                            .collect(Collectors.toList());
+
+        return rt(RoadNetParser::parseNode).apply(result.getAsJsonObject());
     }
 
-    public LinkResult getLinks() {
-        return getLinks(RoadNetRequest.DEFAULT);
+    public LinkResult getLinkSequences() {
+        return getLinkSequences(RoadNetRequest.DEFAULT);
     }
 
-    public LinkResult getLinks(RoadNetRequest request) {
-        Objects.requireNonNull(request, "Missing page info argument.");
+    public NodeResult getNodes() {
+        return getNodes(RoadNetRequest.DEFAULT);
+    }
 
-        UriBuilder path = endpoint().path("/lenker");
-        if (!request.getRegions().isEmpty()) path.queryParam("region", join(request.getRegions()));
-        if (!request.getCounties().isEmpty()) path.queryParam("fylke", join(request.getCounties()));
-        if (!request.getMunicipalities().isEmpty()) path.queryParam("kommune", join(request.getMunicipalities()));
-        if (!request.getRoadDepartments().isEmpty()) path.queryParam("vegavdeling", join(request.getRoadDepartments()));
-        request.getBbox().ifPresent(v -> path.queryParam("kartutsnitt", v));
-        request.getProjection().ifPresent(v -> path.queryParam("srid", v.getSrid()));
-        request.getRoadRefFilter().ifPresent(v -> path.queryParam("vegreferanse", v));
+    public AsyncLinkResult getLinkSequencesAsync() {
+        return getLinkSequencesAsync(RoadNetRequest.DEFAULT);
+    }
 
-        WebTarget target = getClient().target(path);
+    public AsyncNodeResult getNodesAsync() {
+        return getNodesAsync(RoadNetRequest.DEFAULT);
+    }
+
+    public LinkResult getLinkSequences(RoadNetRequest request) {
+        WebTarget target = getWebTarget(request, "/veglenkesekvenser");
         return new LinkResult(target, request.getPage());
     }
 
-    private static String join(List<Integer> list) {
+    public AsyncLinkResult getLinkSequencesAsync(RoadNetRequest request) {
+        WebTarget target = getWebTarget(request, "/veglenkesekvenser");
+        return new AsyncLinkResult(target, request.getPage());
+    }
+
+    public NodeResult getNodes(RoadNetRequest request) {
+        WebTarget target = getWebTarget(request, "/noder");
+        return new NodeResult(target, request.getPage());
+    }
+
+    public AsyncNodeResult getNodesAsync(RoadNetRequest request) {
+        WebTarget target = getWebTarget(request, "/noder");
+        return new AsyncNodeResult(target, request.getPage());
+    }
+
+    private WebTarget getWebTarget(RoadNetRequest request, String p) {
+        Objects.requireNonNull(request, "Missing page info argument.");
+
+        UriBuilder path = endpoint().path(p);
+        addParameters(request, path);
+
+        return getClient().target(path);
+    }
+
+    protected static String join(List<?> list) {
         if (list == null) {
             return null;
         }
         return list.stream()
-                   .map(Objects::toString)
-                   .collect(Collectors.joining(","));
+                .map(Objects::toString)
+                .collect(Collectors.joining(","));
+    }
+
+
+    private void addParameters(RoadNetRequest request, UriBuilder path) {
+        if (!request.getCounties().isEmpty()) path.queryParam("fylke", join(request.getCounties()));
+        if (!request.getTopologyLevel().isEmpty()) {
+            path.queryParam("topologiniva",
+                    join(request.getTopologyLevel()
+                            .stream()
+                            .map(TopologyLevel::getApiValue)
+                            .collect(Collectors.toList())));
+        }
+        if (!request.getSuperId().isEmpty()) path.queryParam("superid", join(request.getSuperId()));
+        if (!request.getMunicipalities().isEmpty()) path.queryParam("kommune", join(request.getMunicipalities()));
+        if (!request.getId().isEmpty()) path.queryParam("ider", join(request.getId()));
+        request.getBbox().ifPresent(v -> path.queryParam("kartutsnitt", v));
+        request.getBpolygon().ifPresent(v -> path.queryParam("polygon", v));
+        request.getProjection().ifPresent(v -> path.queryParam("srid", v.getSrid()));
+        request.getRoadRefFilter().ifPresent(v -> path.queryParam("vegsystemreferanse", v));
+        request.getContractArea().ifPresent(v -> path.queryParam("kontraktsomrade", v));
+        request.getNationalRoute().ifPresent(v -> path.queryParam("riksvegrute", v));
+        request.getStreet().ifPresent(v -> path.queryParam("gate", v));
     }
 
     private UriBuilder endpoint() {
         return start().path("vegnett");
     }
 
-    public final class LinkResult extends GenericResultSet<Link> {
+    public static final class AsyncLinkResult extends AsyncResult<LinkSequence> {
+        AsyncLinkResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(RoadNetParser::parseLinkSequence));
+        }
+    }
+
+    public static final class LinkResult extends GenericResultSet<LinkSequence> {
+        LinkResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(RoadNetParser::parseLinkSequence));
+        }
+    }
 
-        protected LinkResult(WebTarget baseTarget, Optional<Page> currentPage) {
-            super(baseTarget, currentPage, LinkParser::parse);
+    public static final class NodeResult extends GenericResultSet<Node> {
+        NodeResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(RoadNetParser::parseNode));
         }
     }
+
+    public static final class AsyncNodeResult extends AsyncResult<Node> {
+        AsyncNodeResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(RoadNetParser::parseNode));
+        }
+    }
+
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRequest.java
index dbde0c5..c12c976 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRequest.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRequest.java
@@ -27,7 +27,9 @@ package no.vegvesen.nvdbapi.client.clients;
 
 import no.vegvesen.nvdbapi.client.model.Page;
 import no.vegvesen.nvdbapi.client.model.Projection;
+import no.vegvesen.nvdbapi.client.model.roadnet.*;
 
+import java.time.LocalDate;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
@@ -37,38 +39,97 @@ public class RoadNetRequest {
 
     private final Optional<Page> page;
     private final Optional<String> roadRefFilter;
-    private final List<Integer> regions;
     private final List<Integer> counties;
     private final List<Integer> municipalities;
-    private final List<Integer> roadDepartments;
+    private final List<TopologyLevel> topologyLevel;
+    private final List<Long> superId;
+    private final List<Long> id;
     private final Optional<Projection> projection;
     private final Optional<String> bbox;
+    private final Optional<String> contractArea;
+    private final Optional<String> nationalRoute;
+    private final Optional<String> street;
+    private final Optional<String> bpolygon;
+    private final boolean history;
+    private final Optional<LocalDate> dateFilter;
+    private final Optional<Boolean> armFilter;
+    private final Optional<Boolean> sideAreaFilter;
+    private final Optional<Boolean> intersectionFilter;
+    private final Optional<RoadUserGroup> roadUserGroupFilter;
+    private final Optional<SeparatePassages> separatePassagesFilter;
+    private final Optional<TypeOfRoad> typeOfRoadFilter;
+    private final Optional<RefLinkPartType> refLinkPartTypeFilter;
+    private final Optional<DetailLevel> detailLevelFilter;
 
     private RoadNetRequest(Builder b) {
         page = b.page;
         roadRefFilter = b.roadRefFilter;
-        regions = b.regions;
         counties = b.counties;
         municipalities = b.municipalities;
-        roadDepartments = b.roadDepartments;
+        topologyLevel = b.topologyLevel;
+        this.superId = b.superId;
         projection = b.projection;
         bbox = b.bbox;
+        bpolygon = b.bpolygon;
+        contractArea = b.contractArea;
+        nationalRoute = b.nationalRoute;
+        street = b.street;
+        id = b.id;
+        history = b.history;
+        dateFilter = b.dateFilter;
+        armFilter = b.armFilter;
+        sideAreaFilter = b.sideAreaFilter;
+        intersectionFilter = b.intersectionFilter;
+        roadUserGroupFilter = b.roadUserGroupFilter;
+        separatePassagesFilter = b.separatePassagesFilter;
+        refLinkPartTypeFilter = b.refLinkPartTypeFilter;
+        detailLevelFilter = b.detailLevelFilter;
+        typeOfRoadFilter = b.typeOfRoadFilter;
+
     }
 
     public static Builder newBuilder() {
         return new Builder();
     }
 
-    public Optional<Page> getPage() {
-        return page;
+    public Page getPage() {
+        return page.orElse(Page.defaults());
     }
 
-    public Optional<String> getRoadRefFilter() {
-        return roadRefFilter;
+    public Optional<Boolean> getArmFilter() {
+        return armFilter;
+    }
+
+    public Optional<Boolean> getSideAreaFilter() {
+        return sideAreaFilter;
+    }
+
+    public Optional<Boolean> getIntersectionFilter() {
+        return intersectionFilter;
+    }
+
+    public Optional<RoadUserGroup> getRoadUserGroupFilter() {
+        return roadUserGroupFilter;
+    }
+
+    public Optional<SeparatePassages> getSeparatePassagesFilter() {
+        return separatePassagesFilter;
     }
 
-    public List<Integer> getRegions() {
-        return regions;
+    public Optional<TypeOfRoad> getTypeOfRoadFilter() {
+        return typeOfRoadFilter;
+    }
+
+    public Optional<RefLinkPartType> getRefLinkPartTypeFilter() {
+        return refLinkPartTypeFilter;
+    }
+
+    public Optional<DetailLevel> getDetailLevelFilter() {
+        return detailLevelFilter;
+    }
+
+    public Optional<String> getRoadRefFilter() {
+        return roadRefFilter;
     }
 
     public List<Integer> getCounties() {
@@ -79,8 +140,12 @@ public class RoadNetRequest {
         return municipalities;
     }
 
-    public List<Integer> getRoadDepartments() {
-        return roadDepartments;
+    public List<TopologyLevel> getTopologyLevel() {
+        return topologyLevel;
+    }
+
+    public List<Long> getSuperId() {
+        return superId;
     }
 
     public Optional<String> getBbox() {
@@ -91,15 +156,58 @@ public class RoadNetRequest {
         return projection;
     }
 
+    public Optional<String> getContractArea() {
+        return contractArea;
+    }
+
+    public Optional<String> getNationalRoute() {
+        return nationalRoute;
+    }
+
+    public Optional<String> getStreet() {
+        return street;
+    }
+
+    public List<Long> getId() {
+        return id;
+    }
+
+    public Optional<String> getBpolygon() {
+        return bpolygon;
+    }
+
+    public boolean isHistory() {
+        return history;
+    }
+
+    public Optional<LocalDate> getDateFilter() {
+        return dateFilter;
+    }
+
     public static class Builder {
+        private Optional<String> bpolygon = Optional.empty();
         private Optional<Page> page = Optional.empty();
         private Optional<String> roadRefFilter = Optional.empty();
-        private List<Integer> regions = Collections.emptyList();
         private List<Integer> counties = Collections.emptyList();
         private List<Integer> municipalities = Collections.emptyList();
-        private List<Integer> roadDepartments = Collections.emptyList();
+        private List<TopologyLevel> topologyLevel = Collections.emptyList();
+        private List<Long> superId = Collections.emptyList();
+        private List<Long> id = Collections.emptyList();
         private Optional<String> bbox = Optional.empty();
         private Optional<Projection> projection = Optional.empty();
+        private Optional<String> contractArea = Optional.empty();
+        private Optional<String> nationalRoute = Optional.empty();
+        private Optional<String> street = Optional.empty();
+        private boolean history = false;
+        private Optional<LocalDate> dateFilter = Optional.empty();
+        private Optional<Boolean> armFilter = Optional.empty();
+        private Optional<Boolean> sideAreaFilter = Optional.empty();
+        private Optional<Boolean> intersectionFilter = Optional.empty();
+        private Optional<RoadUserGroup> roadUserGroupFilter = Optional.empty();
+        private Optional<SeparatePassages> separatePassagesFilter = Optional.empty();
+        private Optional<RefLinkPartType> refLinkPartTypeFilter = Optional.empty();
+        private Optional<DetailLevel> detailLevelFilter = Optional.empty();
+        private Optional<TypeOfRoad> typeOfRoadFilter = Optional.empty();
 
         private Builder() {
         }
@@ -108,23 +216,57 @@ public class RoadNetRequest {
             return new RoadNetRequest(this);
         }
 
-        public Builder withPage(Page page) {
-            this.page = Optional.ofNullable(page);
+        public Builder withArmFilter(Boolean armFilter) {
+            this.armFilter = Optional.ofNullable(armFilter);
             return this;
         }
 
-        public Builder withRoadRefFilter(String filter) {
-            this.roadRefFilter = Optional.ofNullable(filter);
+        public Builder withSideAreaFilter(Boolean sideAreaFilter) {
+            this.sideAreaFilter = Optional.ofNullable(sideAreaFilter);
+            return this;
+        }
+
+        public Builder withIntersectionFilter(Boolean intersectionFilter) {
+            this.intersectionFilter = Optional.ofNullable(intersectionFilter);
             return this;
         }
 
-        public Builder withRegions(List<Integer> regions) {
-            this.regions = Optional.ofNullable(regions).orElse(Collections.emptyList());
+        public Builder withRoadUserGroupFilter(RoadUserGroup roadUserGroupFilter) {
+            this.roadUserGroupFilter = Optional.ofNullable(roadUserGroupFilter);
             return this;
         }
 
-        public Builder withRegion(Integer region) {
-            this.regions = Optional.ofNullable(region).map(Collections::singletonList).orElse(Collections.emptyList());
+        public Builder withSeparatePassagesFilter(SeparatePassages separatePassagesFilter) {
+            this.separatePassagesFilter = Optional.ofNullable(separatePassagesFilter);
+            return this;
+        }
+
+        public Builder withRefLinkPartTypeFilter(RefLinkPartType refLinkPartTypeFilter) {
+            this.refLinkPartTypeFilter = Optional.ofNullable(refLinkPartTypeFilter);
+            return this;
+        }
+
+        public Builder withDetailLevelFilter(DetailLevel detailLevelFilter) {
+            this.detailLevelFilter = Optional.ofNullable(detailLevelFilter);
+            return this;
+        }
+
+        public Builder withTypeOfRoadFilter(TypeOfRoad typeOfRoadFilter) {
+            this.typeOfRoadFilter = Optional.ofNullable(typeOfRoadFilter);
+            return this;
+        }
+
+        public Builder withBoundingPolygon(String boundingPolygon) {
+            this.bpolygon = Optional.ofNullable(boundingPolygon);
+            return this;
+        }
+        public Builder withPage(Page page) {
+            this.page = Optional.ofNullable(page);
+            return this;
+        }
+
+        public Builder withRoadRefFilter(String filter) {
+            this.roadRefFilter = Optional.ofNullable(filter);
             return this;
         }
 
@@ -148,13 +290,18 @@ public class RoadNetRequest {
             return this;
         }
 
-        public Builder withRoadDepartments(List<Integer> roadDepartments) {
-            this.roadDepartments = Optional.ofNullable(roadDepartments).orElse(Collections.emptyList());
+        public Builder withTopologyLevel(List<TopologyLevel> topologyLevel) {
+            this.topologyLevel = Optional.ofNullable(topologyLevel).orElse(Collections.emptyList());
             return this;
         }
 
-        public Builder withRoadDepartment(Integer roadDepartment) {
-            this.roadDepartments = Optional.ofNullable(roadDepartment).map(Collections::singletonList).orElse(Collections.emptyList());
+        public Builder withSuperId(List<Long> superId) {
+            this.superId = Optional.ofNullable(superId).orElse(Collections.emptyList());
+            return this;
+        }
+
+        public Builder withId(List<Long> id) {
+            this.id = Optional.ofNullable(id).orElse(Collections.emptyList());
             return this;
         }
 
@@ -163,9 +310,39 @@ public class RoadNetRequest {
             return this;
         }
 
+        public Builder withBpolygon(String bpolygon) {
+            this.bpolygon = Optional.ofNullable(bpolygon);
+            return this;
+        }
+
         public Builder withProjection(Projection projection) {
             this.projection = Optional.ofNullable(projection);
             return this;
         }
+
+        public Builder withContractArea(String contractArea) {
+            this.contractArea = Optional.ofNullable(contractArea);
+            return this;
+        }
+
+        public Builder withNationalRoute(String nationalRoute) {
+            this.nationalRoute = Optional.ofNullable(nationalRoute);
+            return this;
+        }
+
+        public Builder withStreet(String street) {
+            this.street = Optional.ofNullable(street);
+            return this;
+        }
+
+        public Builder withDateFilter(LocalDate localDate){
+            this.dateFilter = Optional.ofNullable(localDate);
+            return this;
+        }
+
+        public Builder withHistory(boolean history){
+            this.history = history;
+            return this;
+        }
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRouteClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRouteClient.java
new file mode 100644
index 0000000..0023af0
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRouteClient.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2015-2019, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.clients;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.Entity;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.UriBuilder;
+
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.gson.RouteParser;
+import no.vegvesen.nvdbapi.client.model.Coordinates;
+import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.Projection;
+import no.vegvesen.nvdbapi.client.model.roadnet.TypeOfRoad;
+import no.vegvesen.nvdbapi.client.model.roadnet.route.RouteOnRoadNet;
+
+public class RoadNetRouteClient extends AbstractJerseyClient {
+    static class RouteRequestField {
+        static final String START = "start";
+        static final String END = "slutt";
+        static final String GEOMETRY = "geometri";
+        static final String SRID = "srid";
+        static final String BRIEF_RESPONSE = "kortform";
+        static final String CONNECTION_LINKS = "konnekteringslenker";
+        static final String DETAILED_LINKS = "detaljerte_lenker";
+        static final String DISTANCE = "maks_avstand";
+        static final String ENVELOPE = "omkrets";
+        static final String ROAD_SYS_REFS = "vegsystemreferanse";
+        static final String TYPE_OF_ROAD = "typeveg";
+        static final String ROAD_USER_GROUP = "trafikantgruppe";
+        static final String KEEP_ROAD_USER_GROUP = "behold_trafikantgruppe";
+        static final String POINT_IN_TIME = "tidspunkt";
+        static final String START_POINT_IN_TIME = "tidspunkt_start";
+        static final String END_POINT_IN_TIME = "tidspunkt_slutt";
+    }
+
+    RoadNetRouteClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
+    }
+
+    public RouteOnRoadNet getRouteOnRoadnet(RoadNetRouteRequest request) {
+        WebTarget target = getWebTarget(request);
+        JsonObject result = JerseyHelper.execute(target).getAsJsonObject();
+        if (request.isBriefResponse()) {
+            return RouteParser.parseBrief(result);
+        } else {
+            return RouteParser.parseDetailed(result);
+        }
+    }
+
+    public RouteOnRoadNet postRouteOnRoadnet(RoadNetRouteRequest request) {
+        WebTarget target = getWebTarget();
+        Entity<Map<String, String>> entity = Entity.entity(getJsonObject(request), MediaType.APPLICATION_JSON);
+        JsonObject result = JerseyHelper.execute(target, entity).getAsJsonObject();
+        if (request.isBriefResponse()) {
+            return RouteParser.parseBrief(result);
+        } else {
+            return RouteParser.parseDetailed(result);
+        }
+    }
+
+    private Map<String, String> getJsonObject(RoadNetRouteRequest request) {
+        Map<String, String> jsonMap = new HashMap<>();
+
+        if (request.getStartReflinkPosition() != null) jsonMap.put(RouteRequestField.START, String.valueOf(request.getStartReflinkPosition()));
+        if (request.getEndReflinkPosition() != null) jsonMap.put(RouteRequestField.END, String.valueOf(request.getEndReflinkPosition()));
+        if (request.getGeometry() != null) jsonMap.put(RouteRequestField.GEOMETRY, request.getGeometry());
+        jsonMap.put(RouteRequestField.DISTANCE, String.valueOf(request.getDistance()));
+        jsonMap.put(RouteRequestField.ENVELOPE, String.valueOf(request.getEnvelope()));
+        jsonMap.put(RouteRequestField.BRIEF_RESPONSE, String.valueOf(request.isBriefResponse()));
+        jsonMap.put(RouteRequestField.CONNECTION_LINKS, String.valueOf(request.isConnectionLinks()));
+        jsonMap.put(RouteRequestField.DETAILED_LINKS, String.valueOf(request.isDetailedLinks()));
+        jsonMap.put(RouteRequestField.KEEP_ROAD_USER_GROUP, String.valueOf(request.isKeepRoadUserGroup()));
+        request.getRoadRefFilter().ifPresent(s -> jsonMap.put(RouteRequestField.ROAD_SYS_REFS, s));
+        request.getRoadUserGroup().ifPresent(userGroup -> jsonMap.put(RouteRequestField.ROAD_USER_GROUP, userGroup.getTextValue()));
+        if (!request.getTypeOfRoad().isEmpty()) jsonMap.put(RouteRequestField.TYPE_OF_ROAD, request.getTypeOfRoad().stream().map(TypeOfRoad::getTypeOfRoadSosi).collect(Collectors.joining(",")));
+
+        request.getPointInTime().ifPresent(pit -> jsonMap.put(RouteRequestField.POINT_IN_TIME, pit.toString()));
+        request.getStartPointInTime().ifPresent(pit -> jsonMap.put(RouteRequestField.START_POINT_IN_TIME, pit.toString()));
+        request.getEndPointInTime().ifPresent(pit -> jsonMap.put(RouteRequestField.END_POINT_IN_TIME, pit.toString()));
+
+        return jsonMap;
+    }
+
+    private WebTarget getWebTarget() {
+        return getClient().target(endpoint());
+    }
+
+    private WebTarget getWebTarget(RoadNetRouteRequest request) {
+        Objects.requireNonNull(request, "Missing page info argument.");
+
+        UriBuilder path = endpoint();
+
+        request.getPointInTime().ifPresent(v -> path.queryParam(RouteRequestField.POINT_IN_TIME, v.toString()));
+        request.getStartPointInTime().ifPresent(v -> path.queryParam(RouteRequestField.START_POINT_IN_TIME, v.toString()));
+        request.getEndPointInTime().ifPresent(v -> path.queryParam(RouteRequestField.END_POINT_IN_TIME, v.toString()));
+        path.queryParam(RouteRequestField.BRIEF_RESPONSE, request.isBriefResponse());
+        path.queryParam(RouteRequestField.CONNECTION_LINKS, request.isConnectionLinks());
+        path.queryParam(RouteRequestField.DETAILED_LINKS, request.isDetailedLinks());
+        request.getRoadRefFilter().ifPresent(v -> path.queryParam(RouteRequestField.ROAD_SYS_REFS, v));
+        request.getRoadUserGroup().ifPresent(v -> path.queryParam(RouteRequestField.ROAD_USER_GROUP, v.getTextValue()));
+        path.queryParam(RouteRequestField.KEEP_ROAD_USER_GROUP, request.isKeepRoadUserGroup());
+        if (!request.getTypeOfRoad().isEmpty()) path.queryParam(RouteRequestField.TYPE_OF_ROAD, request.getTypeOfRoad()
+                .stream()
+                .map(TypeOfRoad::getTypeOfRoadSosi)
+                .collect(Collectors.joining(",")));
+
+        if (request.usesGeometry()) {
+            path.queryParam(RouteRequestField.GEOMETRY, request.getGeometry());
+            path.queryParam(RouteRequestField.DISTANCE, request.getDistance());
+            if (request.getProjection() != Projection.UTM33) {
+                path.queryParam(RouteRequestField.SRID, request.getProjection().getSrid());
+            }
+        } else if(request.usesReflinkPosition()) {
+            path.queryParam(RouteRequestField.START, request.getStartReflinkPosition());
+            path.queryParam(RouteRequestField.END, request.getEndReflinkPosition());
+        } else {
+            Coordinates startCoordinates = request.getStartCoordinates();
+            path.queryParam(RouteRequestField.START, startCoordinates);
+            path.queryParam(RouteRequestField.END, request.getEndCoordinates());
+            path.queryParam(RouteRequestField.DISTANCE, request.getDistance());
+            path.queryParam(RouteRequestField.ENVELOPE, request.getEnvelope());
+
+            if(startCoordinates.getProjection() != Projection.UTM33) {
+                path.queryParam(RouteRequestField.SRID, startCoordinates.getProjection().getSrid());
+            }
+        }
+
+        return getClient().target(path);
+    }
+
+    private UriBuilder endpoint() {
+        return start().path("beta/vegnett/rute");
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRouteRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRouteRequest.java
new file mode 100644
index 0000000..cc87165
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadNetRouteRequest.java
@@ -0,0 +1,248 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import no.vegvesen.nvdbapi.client.model.Coordinates;
+import no.vegvesen.nvdbapi.client.model.Projection;
+import no.vegvesen.nvdbapi.client.model.RefLinkPosition;
+import no.vegvesen.nvdbapi.client.model.roadnet.RoadUserGroup;
+import no.vegvesen.nvdbapi.client.model.roadnet.TypeOfRoad;
+
+import java.time.LocalDate;
+import java.util.List;
+import java.util.Optional;
+
+import static java.util.Collections.emptyList;
+import static java.util.Objects.nonNull;
+
+public class RoadNetRouteRequest {
+
+    private final RefLinkPosition startReflinkPosition;
+    private final RefLinkPosition endReflinkPosition;
+    private final Coordinates startCoordinates;
+    private final Coordinates endCoordinates;
+    private final String geometry;
+    private final int distance;
+    private final int envelope;
+    private final boolean briefResponse;
+    private final boolean connectionLinks;
+    private final boolean detailedLinks;
+    private final Optional<String> roadRefFilter;
+    private final Optional<RoadUserGroup> roadUserGroup;
+    private final List<TypeOfRoad> typeOfRoad;
+    private final Optional<LocalDate> pointInTime;
+    private final Optional<LocalDate> startPointInTime;
+    private final Optional<LocalDate> endPointInTime;
+    private final boolean keepRoadUserGroup;
+    private final Projection projection;
+
+    private RoadNetRouteRequest(Builder b) {
+        this.startReflinkPosition = b.startReflinkPosition;
+        this.endReflinkPosition = b.endReflinkPosition;
+        this.startCoordinates = b.startCoordinates;
+        this.endCoordinates = b.endCoordinates;
+        this.geometry = b.geometry;
+        this.projection = b.projection;
+        this.distance = b.distance;
+        this.envelope = b.envelope;
+        this.briefResponse = b.briefResponse;
+        this.connectionLinks = b.connectionLinks;
+        this.detailedLinks = b.detailedLinks;
+        this.roadRefFilter = b.roadRefFilter;
+        this.roadUserGroup = b.roadUserGroup;
+        this.typeOfRoad = b.typeOfRoad;
+        this.pointInTime = b.pointInTime;
+        this.startPointInTime = b.startPointInTime;
+        this.endPointInTime = b.endPointInTime;
+        this.keepRoadUserGroup = b.keepRoadUserGroup;
+    }
+
+    public RefLinkPosition getStartReflinkPosition() {
+        return startReflinkPosition;
+    }
+
+    public RefLinkPosition getEndReflinkPosition() {
+        return endReflinkPosition;
+    }
+
+    public Coordinates getStartCoordinates() {
+        return startCoordinates;
+    }
+
+    public Coordinates getEndCoordinates() {
+        return endCoordinates;
+    }
+
+    public String getGeometry() {
+        return geometry;
+    }
+
+    public int getDistance() {
+        return distance;
+    }
+
+    public int getEnvelope() {
+        return envelope;
+    }
+
+    public boolean isBriefResponse() {
+        return briefResponse;
+    }
+
+    public boolean isConnectionLinks() {
+        return connectionLinks;
+    }
+
+    public boolean isDetailedLinks() {
+        return detailedLinks;
+    }
+
+    public Optional<String> getRoadRefFilter() {
+        return roadRefFilter;
+    }
+
+    public Optional<RoadUserGroup> getRoadUserGroup() {
+        return roadUserGroup;
+    }
+
+    public List<TypeOfRoad> getTypeOfRoad() {
+        return typeOfRoad;
+    }
+
+    public Optional<LocalDate> getPointInTime() {
+        return pointInTime;
+    }
+
+    public Optional<LocalDate> getStartPointInTime() {
+        return startPointInTime;
+    }
+
+    public Optional<LocalDate> getEndPointInTime() {
+        return endPointInTime;
+    }
+
+    public boolean usesReflinkPosition() {
+        return startReflinkPosition != null;
+    }
+
+    public boolean usesGeometry() {
+        return nonNull(geometry);
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public boolean isKeepRoadUserGroup() {
+        return keepRoadUserGroup;
+    }
+
+    public Projection getProjection() {
+        return projection;
+    }
+
+    public static class Builder {
+        private RefLinkPosition startReflinkPosition;
+        private RefLinkPosition endReflinkPosition;
+        private Coordinates startCoordinates;
+        private Coordinates endCoordinates;
+        private String geometry;
+        private Projection projection = Projection.UTM33;
+        private int distance = 10;
+        private int envelope = 100;
+        private boolean briefResponse = false;
+        private boolean connectionLinks = true;
+        private boolean detailedLinks = false;
+        private Optional<String> roadRefFilter = Optional.empty();
+        private Optional<RoadUserGroup> roadUserGroup = Optional.empty();
+        private List<TypeOfRoad> typeOfRoad = emptyList();
+        private Optional<LocalDate> pointInTime = Optional.empty();
+        private Optional<LocalDate> startPointInTime = Optional.empty();
+        private Optional<LocalDate> endPointInTime = Optional.empty();
+        public boolean keepRoadUserGroup = false;
+
+        public Builder between(RefLinkPosition startReflinkPosition, RefLinkPosition endReflinkPosition) {
+            this.startReflinkPosition = startReflinkPosition;
+            this.endReflinkPosition = endReflinkPosition;
+            return this;
+        }
+
+        public Builder between(Coordinates startCoordinates, Coordinates endCoordinates) {
+            this.startCoordinates = startCoordinates;
+            this.endCoordinates = endCoordinates;
+            return this;
+        }
+
+        public Builder fromGeometry(String geometry) {
+            this.geometry = geometry;
+            return this;
+        }
+
+        public Builder withProjection(Projection projection) {
+            this.projection = projection;
+            return this;
+        }
+
+        public Builder withDistance(int distance) {
+            this.distance = distance;
+            return this;
+        }
+
+        public Builder withEnvelope(int envelope) {
+            this.envelope = envelope;
+            return this;
+        }
+
+        public Builder withBriefResponse(boolean briefResponse) {
+            this.briefResponse = briefResponse;
+            return this;
+        }
+
+        public Builder withConnectionLinks(boolean connectionLinks) {
+            this.connectionLinks = connectionLinks;
+            return this;
+        }
+
+        public Builder withDetailedLinks(boolean detailedLinks) {
+            this.detailedLinks = detailedLinks;
+            return this;
+        }
+
+        public Builder withRoadRefFilter(String filter) {
+            this.roadRefFilter = Optional.ofNullable(filter);
+            return this;
+        }
+
+        public Builder withRoadUserGroup(RoadUserGroup roadUserGroup) {
+            this.roadUserGroup = Optional.ofNullable(roadUserGroup);
+            return this;
+        }
+
+        public Builder withTypeOfRoad(List<TypeOfRoad> typeOfRoad) {
+            this.typeOfRoad = typeOfRoad;
+            return this;
+        }
+
+        public Builder withPointInTime(LocalDate pointInTime) {
+            this.pointInTime = Optional.ofNullable(pointInTime);
+            return this;
+        }
+
+        public Builder withStartPointInTime(LocalDate startPointInTime) {
+            this.startPointInTime = Optional.ofNullable(startPointInTime);
+            return this;
+        }
+
+        public Builder withEndPointInTime(LocalDate endPointInTime) {
+            this.endPointInTime = Optional.ofNullable(endPointInTime);
+            return this;
+        }
+
+        public Builder withKeepRoadUserGroup(boolean keepRoadUserGroup){
+            this.keepRoadUserGroup = keepRoadUserGroup;
+            return this;
+        }
+
+        public RoadNetRouteRequest build() {
+            return new RoadNetRouteRequest(this);
+        }
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectClient.java
index b6a9169..2f85099 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectClient.java
@@ -25,76 +25,82 @@
 
 package no.vegvesen.nvdbapi.client.clients;
 
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Consumer;
+import java.util.stream.StreamSupport;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.UriBuilder;
+
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
-import no.vegvesen.nvdbapi.client.gson.ChangesParser;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import no.vegvesen.nvdbapi.client.gson.RoadObjectParser;
-import no.vegvesen.nvdbapi.client.model.Change;
 import no.vegvesen.nvdbapi.client.model.Page;
-import no.vegvesen.nvdbapi.client.model.datakatalog.DataType;
-import no.vegvesen.nvdbapi.client.model.datakatalog.Datakatalog;
-import no.vegvesen.nvdbapi.client.model.roadobjects.Attribute;
 import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObject;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObjectAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObjectType;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObjectTypeWithStats;
 import no.vegvesen.nvdbapi.client.model.roadobjects.Statistics;
-import no.vegvesen.nvdbapi.client.util.ArgUtil;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
-import javax.ws.rs.client.Client;
-import javax.ws.rs.client.WebTarget;
-import javax.ws.rs.core.MultivaluedMap;
-import javax.ws.rs.core.UriBuilder;
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.util.*;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
+import static java.lang.String.valueOf;
+import static java.util.Arrays.asList;
+import static java.util.stream.Collectors.toList;
 
+import static no.vegvesen.nvdbapi.client.clients.RoadObjectRequest.DEFAULT;
 import static no.vegvesen.nvdbapi.client.clients.RoadObjectRequestBuilder.convert;
+import static no.vegvesen.nvdbapi.client.clients.JerseyHelper.MEDIA_TYPE;
+import static no.vegvesen.nvdbapi.client.clients.JerseyHelper.execute;
+import static no.vegvesen.nvdbapi.client.clients.JerseyHelper.isSuccess;
+import static no.vegvesen.nvdbapi.client.clients.JerseyHelper.parseError;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
 
 public class RoadObjectClient extends AbstractJerseyClient {
     private static final Logger logger = LoggerFactory.getLogger(RoadObjectClient.class);
-    private final Datakatalog datakatalog;
 
-    protected RoadObjectClient(String baseUrl, Client client, Datakatalog datakatalog) {
-        super(baseUrl, client);
-        this.datakatalog = datakatalog;
+    RoadObjectClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
     }
 
-    public Datakatalog getDatakatalog() {
-        return datakatalog;
-    }
+    public Statistics getStats(int featureTypeId, RoadObjectRequest request) {
+        UriBuilder path = start(featureTypeId).path("statistikk");
 
-    public Attribute getAttribute(int featureTypeId, long featureId, int attributeTypeId) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d/%d/egenskaper/%d", featureTypeId, featureId, attributeTypeId));
+        applyRequestParameters(path, convert(request));
         logger.debug("Invoking {}", path);
         WebTarget target = getClient().target(path);
-        JsonElement e = JerseyHelper.execute(target);
-        return RoadObjectParser.parseAttribute(datakatalog.getDataTypeMap(), e.getAsJsonObject());
+
+        JsonElement e = execute(target);
+        return rt(RoadObjectParser::parseStatistics).apply(e.getAsJsonObject());
     }
 
-    public Stream<Attribute> getAttributes(int featureTypeId, Stream<Long> featureIds, int attributeTypeId) {
-        return featureIds.map(id -> getAttribute(featureTypeId, id, attributeTypeId));
+    public RoadObjectsResult getRoadObjects(int featureTypeId) {
+        return getRoadObjects(featureTypeId, DEFAULT);
     }
 
-    public Statistics getStats(int featureTypeId, RoadObjectRequest request) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d/statistikk", featureTypeId));
+    public AsyncRoadObjectsResult getRoadObjectsAsync(int featureTypeId) {
+        return getRoadObjectsAsync(featureTypeId, DEFAULT);
+    }
 
-        applyRequestParameters(path, convert(request));
-        logger.debug("Invoking {}", path);
+    public List<RoadObjectType> getRoadObjectTypes(){
+        UriBuilder path = start();
         WebTarget target = getClient().target(path);
 
-        JsonElement e = JerseyHelper.execute(target);
-        return RoadObjectParser.parseStatistics(e.getAsJsonObject());
-    }
+        JsonArray e = execute(target).getAsJsonArray();
 
-    public RoadObjectsResult getRoadObjects(int featureTypeId) {
-        return getRoadObjects(featureTypeId, RoadObjectRequest.DEFAULT);
+        return StreamSupport.stream(e.getAsJsonArray().spliterator(), false)
+            .map(JsonElement::getAsJsonObject)
+            .map(rt(RoadObjectParser::parseRoadObjectType))
+            .collect(toList());
     }
 
     /**
@@ -104,102 +110,147 @@ public class RoadObjectClient extends AbstractJerseyClient {
      * @return {@code RoadObjectsResult} for query
      */
     public RoadObjectsResult getRoadObjects(int featureTypeId, MultivaluedMap<String, String> queryParameters) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d", featureTypeId));
+        UriBuilder path = start(featureTypeId);
 
         applyRequestParameters(path, queryParameters);
         WebTarget target = getClient().target(path);
 
-        return new RoadObjectsResult(target, extractPage(queryParameters), datakatalog);
+        return new RoadObjectsResult(target, extractPage(queryParameters));
     }
 
     public RoadObjectsResult getRoadObjects(int featureTypeId, RoadObjectRequest request) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d", featureTypeId));
+        WebTarget target = getWebTarget(featureTypeId, request);
 
-        applyRequestParameters(path, convert(request));
-        WebTarget target = getClient().target(path);
-
-        return new RoadObjectsResult(target, Optional.ofNullable(request.getPage()), datakatalog);
+        return new RoadObjectsResult(target,
+            request.getPage()
+        );
     }
 
-    public AsyncRoadObjectsResult getRoadObjectsAsync(int featureTypeId, MultivaluedMap<String, String> queryParameters) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d", featureTypeId));
-
-        applyRequestParameters(path, queryParameters);
-        WebTarget target = getClient().target(path);
+    public AsyncRoadObjectsResult getRoadObjectsAsync(int featureTypeId, RoadObjectRequest request) {
+        WebTarget target = getWebTarget(featureTypeId, request);
 
-        return new AsyncRoadObjectsResult(target, extractPage(queryParameters).orElse(Page.defaults()), datakatalog);
+        return new AsyncRoadObjectsResult(target,
+            request.getPage()
+        );
     }
 
-    public AsyncRoadObjectsResult getRoadObjectsAsync(int featureTypeId, RoadObjectRequest request) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d", featureTypeId));
+    private WebTarget getWebTarget(int featureTypeId, RoadObjectRequest request) {
+        UriBuilder path = start(featureTypeId);
 
         applyRequestParameters(path, convert(request));
-        WebTarget target = getClient().target(path);
-
-        return new AsyncRoadObjectsResult(target, request.getPage(), datakatalog);
+        return getClient().target(path);
     }
 
-    private Optional<Page> extractPage(MultivaluedMap<String, String> params) {
+    private Page extractPage(MultivaluedMap<String, String> params) {
         if (params.containsKey("antall")) {
-            return Optional.of(Page.count(Integer.parseInt(params.getFirst("antall"))));
+            return Page.count(Integer.parseInt(params.getFirst("antall")));
         }
 
-        return Optional.empty();
+        return Page.defaults();
     }
 
     public RoadObject getRoadObject(int featureTypeId, long featureId) {
-        return getRoadObject(featureTypeId, featureId, RoadObjectRequest.DEFAULT);
+        return getRoadObject(featureTypeId, featureId, DEFAULT);
     }
 
     public RoadObject getRoadObject(int featureTypeId, long featureId, RoadObjectRequest request) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d/%d", featureTypeId, featureId));
+        UriBuilder path = start(featureTypeId).path(valueOf(featureId));
 
         logger.debug("Invoking {}", path);
         applyRequestParameters(path, convert(request));
 
         WebTarget target = getClient().target(path);
 
-        JsonObject obj = JerseyHelper.execute(target).getAsJsonObject();
-        return RoadObjectParser.parse(datakatalog.getDataTypeMap(), obj);
+        JsonObject obj = execute(target).getAsJsonObject();
+
+        return rt(RoadObjectParser::parse).apply(obj);
     }
 
-    public ChangesResult getChanges(int typeId, LocalDate from, Page page, Change.Type type) {
-        return getChanges(typeId, from.atStartOfDay(), page, type);
+    public List<RoadObject> getRoadObjectVersions(int featureTypeId, long featureId) {
+        return getRoadObjectVersions(featureTypeId, featureId, DEFAULT);
     }
 
-    public ChangesResult getChanges(int typeId, LocalDateTime from, Page page, Change.Type type) {
-        Objects.requireNonNull(from, "Missing from argument!");
+    public List<RoadObject> getRoadObjectVersions(int featureTypeId, long featureId, RoadObjectRequest roadObjectRequest) {
+        UriBuilder path = start(featureTypeId).path(valueOf(featureId)).path("versjoner");
 
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d/endringer", typeId))
-                .queryParam("etter", ArgUtil.date(from))
-                .queryParam("type", type.getArgValue());
+        logger.debug("Invoking {}", path);
+        applyRequestParameters(path, convert(roadObjectRequest));
 
         WebTarget target = getClient().target(path);
 
-        return new ChangesResult(datakatalog.getDataTypeMap(), typeId, target, Optional.ofNullable(page));
+        JsonArray e = execute(target).getAsJsonArray();
+        return StreamSupport.stream(e.spliterator(), false)
+            .map(JsonElement::getAsJsonObject)
+            .map(rt(RoadObjectParser::parse))
+            .collect(toList());
     }
 
-    private static void applyRequestParameters(UriBuilder path, MultivaluedMap<String, String> params) {
-        params.forEach((k, values) -> path.queryParam(k, (Object[]) values.toArray(new String[0])));
+    public RoadObject getRoadObjectVersion(int featureTypeId, long featureId, int version){
+        return getRoadObjectVersion(featureTypeId, featureId, version, DEFAULT);
     }
 
-    public List<Attribute> getAttributes(int featureTypeId, long featureId) {
-        UriBuilder path = start()
-                .path(String.format("/vegobjekter/%d/%d/egenskaper", featureTypeId, featureId));
+    public RoadObject getRoadObjectVersion(int featureTypeId, long featureId, int version, RoadObjectRequest roadObjectRequest){
+        UriBuilder path = start(featureTypeId).path(valueOf(featureId)).path(valueOf(version));
+
         logger.debug("Invoking {}", path);
+        applyRequestParameters(path, convert(roadObjectRequest));
+
         WebTarget target = getClient().target(path);
 
-        JsonArray array = JerseyHelper.execute(target).getAsJsonArray();
+        JsonObject obj = execute(target).getAsJsonObject();
+        return rt(RoadObjectParser::parse).apply(obj);
+    }
+
+    public RoadObjectAttribute getBinaryAttributeRoadObject(int featureTypeId, long featureId, int version, int attributeId, int blobId){
+        UriBuilder path = start(featureTypeId).path(valueOf(featureId)).path(valueOf(version))
+            .path("egenskaper").path(valueOf(attributeId)).path(valueOf(blobId)).path("binaer");
+
+        logger.debug("Invoking {}", path);
+        WebTarget target = getClient().target(path);
+
+        Invocation invocation = target.request().accept(MEDIA_TYPE).buildGet();
+        Response response = execute(invocation, Response.class);
+
+        if (!isSuccess(response)) {
+            throw parseError(response);
+        }
+
+        List<String> contentTypes = new ArrayList<>();
+        for(Object o : response.getHeaders().get("Content-Type")){
+            contentTypes.add(o.toString());
+        }
+        InputStream inputStream = response.readEntity(InputStream.class);
+
+        return new RoadObjectAttribute(contentTypes, inputStream);
+    }
+
+    private static void applyRequestParameters(UriBuilder path, MultivaluedMap<String, String> params) {
+        params.forEach((k, values) -> path.queryParam(k, values.toArray(new Object[0])));
+    }
+
+    public List<RoadObjectTypeWithStats> getSummary() {
+        return getSummary(DEFAULT);
+    }
+
+    public List<RoadObjectTypeWithStats> getSummary(RoadObjectRequest request) {
+        UriBuilder path = start();
+        applyRequestParameters(path, convert(request));
+        WebTarget target = getClient().target(path);
+        logger.debug("Invoking {}", path);
+        JsonArray array = execute(target).getAsJsonArray();
         return StreamSupport.stream(array.spliterator(), false)
-                .map(JsonElement::getAsJsonObject)
-                .map(o -> RoadObjectParser.parseAttribute(datakatalog.getDataTypeMap(), o))
-                .collect(Collectors.toList());
+            .map(JsonElement::getAsJsonObject)
+            .map(rt(RoadObjectParser::parseRoadObjectTypeWithStats))
+            .collect(toList());
+    }
+
+    private UriBuilder start(int typeId) {
+        return start().path(valueOf(typeId));
+    }
+
+    @Override
+    protected UriBuilder start() {
+        return super.start().path("vegobjekter");
     }
 
     public enum Include {
@@ -223,9 +274,9 @@ public class RoadObjectClient extends AbstractJerseyClient {
         }
 
         public static Set<Include> not(Include... without) {
-            return all().stream()
-                    .filter(v -> !Arrays.asList(without).contains(v))
-                    .collect(Collectors.toSet());
+            Set<Include> includes = all();
+            includes.removeAll(asList(without));
+            return includes;
         }
 
         public String stringValue() {
@@ -253,31 +304,39 @@ public class RoadObjectClient extends AbstractJerseyClient {
         }
     }
 
-    public static class RoadObjectsResult extends GenericResultSet<RoadObject> {
+    public enum IncludeAttribute {
+        BASE("basis"),
+        ASSOCIATIONS("assosiasjon"),
+        PLACEMENTS("stedfesting"),
+        GEOMETRY("geometri");
 
-        public RoadObjectsResult(WebTarget baseTarget,
-                                 Optional<Page> currentPage,
-                                 Datakatalog datakatalog) {
-            super(baseTarget, currentPage, o -> RoadObjectParser.parse(datakatalog.getDataTypeMap(), o));
+        private final String value;
+        IncludeAttribute(String stringValue) {
+            this.value = stringValue;
+        }
+
+        public String stringValue() {
+            return value;
+        }
+
+        public static Set<IncludeAttribute> all() {
+            return EnumSet.allOf(IncludeAttribute.class);
         }
     }
 
-    public static class AsyncRoadObjectsResult extends AsyncResult<RoadObject> {
+    public static class RoadObjectsResult extends GenericResultSet<RoadObject> {
 
-        public AsyncRoadObjectsResult(WebTarget baseTarget,
-                                      Page currentPage,
-                                      Datakatalog datakatalog) {
-            super(baseTarget, currentPage, o -> RoadObjectParser.parse(datakatalog.getDataTypeMap(), o));
+        public RoadObjectsResult(WebTarget baseTarget,
+                                 Page currentPage) {
+            super(baseTarget, currentPage, rt(RoadObjectParser::parse));
         }
     }
 
-    public static class ChangesResult extends GenericResultSet<Change> {
+    public static class AsyncRoadObjectsResult extends AsyncResult<RoadObject> {
 
-        public ChangesResult(Map<Integer, DataType> dataTypes,
-                             int typeId,
-                             WebTarget baseTarget,
-                             Optional<Page> currentPage) {
-            super(baseTarget, currentPage, obj -> ChangesParser.parse(dataTypes, obj, typeId));
+        public AsyncRoadObjectsResult(WebTarget baseTarget,
+                                      Page currentPage) {
+            super(baseTarget, currentPage, rt(RoadObjectParser::parse));
         }
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequest.java
index 37b0478..4c134c4 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequest.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequest.java
@@ -27,31 +27,48 @@ package no.vegvesen.nvdbapi.client.clients;
 
 import no.vegvesen.nvdbapi.client.model.Page;
 import no.vegvesen.nvdbapi.client.model.Projection;
+import no.vegvesen.nvdbapi.client.model.roadnet.*;
 
+import java.time.LocalDate;
+import java.time.LocalDateTime;
 import java.util.*;
 
+@SuppressWarnings({"WeakerAccess", "UnusedReturnValue", "unused"})
 public class RoadObjectRequest {
 
     public static final RoadObjectRequest DEFAULT = new Builder().build();
 
     private final Page page;
     private final Boolean segmented;
+    private final Boolean allVersions;
     private final String depth;
     private final Projection projection;
     private final Integer distanceTolerance;
     private final String attributeFilter;
     private final String bbox;
+    private final String bpolygon;
     private final String roadRefFilter;
     private final String refLinkFilter;
     private final Set<RoadObjectClient.Include> includes;
     private final Set<RoadObjectClient.IncludeGeometry> includeGeometries;
+    private final Set<RoadObjectClient.IncludeAttribute> includeAttributes;
     private final List<OverlapFilter> overlapFilters;
     private final List<Integer> municipalities;
     private final List<Integer> counties;
-    private final List<Integer> regions;
-    private final List<Integer> roadDepartments;
     private final List<String> contractAreas;
     private final List<String> nationalRoutes;
+    private final List<String> streets;
+    private final List<Long> roadobjectIds;
+    private final LocalDate pointInTime;
+    private final LocalDateTime modifiedAfter;
+    private final Boolean armFilter;
+    private final Boolean sideAreaFilter;
+    private final Boolean intersectionFilter;
+    private final RoadUserGroup roadUserGroupFilter;
+    private final SeparatePassages separatePassagesFilter;
+    private final DetailLevel detailLevel;
+    private final TypeOfRoad typeOfRoad;
+    private final RefLinkPartType refLinkPartType;
 
     private RoadObjectRequest(Builder b) {
         page = b.page;
@@ -60,18 +77,31 @@ public class RoadObjectRequest {
         projection = b.projection;
         includes = b.includes;
         includeGeometries = b.includeGeometries;
+        includeAttributes = b.includeAttributes;
         distanceTolerance = b.distanceTolerance;
         attributeFilter = b.attributeFilter;
         bbox = b.bbox;
+        bpolygon = b.bpolygon;
         roadRefFilter = b.roadRefFilter;
         refLinkFilter = b.refLinkFilter;
         overlapFilters = b.overlapFilters;
         municipalities = b.municipalities;
         counties = b.counties;
-        regions = b.regions;
-        roadDepartments = b.roadDepartments;
         contractAreas = b.contractAreas;
         nationalRoutes = b.nationalRoutes;
+        streets = b.streets;
+        allVersions = b.allVersions;
+        roadobjectIds = b.roadobjectIds;
+        pointInTime = b.pointInTime;
+        modifiedAfter = b.modifiedAfter;
+        armFilter = b.armFilter;
+        sideAreaFilter = b.sideAreaFilter;
+        intersectionFilter = b.intersectionFilter;
+        detailLevel = b.detailLevel;
+        typeOfRoad = b.typeOfRoad;
+        refLinkPartType = b.refLinkPartType;
+        roadUserGroupFilter = b.roadUserGroupFilter;
+        separatePassagesFilter = b.separatePassagesFilter;
     }
 
     public static Builder newBuilder() {
@@ -86,6 +116,10 @@ public class RoadObjectRequest {
         return Optional.ofNullable(segmented);
     }
 
+    public Optional<Boolean> getAllVersions() {
+        return Optional.ofNullable(allVersions);
+    }
+
     public Optional<String> getDepth() {
         return Optional.ofNullable(depth);
     }
@@ -106,6 +140,10 @@ public class RoadObjectRequest {
         return this.includeGeometries;
     }
 
+    public Set<RoadObjectClient.IncludeAttribute> getIncludeAttributes() {
+        return includeAttributes;
+    }
+
     public List<OverlapFilter> getOverlapFilters() {
         return overlapFilters;
     }
@@ -118,6 +156,10 @@ public class RoadObjectRequest {
         return Optional.ofNullable(bbox);
     }
 
+    public Optional<String> getBpolygon() {
+        return Optional.ofNullable(bpolygon);
+    }
+
     public Optional<String> getRoadRefFilter() {
         return Optional.ofNullable(roadRefFilter);
     }
@@ -134,14 +176,6 @@ public class RoadObjectRequest {
         return counties;
     }
 
-    public List<Integer> getRegions() {
-        return regions;
-    }
-
-    public List<Integer> getRoadDepartments() {
-        return roadDepartments;
-    }
-
     public List<String> getContractAreas() {
         return contractAreas;
     }
@@ -150,6 +184,54 @@ public class RoadObjectRequest {
         return nationalRoutes;
     }
 
+    public List<String> getStreets() {
+        return streets;
+    }
+
+    public List<Long> getRoadobjectIds() {
+        return roadobjectIds;
+    }
+
+    public Optional<LocalDate> getPointInTime() {
+        return Optional.ofNullable(pointInTime);
+    }
+
+    public Optional<Boolean> getArmFilter() {
+        return Optional.ofNullable(armFilter);
+    }
+
+    public Optional<Boolean> getSideAreaFilter() {
+        return Optional.ofNullable(sideAreaFilter);
+    }
+
+    public Optional<Boolean> getIntersectionFilter() {
+        return Optional.ofNullable(intersectionFilter);
+    }
+
+    public Optional<RoadUserGroup> getRoadUserGroupFilter() {
+        return Optional.ofNullable(roadUserGroupFilter);
+    }
+
+    public Optional<SeparatePassages> getSeparatePassagesFilter() {
+        return Optional.ofNullable(separatePassagesFilter);
+    }
+
+    public Optional<LocalDateTime> getModifiedAfter() {
+        return Optional.ofNullable(modifiedAfter);
+    }
+
+    public Optional<DetailLevel> getDetailLevel() {
+        return Optional.ofNullable(detailLevel);
+    }
+
+    public Optional<TypeOfRoad> getTypeOfRoad() {
+        return Optional.ofNullable(typeOfRoad);
+    }
+
+    public Optional<RefLinkPartType> getRefLinkPartType() {
+        return Optional.ofNullable(refLinkPartType);
+    }
+
     /**
      * This method strips any parameters that are not supported by the API
      * for statistics requests
@@ -166,48 +248,73 @@ public class RoadObjectRequest {
     }
 
     public Builder toMutable() {
-        Builder b = new Builder();
-        b.withPage(page);
-        b.withSegmented(segmented);
-        b.withDepth(depth);
-        b.withProjection(projection);
-        b.withDistanceTolerance(distanceTolerance);
-        b.withIncludes(includes);
-        b.withAttributeFilter(attributeFilter);
-        b.withBbox(bbox);
-        b.withRoadRefFilter(roadRefFilter);
-        b.withRefLinkFilter(refLinkFilter);
+        Builder b = new Builder()
+                .withPage(page)
+                .withSegmented(segmented)
+                .withDepth(depth)
+                .withProjection(projection)
+                .withDistanceTolerance(distanceTolerance)
+                .withIncludes(includes)
+                .withAttributeFilter(attributeFilter)
+                .withBbox(bbox)
+                .withBpolygon(bpolygon)
+                .withRoadRefFilter(roadRefFilter)
+                .withRefLinkFilter(refLinkFilter)
+                .withMunicipalities(municipalities)
+                .withCounties(counties)
+                .withAllVersions(allVersions)
+                .withPointInTime(pointInTime)
+                .withModifiedAfter(modifiedAfter)
+                .withIds(roadobjectIds)
+                .withArmFilter(armFilter)
+                .withSideAreaFilter(sideAreaFilter)
+                .withIntersectionFilter(intersectionFilter)
+                .withSeparatePassagesFilter(separatePassagesFilter)
+                .withRoadUserGroupFilter(roadUserGroupFilter)
+                .withRefLinkPartType(refLinkPartType)
+                .withTypeOfRoad(typeOfRoad)
+                .withDetailLevel(detailLevel);
+
         overlapFilters.forEach(of -> b.addOverlapFilter(of.filter, of.typeId));
-        b.withMunicipalities(municipalities);
-        b.withCounties(counties);
-        b.withRegions(regions);
-        b.withRoadDepartments(roadDepartments);
         return b;
     }
 
     public static class Builder {
 
+        private RefLinkPartType refLinkPartType;
+        private DetailLevel detailLevel;
+        private TypeOfRoad typeOfRoad;
+
         private Page page = Page.count(1000);
         private Boolean segmented;
-        private String depth = null;
-        private Projection projection = null;
-        private Integer distanceTolerance = null;
+        private Boolean allVersions;
+        private String depth;
+        private Projection projection;
+        private Integer distanceTolerance;
         private Set<RoadObjectClient.Include> includes = Collections.emptySet();
         private Set<RoadObjectClient.IncludeGeometry> includeGeometries = Collections.emptySet();
-        private String attributeFilter = null;
-        private String bbox = null;
-        private String roadRefFilter = null;
-        private String refLinkFilter = null;
+        private Set<RoadObjectClient.IncludeAttribute> includeAttributes = Collections.emptySet();
+        private String attributeFilter;
+        private String bbox;
+        private String bpolygon;
+        private String roadRefFilter;
+        private String refLinkFilter;
         private List<OverlapFilter> overlapFilters = new ArrayList<>();
         private List<Integer> municipalities = Collections.emptyList();
         private List<Integer> counties = Collections.emptyList();
-        private List<Integer> regions = Collections.emptyList();
-        private List<Integer> roadDepartments = Collections.emptyList();
         private List<String> contractAreas = Collections.emptyList();
         private List<String> nationalRoutes = Collections.emptyList();
-
-        private Builder() {
-        }
+        private List<String> streets = Collections.emptyList();
+        private List<Long> roadobjectIds = Collections.emptyList();
+        private LocalDate pointInTime;
+        private Boolean armFilter;
+        private Boolean sideAreaFilter;
+        private Boolean intersectionFilter;
+        private RoadUserGroup roadUserGroupFilter;
+        private SeparatePassages separatePassagesFilter;
+        private LocalDateTime modifiedAfter;
+
+        private Builder() { }
 
         public RoadObjectRequest build() {
             return new RoadObjectRequest(this);
@@ -227,6 +334,21 @@ public class RoadObjectRequest {
             return this;
         }
 
+        public Builder withDetailLevel(DetailLevel detailLevel) {
+            this.detailLevel = detailLevel;
+            return this;
+        }
+
+        public Builder withTypeOfRoad(TypeOfRoad typeOfRoad) {
+            this.typeOfRoad = typeOfRoad;
+            return this;
+        }
+
+        public Builder withRefLinkPartType(RefLinkPartType refLinkPartType) {
+            this.refLinkPartType = refLinkPartType;
+            return this;
+        }
+
         public Builder withProjection(Projection projection) {
             this.projection = projection;
             return this;
@@ -261,6 +383,16 @@ public class RoadObjectRequest {
             return this;
         }
 
+        public Builder withIncludeAttributes(Set<RoadObjectClient.IncludeAttribute> includeAttributes) {
+            this.includeAttributes = includeAttributes;
+            return this;
+        }
+
+        public Builder withIncludeAttributes(RoadObjectClient.IncludeAttribute... includeAttributes) {
+            this.includeAttributes = new HashSet<>(Arrays.asList(includeAttributes));
+            return this;
+        }
+
         public Builder withIncludeGeometries(RoadObjectClient.IncludeGeometry... includes) {
             this.includeGeometries = new HashSet<>(Arrays.asList(includes));
             return this;
@@ -285,6 +417,11 @@ public class RoadObjectRequest {
             return this;
         }
 
+        public Builder withBpolygon(String bpolygon) {
+            this.bpolygon = bpolygon;
+            return this;
+        }
+
         public Builder withRoadRefFilter(String filter) {
             this.roadRefFilter = filter;
             return this;
@@ -295,33 +432,28 @@ public class RoadObjectRequest {
             return this;
         }
 
-        public Builder withRoadDepartments(List<Integer> roadDepartments) {
-            this.roadDepartments = roadDepartments;
-            return this;
-        }
-
-        public Builder withRoadDepartments(Integer... roadDepartments) {
-            this.roadDepartments = Arrays.asList(roadDepartments);
+        public Builder withArmFilter(Boolean arm) {
+            this.armFilter = arm;
             return this;
         }
 
-        public Builder withRoadDepartment(Integer roadDepartment) {
-            this.roadDepartments = Collections.singletonList(roadDepartment);
+        public Builder withSideAreaFilter(Boolean sideAreaFilter) {
+            this.sideAreaFilter = sideAreaFilter;
             return this;
         }
 
-        public Builder withRegions(List<Integer> regions) {
-            this.regions = regions;
+        public Builder withIntersectionFilter(Boolean intersectionFilter) {
+            this.intersectionFilter = intersectionFilter;
             return this;
         }
 
-        public Builder withRegions(Integer... regions) {
-            this.regions = Arrays.asList(regions);
+        public Builder withSeparatePassagesFilter(SeparatePassages separatePassagesFilter) {
+            this.separatePassagesFilter = separatePassagesFilter;
             return this;
         }
 
-        public Builder withRegion(Integer region) {
-            this.regions = Collections.singletonList(region);
+        public Builder withRoadUserGroupFilter(RoadUserGroup roadUserGroupFilter) {
+            this.roadUserGroupFilter = roadUserGroupFilter;
             return this;
         }
 
@@ -384,6 +516,36 @@ public class RoadObjectRequest {
             this.nationalRoutes = Arrays.asList(nationalRoutes);
             return this;
         }
+
+        public Builder withStreet(String street) {
+            this.streets = Collections.singletonList(street);
+            return this;
+        }
+
+        public Builder withStreets(String... streets) {
+            this.streets = Arrays.asList(streets);
+            return this;
+        }
+
+        public Builder withAllVersions(Boolean allVersions) {
+            this.allVersions = allVersions;
+            return this;
+        }
+
+        public Builder withIds(List<Long> roadobjectIds) {
+            this.roadobjectIds = roadobjectIds;
+            return this;
+        }
+
+        public Builder withPointInTime(LocalDate date) {
+            this.pointInTime = date;
+            return this;
+        }
+
+        public Builder withModifiedAfter(LocalDateTime date) {
+            this.modifiedAfter = date;
+            return this;
+        }
     }
 
     public static class OverlapFilter {
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilder.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilder.java
index b757ff0..d3308c4 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilder.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilder.java
@@ -28,33 +28,48 @@ package no.vegvesen.nvdbapi.client.clients;
 
 import javax.ws.rs.core.MultivaluedHashMap;
 import javax.ws.rs.core.MultivaluedMap;
+import java.time.format.DateTimeFormatter;
 import java.util.*;
 import java.util.stream.Collectors;
 
 class RoadObjectRequestBuilder {
-    private RoadObjectRequestBuilder() {
-    }
+    private RoadObjectRequestBuilder() {}
 
     static MultivaluedMap<String, String> convert(RoadObjectRequest request) {
         MultivaluedMap<String, String> map = new MultivaluedHashMap<>();
 
         // Single parameters
         request.getSegmented().ifPresent(v -> map.putSingle("segmentering", Boolean.toString(v)));
+        request.getAllVersions().ifPresent(v -> map.putSingle("alle_versjoner", Boolean.toString(v)));
+        request.getPointInTime().ifPresent(v -> map.putSingle("tidspunkt",
+            v.format(DateTimeFormatter.ISO_DATE)));
+        request.getArmFilter().ifPresent(v -> map.putSingle("arm", Boolean.toString(v)));
+        request.getIntersectionFilter().ifPresent(v -> map.putSingle("kryssystem", Boolean.toString(v)));
+        request.getSideAreaFilter().ifPresent(v -> map.putSingle("sideanlegg", Boolean.toString(v)));
+        request.getRoadUserGroupFilter().ifPresent(v -> map.putSingle("trafikantgruppe", v.getTextValue()));
+        request.getSeparatePassagesFilter().ifPresent(v -> map.putSingle("adskiltelop", v.getTextValue()));
+        request.getModifiedAfter().ifPresent(v -> map.putSingle("endret_etter",
+                v.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)));
         request.getProjection().ifPresent(v -> map.putSingle("srid", Integer.toString(v.getSrid())));
         request.getDistanceTolerance().ifPresent(v -> map.putSingle("geometritoleranse", Integer.toString(v)));
         request.getDepth().ifPresent(v -> map.putSingle("dybde", v));
         getIncludeArgument(request.getIncludes()).ifPresent(v -> map.putSingle("inkluder", v));
         getIncludeGeometriesArgument(request.getIncludeGeometries()).ifPresent(v -> map.putSingle("inkludergeometri", v));
+        getIncludeAttributesArgument(request.getIncludeAttributes()).ifPresent(v -> map.putSingle("inkluder_egenskaper", v));
         request.getAttributeFilter().ifPresent(v -> map.putSingle("egenskap", v));
+        request.getBpolygon().ifPresent(v -> map.putSingle("polygon", v));
         request.getBbox().ifPresent(v -> map.putSingle("kartutsnitt", v));
-        request.getRoadRefFilter().ifPresent(v -> map.putSingle("vegreferanse", v));
-        request.getRefLinkFilter().ifPresent(v -> map.putSingle("veglenke", v));
+        request.getDetailLevel().ifPresent(v -> map.putSingle("detaljniva", v.getSosi()));
+        request.getTypeOfRoad().ifPresent(v -> map.putSingle("typeveg", v.getTypeOfRoadSosi()));
+        request.getRefLinkPartType().ifPresent(v -> map.putSingle("veglenketype", v.getRefLinkPartType()));
+        request.getRoadRefFilter().ifPresent(v -> map.putSingle("vegsystemreferanse", v));
+        request.getRefLinkFilter().ifPresent(v -> map.putSingle("veglenkesekvens", v));
         flatten(request.getMunicipalities()).ifPresent(v -> map.putSingle("kommune", v));
+        flatten(request.getRoadobjectIds()).ifPresent(v -> map.putSingle("ider", v));
         flatten(request.getCounties()).ifPresent(v -> map.putSingle("fylke", v));
-        flatten(request.getRegions()).ifPresent(v -> map.putSingle("region", v));
-        flatten(request.getRoadDepartments()).ifPresent(v -> map.putSingle("vegavdeling", v));
         flattenString(request.getContractAreas()).ifPresent(v -> map.putSingle("kontraktsomrade", v));
         flattenString(request.getNationalRoutes()).ifPresent(v -> map.putSingle("riksvegrute", v));
+        flattenString(request.getStreets()).ifPresent(v -> map.putSingle("gate", v));
 
         // Multiple parameters
         request.getOverlapFilters().forEach(f -> map.add("overlapp", f.toString()));
@@ -102,7 +117,20 @@ class RoadObjectRequestBuilder {
                 .collect(Collectors.joining(",")));
     }
 
-    private static Optional<String> flatten(List<Integer> set) {
+    private static Optional<String> getIncludeAttributesArgument(Set<RoadObjectClient.IncludeAttribute> values) {
+        // Defaults
+        if (values == null
+            || values.isEmpty()
+            || values.equals(RoadObjectClient.IncludeAttribute.all())) {
+            return Optional.empty();
+        }
+
+        return Optional.of(values.stream()
+            .map(RoadObjectClient.IncludeAttribute::stringValue)
+            .collect(Collectors.joining(",")));
+    }
+
+    private static Optional<String> flatten(List<?> set) {
         if (set.isEmpty()) {
             return Optional.empty();
         }
@@ -117,7 +145,6 @@ class RoadObjectRequestBuilder {
             return Optional.empty();
         }
 
-        return Optional.of(set.stream()
-                              .collect(Collectors.joining(",")));
+        return Optional.of(String.join(",", set));
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadPlacementClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadPlacementClient.java
index 5b567fb..99d31a6 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadPlacementClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadPlacementClient.java
@@ -27,7 +27,6 @@ package no.vegvesen.nvdbapi.client.clients;
 
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
 import no.vegvesen.nvdbapi.client.gson.RoadPlacementParser;
 import no.vegvesen.nvdbapi.client.model.Projection;
 import no.vegvesen.nvdbapi.client.model.RoadPlacement;
@@ -38,67 +37,24 @@ import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.UriBuilder;
 import java.util.List;
 import java.util.Optional;
+import java.util.function.Consumer;
 import java.util.stream.Collectors;
 
-public class RoadPlacementClient extends AbstractJerseyClient {
-
-    protected RoadPlacementClient(String baseUrl, Client client) {
-        super(baseUrl, client);
-    }
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
 
-    /**
-     *
-     * @param request to execute
-     * @return {@code {@link RoadPlacement}} matching request
-     * @deprecated Use {@link #findPlacement(RefLinkRequest)}
-     */
-    @Deprecated
-    public RoadPlacement getRoadPlacement(RoadRefRequest request) {
-        return getResults("vegreferanse", request.getQueryParam(), null).orElse(null);
-    }
-
-    /**
-     *
-     * @param request to execute
-     * @param projection used for coordinates in query and result
-     * @return {@code {@link RoadPlacement}} matching request
-     * @deprecated Use {@link #findPlacement(RefLinkRequest)}
-     */
-    @Deprecated
-    public RoadPlacement getRoadPlacement(RoadRefRequest request, Projection projection) {
-        return getResults("vegreferanse", request.getQueryParam(), projection).orElse(null);
-    }
-
-    /**
-     *
-     * @param request to execute
-     * @return {@code {@link RoadPlacement}} matching request
-     * @deprecated Use {@link #findPlacement(RefLinkRequest)}
-     */
-    @Deprecated
-    public RoadPlacement getRoadPlacement(RefLinkRequest request) {
-        return getResults("veglenke", request.getQueryParam(), null).orElse(null);
-    }
+public class RoadPlacementClient extends AbstractJerseyClient {
 
-    /**
-     *
-     * @param request to execute
-     * @param projection used in query and result
-     * @return {@code {@link RoadPlacement}} matching request
-     * @deprecated Use {@link #findPlacement(RefLinkRequest)}
-     */
-    @Deprecated
-    public RoadPlacement getRoadPlacement(RefLinkRequest request, Projection projection) {
-        return getResults("veglenke", request.getQueryParam(), projection).orElse(null);
+    RoadPlacementClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
     }
 
     /**
-     * Search for a placement by road ref.
+     * Search for a placement by road sys ref.
      * @param request search parameters
      * @return {@code Optional<RoadPlacement>} if query had result, otherwise {@code Optional.empty()}
      */
-    public Optional<RoadPlacement> findPlacement(RoadRefRequest request) {
-        return getResults("vegreferanse", request.getQueryParam(), request.getProjection().orElse(null));
+    public Optional<RoadPlacement> findPlacement(RoadSysRefRequest request) {
+        return getResults("vegsystemreferanse", request.getQueryParam(), request.getMunicipality().orElse(null), request.getProjection().orElse(null));
     }
 
     /**
@@ -107,43 +63,47 @@ public class RoadPlacementClient extends AbstractJerseyClient {
      * @return {@code Optional<RoadPlacement>} if query had result, otherwise {@code Optional.empty()}
      */
     public Optional<RoadPlacement> findPlacement(RefLinkRequest request) {
-        return getResults("veglenke", request.getQueryParam(), request.getProjection().orElse(null));
+        return getResults("veglenkesekvens", request.getQueryParam(), null, request.getProjection().orElse(null));
     }
 
-    public List<RoadPlacementBulkResult> getRoadPlacementsInBulk(List<RoadRefRequest> requests, Projection projection) {
-        String queryParam = requests.stream().map(RoadRefRequest::getQueryParam).collect(Collectors.joining(","));
-        return getRoadPlacementsInBatch("vegreferanser", queryParam, projection);
+    public List<RoadPlacementBulkResult> getRoadPlacementsInBulk(List<RoadSysRefRequest> requests, Integer municipality, Projection projection) {
+        String queryParam = requests.stream().map(RoadSysRefRequest::getQueryParam).collect(Collectors.joining(","));
+        return getRoadPlacementsInBatch("vegsystemreferanser", queryParam, municipality, projection);
     }
 
     public List<RoadPlacementBulkResult> getRoadPlacementsInBulkFromReflinks(List<RefLinkRequest> requests, Projection projection) {
         String queryParam = requests.stream().map(RefLinkRequest::getQueryParam).collect(Collectors.joining(","));
-        return getRoadPlacementsInBatch("veglenker", queryParam, projection);
+        return getRoadPlacementsInBatch("veglenkesekvenser", queryParam, null, projection);
     }
 
-    private List<RoadPlacementBulkResult> getRoadPlacementsInBatch(String paramName, String queryParam, Projection projection) {
+    private List<RoadPlacementBulkResult> getRoadPlacementsInBatch(String paramName, String queryParam, Integer municipality, Projection projection) {
         UriBuilder url = bulkEndpoint();
 
         url.queryParam(paramName, queryParam);
+        Optional.ofNullable(municipality).ifPresent(p -> url.queryParam("kommune", municipality));
         Optional.ofNullable(projection).ifPresent(p -> url.queryParam("srid", projection.getSrid()));
 
         WebTarget target = getClient().target(url);
 
         JsonObject resultMap = JerseyHelper.execute(target).getAsJsonObject();
 
-        return resultMap.entrySet().stream().map(r -> RoadPlacementParser.parseRoadPlacementBulkResult(r.getKey(), r.getValue())).collect(Collectors.toList());
+        return resultMap.entrySet().stream()
+            .map(r -> RoadPlacementParser.parseRoadPlacementBulkResult(r.getKey(), r.getValue()))
+            .collect(Collectors.toList());
     }
 
-    private Optional<RoadPlacement> getResults(String paramName, String queryParam, Projection projection) {
+    private Optional<RoadPlacement> getResults(String paramName, String queryParam, Integer municipality, Projection projection) {
         UriBuilder url = endpoint();
 
         url.queryParam(paramName, queryParam);
+        Optional.ofNullable(municipality).ifPresent(p -> url.queryParam("kommune", municipality));
         Optional.ofNullable(projection).ifPresent(p -> url.queryParam("srid", projection.getSrid()));
 
         WebTarget target = getClient().target(url);
 
         return JerseyHelper.executeOptional(target)
                 .map(JsonElement::getAsJsonObject)
-                .map(RoadPlacementParser::parseRoadPlacement);
+                .map(rt(RoadPlacementParser::parseRoadPlacement));
     }
 
     private UriBuilder endpoint() {
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadRefRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadRefRequest.java
deleted file mode 100644
index ffe4207..0000000
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadRefRequest.java
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.vegvesen.nvdbapi.client.clients;
-
-import no.vegvesen.nvdbapi.client.model.Projection;
-
-import java.util.Optional;
-
-public class RoadRefRequest {
-
-    private final int county;
-    private final int municipality;
-    private final String roadCategory;
-    private final String roadStatus;
-    private final int roadNumber;
-    private final int hp;
-    private final int meter;
-    private final Projection projection;
-
-    public RoadRefRequest(Builder builder) {
-        this.county = builder.county;
-        this.municipality = builder.municipality;
-        this.roadCategory = builder.roadCategory;
-        this.roadStatus = builder.roadStatus;
-        this.roadNumber = builder.roadNumber;
-        this.hp = builder.hp;
-        this.meter = builder.meter;
-        this.projection = builder.projection;
-    }
-
-    public int getCounty() { return county; }
-
-    public int getMunicipality() {
-        return municipality;
-    }
-
-    public String getRoadCategory() {
-        return roadCategory;
-    }
-
-    public String getRoadStatus() {
-        return roadStatus;
-    }
-
-    public int getRoadNumber() {return roadNumber; }
-
-    public int getHp() {
-        return hp;
-    }
-
-    public int getMeter() {
-        return meter;
-    }
-
-    public Optional<Projection> getProjection() {
-        return Optional.ofNullable(projection);
-    }
-
-    public String getQueryParam() {
-        String county = String.format("%02d", this.getCounty());
-        String municipality = String.format("%02d", this.getMunicipality());
-
-        return county + municipality + this.getRoadCategory() + this.getRoadStatus() + this.getRoadNumber() +
-                "hp" + this.getHp() + "m" + this.getMeter();
-    }
-
-    @Override
-    public String toString() {
-        return this.getQueryParam();
-    }
-
-    public final static class Builder {
-        private int county;
-        private int municipality;
-        private String roadCategory;
-        private String roadStatus;
-        private int roadNumber;
-        private int hp;
-        private int meter;
-        private Projection projection;
-
-        @Deprecated
-        public Builder setMunicipality(int municipality) {
-            return withMunicipality(municipality);
-        }
-
-        @Deprecated
-        public Builder setRoadCategory(String roadCategory) {
-            return withRoadCategory(roadCategory);
-        }
-
-        @Deprecated
-        public Builder setRoadStatus(String roadStatus) {
-            return withRoadStatus(roadStatus);
-        }
-
-        @Deprecated
-        public Builder setRoadNumber(int roadNumber) {
-            return withRoadNumber(roadNumber);
-        }
-
-        @Deprecated
-        public Builder setCounty(int county) {
-            return withCounty(county);
-        }
-
-        @Deprecated
-        public Builder setHp(int hp) {
-            return withHp(hp);
-        }
-
-        @Deprecated
-        public Builder setMeter(int meter) {
-            return withMeter(meter);
-        }
-
-        public Builder withMunicipality(int municipality) {
-            this.municipality = municipality;
-            return this;
-        }
-
-        public Builder withRoadCategory(String roadCategory) {
-            this.roadCategory = roadCategory;
-            return this;
-        }
-
-        public Builder withRoadStatus(String roadStatus) {
-            this.roadStatus = roadStatus;
-            return this;
-        }
-
-        public Builder withRoadNumber(int roadNumber) {
-            this.roadNumber = roadNumber;
-            return this;
-        }
-
-        public Builder withCounty(int county) {
-            this.county = county;
-            return this;
-        }
-
-        public Builder withHp(int hp) {
-            this.hp = hp;
-            return this;
-        }
-
-        public Builder withMeter(int meter) {
-            this.meter = meter;
-            return this;
-        }
-
-        public Builder withProjection(Projection projection) {
-            this.projection = projection;
-            return this;
-        }
-
-        public RoadRefRequest build() {
-            return new RoadRefRequest(this);
-        }
-    }
-}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadSysRefRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadSysRefRequest.java
new file mode 100644
index 0000000..da46cd9
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/RoadSysRefRequest.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.clients;
+
+import no.vegvesen.nvdbapi.client.model.Projection;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.Phase;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadCategory;
+
+import java.util.Optional;
+
+import static java.util.Objects.nonNull;
+
+public class RoadSysRefRequest {
+
+    // RoadSystem
+    private final Integer roadNumber;
+    private final RoadCategory roadCategory;
+    private final Phase phase;
+
+    // Secion
+    private final Integer sectionNumber;
+    private final Integer sectionPartNumber;
+    private final Integer sectionMeter;
+
+    // Intersection
+    private final Integer interSectionNumber;
+    private final Integer interSectionPart;
+    private final Integer interSectionMeter;
+
+    // Sidearea
+    private final Integer sideAreaNumber;
+    private final Integer sideAreaPart;
+    private final Integer sideAreaMeter;
+
+    // Other
+    private final Integer municipality;
+    private final Projection projection;
+
+    public RoadSysRefRequest(Builder builder) {
+        this.roadNumber = builder.roadNumber;
+        this.roadCategory = builder.roadCategory;
+        this.phase = builder.phase;
+        this.sectionNumber = builder.sectionNumber;
+        this.sectionPartNumber = builder.sectionPartNumber;
+        this.sectionMeter = builder.sectionMeter;
+        this.interSectionNumber = builder.interSectionNumber;
+        this.interSectionPart = builder.interSectionPart;
+        this.interSectionMeter = builder.interSectionMeter;
+        this.sideAreaNumber = builder.sideAreaNumber;
+        this.sideAreaPart = builder.sideAreaPart;
+        this.sideAreaMeter = builder.sideAreaMeter;
+        this.municipality = builder.municipality;
+        this.projection = builder.projection;
+    }
+
+    public static Builder newBuilder() {
+        return new Builder();
+    }
+
+    public Integer getRoadNumber() {
+        return roadNumber;
+    }
+
+    public RoadCategory getRoadCategory() {
+        return roadCategory;
+    }
+
+    public Phase getPhase() {
+        return phase;
+    }
+
+    public Integer getSectionNumber() {
+        return sectionNumber;
+    }
+
+    public Integer getSectionPartNumber() {
+        return sectionPartNumber;
+    }
+
+    public Integer getSectionMeter() {
+        return sectionMeter;
+    }
+
+    public Integer getInterSectionNumber() {
+        return interSectionNumber;
+    }
+
+    public Integer getInterSectionPart() {
+        return interSectionPart;
+    }
+
+    public Integer getInterSectionMeter() {
+        return interSectionMeter;
+    }
+
+    public Integer getSideAreaNumber() {
+        return sideAreaNumber;
+    }
+
+    public Integer getSideAreaPart() {
+        return sideAreaPart;
+    }
+
+    public Integer getSideAreaMeter() {
+        return sideAreaMeter;
+    }
+
+    public Optional<Integer> getMunicipality() {
+        return Optional.ofNullable(municipality);
+    }
+
+    public Optional<Projection> getProjection() {
+        return Optional.ofNullable(projection);
+    }
+
+    public String getQueryParam() {
+        return this.getRoadCategory().name() + this.getPhase() + this.getRoadNumber() +
+                "S" + this.getSectionNumber() + "D" + this.getSectionPartNumber() + "M" + this.getSectionMeter() +
+                (nonNull(this.getInterSectionPart()) ? "KD" + this.getInterSectionPart() + "M" + this.getInterSectionMeter() : "") +
+                (nonNull(this.getSideAreaPart()) ? "SD" + this.getSideAreaPart() + "M" + this.getSideAreaMeter() : "");
+    }
+
+    @Override
+    public String toString() {
+        return this.getQueryParam();
+    }
+
+    public final static class Builder {
+        private Integer roadNumber;
+        private RoadCategory roadCategory;
+        private Phase phase;
+        private Integer sectionNumber;
+        private Integer sectionPartNumber;
+        private Integer sectionMeter;
+        private Integer interSectionNumber;
+        private Integer interSectionPart;
+        private Integer interSectionMeter;
+        private Integer sideAreaNumber;
+        private Integer sideAreaPart;
+        private Integer sideAreaMeter;
+        private Integer municipality;
+        private Projection projection;
+
+        public Builder withRoadNumber(Integer roadNumber) {
+            this.roadNumber = roadNumber;
+            return this;
+        }
+
+        public Builder withRoadCategory(RoadCategory roadCategory) {
+            this.roadCategory = roadCategory;
+            return this;
+        }
+
+        public Builder withRoadCategory(String roadCategory) {
+            this.roadCategory = RoadCategory.valueOf(roadCategory);
+            return this;
+        }
+
+        public Builder withPhase(Phase phase) {
+            this.phase = phase;
+            return this;
+        }
+
+
+        public Builder withPhase(String phase) {
+            this.phase = Phase.valueOf(phase);
+            return this;
+        }
+
+        public Builder withSectionNumber(Integer sectionNumber) {
+            this.sectionNumber = sectionNumber;
+            return this;
+        }
+
+        public Builder withSectionPartNumber(Integer sectionPartNumber) {
+            this.sectionPartNumber = sectionPartNumber;
+            return this;
+        }
+
+        public Builder withSectionMeter(Integer sectionMeter) {
+            this.sectionMeter = sectionMeter;
+            return this;
+        }
+
+        public Builder withInterSectionNumber(Integer interSectionNumber) {
+            this.interSectionNumber = interSectionNumber;
+            return this;
+        }
+
+        public Builder withInterSectionPart(Integer interSectionPart) {
+            this.interSectionPart = interSectionPart;
+            return this;
+        }
+
+        public Builder withInterSectionMeter(Integer interSectionMeter) {
+            this.interSectionMeter = interSectionMeter;
+            return this;
+        }
+
+        public Builder withSideAreaNumber(Integer sideAreaNumber) {
+            this.sideAreaNumber = sideAreaNumber;
+            return this;
+        }
+
+        public Builder withSideAreaPart(Integer sideAreaPart) {
+            this.sideAreaPart = sideAreaPart;
+            return this;
+        }
+
+        public Builder withSideAreaMeter(Integer sideAreaMeter) {
+            this.sideAreaMeter = sideAreaMeter;
+            return this;
+        }
+
+        public Builder withMunicipality(Integer municipality) {
+            this.municipality = municipality;
+            return this;
+        }
+
+        public Builder withProjection(Projection projection) {
+            this.projection = projection;
+            return this;
+        }
+
+        public RoadSysRefRequest build() {
+            return new RoadSysRefRequest(this);
+        }
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/SegmentedRoadNetClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/SegmentedRoadNetClient.java
new file mode 100644
index 0000000..30a80e3
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/SegmentedRoadNetClient.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.clients;
+
+import java.time.format.DateTimeFormatter;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.UriBuilder;
+
+import com.google.gson.JsonElement;
+
+import no.vegvesen.nvdbapi.client.gson.SegmentedLinkParser;
+import no.vegvesen.nvdbapi.client.model.Page;
+import no.vegvesen.nvdbapi.client.model.roadnet.SegmentedLink;
+import no.vegvesen.nvdbapi.client.model.roadnet.TopologyLevel;
+
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
+
+public class SegmentedRoadNetClient extends AbstractJerseyClient {
+
+    SegmentedRoadNetClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
+    }
+
+    public List<SegmentedLink> getLinks(long linksequenceId) {
+        UriBuilder path = endpoint().path("/veglenkesekvenser/segmentert").path(Long.toString(linksequenceId));
+
+        WebTarget target = getClient().target(path);
+        return getLinks(target);
+    }
+
+    public List<SegmentedLink> getLinks(long linksequenceId, RoadNetRequest request) {
+        WebTarget target = getWebTarget(linksequenceId, request);
+
+        return getLinks(target);
+    }
+
+    public SegmentedLinkResult getLinks() {
+        return getLinks(RoadNetRequest.DEFAULT);
+    }
+
+    public AsyncSegmentedLinkResult getLinksAsync() {
+        return getLinksAsync(RoadNetRequest.DEFAULT);
+    }
+
+    public SegmentedLinkResult getLinks(RoadNetRequest request) {
+        WebTarget target = getWebTarget(request);
+        return new SegmentedLinkResult(target, request.getPage());
+    }
+
+    public AsyncSegmentedLinkResult getLinksAsync(RoadNetRequest request) {
+        WebTarget target = getWebTarget(request);
+        return new AsyncSegmentedLinkResult(target, request.getPage());
+    }
+
+    private List<SegmentedLink> getLinks(WebTarget target) {
+        JsonElement result = JerseyHelper.execute(target);
+        if (result.isJsonArray()) {
+            return StreamSupport.stream(result.getAsJsonArray().spliterator(), false)
+                .map(JsonElement::getAsJsonObject)
+                .map(rt(SegmentedLinkParser::parse))
+                .collect(Collectors.toList());
+        } else {
+            return Collections.singletonList(SegmentedLinkParser.parse(result.getAsJsonObject()));
+        }
+    }
+
+    private WebTarget getWebTarget(long linksequenceId, RoadNetRequest request) {
+        return getWebTarget(request, endpoint().path("/veglenkesekvenser/segmentert").path(Long.toString(linksequenceId)));
+    }
+
+    private WebTarget getWebTarget(RoadNetRequest request) {
+        return getWebTarget(request, endpoint().path("/veglenkesekvenser/segmentert"));
+    }
+
+    private WebTarget getWebTarget(RoadNetRequest request, UriBuilder path) {
+        Objects.requireNonNull(request, "Missing page info argument.");
+
+        if (!request.getCounties().isEmpty()) path.queryParam("fylke", join(request.getCounties()));
+        if (!request.getMunicipalities().isEmpty()) path.queryParam("kommune", join(request.getMunicipalities()));
+        request.getContractArea().ifPresent(v -> path.queryParam("kontraktsomrade", v));
+        request.getNationalRoute().ifPresent(v -> path.queryParam("riksvegrute", v));
+        request.getStreet().ifPresent(v -> path.queryParam("gate", v));
+        request.getBbox().ifPresent(v -> path.queryParam("kartutsnitt", v));
+        request.getBpolygon().ifPresent(v -> path.queryParam("polygon", v));
+        request.getProjection().ifPresent(v -> path.queryParam("srid", v.getSrid()));
+        request.getRoadRefFilter().ifPresent(v -> path.queryParam("vegsystemreferanse", v));
+        request.getArmFilter().ifPresent(v -> path.queryParam("arm", v));
+        request.getIntersectionFilter().ifPresent(v -> path.queryParam("kryssystem", v));
+        request.getSideAreaFilter().ifPresent(v -> path.queryParam("sideanlegg", v));
+        request.getRoadUserGroupFilter().ifPresent(v -> path.queryParam("trafikantgruppe", v.getTextValue()));
+        request.getSeparatePassagesFilter().ifPresent(v -> path.queryParam("adskiltelop", v.getTextValue()));
+        request.getTypeOfRoadFilter().ifPresent(v -> path.queryParam("typeveg", v.getTypeOfRoadSosi()));
+        request.getRefLinkPartTypeFilter().ifPresent(v -> path.queryParam("veglenketype", v.getRefLinkPartType()));
+        request.getDetailLevelFilter().ifPresent(v -> path.queryParam("detaljniva", v.getSosi()));
+        if (!request.getTopologyLevel().isEmpty()) {
+            String topologiniva = request.getTopologyLevel()
+                .stream()
+                .map(TopologyLevel::getApiValue)
+                .collect(Collectors.joining(","));
+            path.queryParam("topologiniva", topologiniva);
+        }
+
+        path.queryParam("historisk", request.isHistory());
+        request.getDateFilter()
+            .ifPresent(v -> path.queryParam("tidspunkt", v.format(DateTimeFormatter.ofPattern("yyyy-MM-dd"))));
+
+        return getClient().target(path);
+    }
+
+    private static String join(List<?> list) {
+        if (list == null) {
+            return null;
+        }
+        return list.stream()
+            .map(Objects::toString)
+            .collect(Collectors.joining(","));
+    }
+
+    private UriBuilder endpoint() {
+        return start().path("vegnett");
+    }
+
+    public static final class SegmentedLinkResult extends GenericResultSet<SegmentedLink> {
+
+        SegmentedLinkResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(SegmentedLinkParser::parse));
+        }
+    }
+
+    public static final class AsyncSegmentedLinkResult extends AsyncResult<SegmentedLink> {
+
+        AsyncSegmentedLinkResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(SegmentedLinkParser::parse));
+        }
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/StatusClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/StatusClient.java
index 3479c8a..6e786a5 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/clients/StatusClient.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/StatusClient.java
@@ -26,18 +26,18 @@
 package no.vegvesen.nvdbapi.client.clients;
 
 import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.clients.util.JerseyHelper;
 import no.vegvesen.nvdbapi.client.gson.StatusParser;
 import no.vegvesen.nvdbapi.client.model.Status;
 
 import javax.ws.rs.client.Client;
 import javax.ws.rs.client.WebTarget;
 import javax.ws.rs.core.UriBuilder;
+import java.util.function.Consumer;
 
 public class StatusClient extends AbstractJerseyClient {
 
-    protected StatusClient(String baseUrl, Client client) {
-        super(baseUrl, client);
+    StatusClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
     }
 
     public Status getStatus() {
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/StreetRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/StreetRequest.java
new file mode 100644
index 0000000..b48bb07
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/StreetRequest.java
@@ -0,0 +1,19 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+public class StreetRequest {
+    private final int pageSize;
+    private final boolean includeObjectLink;
+
+    public StreetRequest(int pageSize, boolean includeObjectLink) {
+        this.pageSize = pageSize;
+        this.includeObjectLink = includeObjectLink;
+    }
+
+    public int getPageSize() {
+        return pageSize;
+    }
+
+    public boolean includeObjectLink() {
+        return includeObjectLink;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/TransactionsClient.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/TransactionsClient.java
new file mode 100644
index 0000000..41d0ec2
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/TransactionsClient.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.clients;
+
+import no.vegvesen.nvdbapi.client.gson.TransactionParser;
+import no.vegvesen.nvdbapi.client.model.Page;
+import no.vegvesen.nvdbapi.client.model.transaction.Transaction;
+
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.UriBuilder;
+
+import java.time.format.DateTimeFormatter;
+import java.util.function.Consumer;
+
+import static java.util.Objects.nonNull;
+import static no.vegvesen.nvdbapi.client.clients.RoadNetClient.join;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.rt;
+
+public class TransactionsClient extends AbstractJerseyClient {
+
+    TransactionsClient(String baseUrl, Client client, Consumer<AbstractJerseyClient> onClose) {
+        super(baseUrl, client, onClose);
+    }
+
+    public TransacionsResult getTransactions() {
+        return getTransactions(TransactionsRequest.DEFAULT);
+    }
+
+    public TransacionsResult getTransactions(TransactionsRequest request) {
+        WebTarget target = setupGetTransactions(request);
+        return new TransacionsResult(target, request.getPage());
+    }
+
+    public AsyncTransacionsResult getTransactionsAsync(TransactionsRequest request) {
+        WebTarget target = setupGetTransactions(request);
+        return new AsyncTransacionsResult(target, request.getPage());
+    }
+
+    private WebTarget setupGetTransactions(TransactionsRequest request) {
+        UriBuilder url = start().path("/transaksjoner");
+
+        if(request.getIder().size() > 0) url.queryParam("ider", join(request.getIder()));
+        if(nonNull(request.getFrom())) url.queryParam("fra", request.getFrom().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
+        if(nonNull(request.getTo())) url.queryParam("til", request.getTo().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
+
+        return getClient().target(url);
+    }
+
+    public static class TransacionsResult extends GenericResultSet<Transaction>{
+        protected TransacionsResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(TransactionParser::parseTransaction));
+        }
+    }
+    public static class AsyncTransacionsResult extends AsyncResult<Transaction>{
+        protected AsyncTransacionsResult(WebTarget baseTarget, Page currentPage) {
+            super(baseTarget, currentPage, rt(TransactionParser::parseTransaction));
+        }
+    }
+
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/clients/TransactionsRequest.java b/src/main/java/no/vegvesen/nvdbapi/client/clients/TransactionsRequest.java
new file mode 100644
index 0000000..2663740
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/clients/TransactionsRequest.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.clients;
+
+import no.vegvesen.nvdbapi.client.model.Page;
+
+import java.time.LocalDateTime;
+import java.util.Collections;
+import java.util.List;
+
+public class TransactionsRequest {
+
+    public static final TransactionsRequest DEFAULT = new TransactionsRequest.Builder().build();
+
+    private final Page page;
+    private final List<Integer> ider;
+    private final LocalDateTime from;
+    private final LocalDateTime to;
+
+    private TransactionsRequest(Builder b){
+        this.page = b.page;
+        this.ider = b.ider;
+        this.from = b.from;
+        this.to = b.to;
+    }
+
+    public static Builder newBuilder() {
+        return new Builder();
+    }
+
+    public Page getPage() {
+        return page;
+    }
+
+    public List<Integer> getIder() {
+        return ider;
+    }
+
+    public LocalDateTime getFrom() {
+        return from;
+    }
+
+    public LocalDateTime getTo() {
+        return to;
+    }
+
+    public static class Builder{
+
+        private Page page = Page.defaults();
+        private List<Integer> ider = Collections.emptyList();
+        private LocalDateTime from = null;
+        private LocalDateTime to = null;
+
+        public TransactionsRequest build() {
+            return new TransactionsRequest(this);
+        }
+
+        public Builder withPage(Page page){
+            this.page = page;
+            return this;
+        }
+
+        public Builder withIder(List<Integer> ider){
+            this.ider = ider;
+            return this;
+        }
+
+        public Builder withFrom(LocalDateTime from){
+            this.from = from;
+            return this;
+        }
+
+        public Builder withTo(LocalDateTime to){
+            this.to = to;
+            return this;
+        }
+    }
+
+
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/exceptions/ClientException.java b/src/main/java/no/vegvesen/nvdbapi/client/exceptions/ClientException.java
index 719ecf4..2c1ea11 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/exceptions/ClientException.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/exceptions/ClientException.java
@@ -29,14 +29,26 @@ import java.util.List;
 import java.util.Objects;
 import java.util.stream.Stream;
 
+import static java.util.Objects.nonNull;
+
 public class ClientException extends RuntimeException {
     private final List<ApiError> errors;
+    private final String requestId;
     private final int statusCode;
 
-    public ClientException(int statusCode, List<ApiError> errors, Throwable cause) {
+    public ClientException(int statusCode, String requestId, List<ApiError> errors, Throwable cause) {
         super(cause);
-        this.statusCode = Objects.requireNonNull(statusCode);
+        this.statusCode = statusCode;
         this.errors = Objects.requireNonNull(errors);
+        this.requestId = requestId;
+    }
+
+    public ClientException(int statusCode, List<ApiError> errors, Throwable cause) {
+        this(statusCode, null, errors, cause);
+    }
+
+    public ClientException(int statusCode, String requestId, List<ApiError> errors) {
+        this(statusCode, requestId, errors, null);
     }
 
     public ClientException(int statusCode, List<ApiError> errors) {
@@ -55,10 +67,33 @@ public class ClientException extends RuntimeException {
         return statusCode;
     }
 
+    public String getRequestId() {
+        return requestId;
+    }
+
+    @Override
+    public String getMessage() {
+        return getErrorsText();
+    }
+
     @Override
     public String toString() {
-        StringBuilder sb = new StringBuilder("HTTP error ").append(statusCode).append(":\n");
-        errors().forEach(e -> sb.append(String.format("Error %d: %s\n", e.getErrorCode(), e.getErrorMessage())));
-        return sb.toString();
+        return getErrorsText();
+    }
+
+    private String getErrorsText() {
+        StringBuilder message = new StringBuilder("HTTP error ").append(statusCode);
+        if (requestId != null) {
+            message
+                .append(" for request ").append(requestId);
+        }
+        message.append(":\n");
+        errors().forEach(e -> message.append(String
+                .format(
+                        "Error %d: %s %s\n",
+                        e.getErrorCode(),
+                        e.getErrorMessage(),
+                        nonNull(e.getErrorMessageDetails()) ? e.getErrorMessageDetails() : "")));
+        return message.toString();
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/exceptions/JsonExceptionParser.java b/src/main/java/no/vegvesen/nvdbapi/client/exceptions/JsonExceptionParser.java
index 51a4e85..8f86c19 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/exceptions/JsonExceptionParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/exceptions/JsonExceptionParser.java
@@ -25,20 +25,19 @@
 
 package no.vegvesen.nvdbapi.client.exceptions;
 
-import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
 
 public final class JsonExceptionParser {
     private static final Logger LOG = LoggerFactory.getLogger(JsonExceptionParser.class);
-    private static final JsonParser parser = new JsonParser();
 
     private JsonExceptionParser() {
     }
@@ -49,22 +48,27 @@ public final class JsonExceptionParser {
     }
 
     public static List<ApiError> parse(String json) {
-        JsonArray errors;
+        if(json.contains("<html>")) {
+            return Collections.singletonList(
+                new ApiError(504,
+                    "Server did not respond correctly",
+                    json, ""));
+        }
         try {
-            errors = parser.parse(json).getAsJsonArray();
+            return StreamSupport.stream(
+                JsonParser.parseString(json).getAsJsonArray().spliterator(), false
+            )
+                .map(n -> new ApiError(
+                    readInt(n, "code"),
+                    readText(n, "message"),
+                    readText(n, "message_detailed"),
+                    readText(n, "help_url")
+                ))
+                .collect(Collectors.toList());
         } catch (Exception ex) {
-            LOG.warn("Could not parse '{}' as json.", json);
-            return Collections.emptyList();
+            LOG.warn("Could not parse '{}' as json (exception: {})", json, ex.getClass().getName());
+            throw ex;
         }
-        List<ApiError> apiErrors = new ArrayList<>();
-        errors.forEach(n -> {
-            Integer errorCode = readInt(n, "code");
-            String message = readText(n, "message");
-            String details = readText(n, "message_detailed");
-            String helpUrl = readText(n, "help_url");
-            apiErrors.add(new ApiError(errorCode, message, details, helpUrl));
-        });
-        return apiErrors;
     }
 
     private static Integer readInt(JsonElement e, String name) {
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/AreaParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/AreaParser.java
index 4fb1f7c..d72b72f 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/AreaParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/AreaParser.java
@@ -29,9 +29,8 @@ import com.google.gson.JsonObject;
 import no.vegvesen.nvdbapi.client.model.Geometry;
 import no.vegvesen.nvdbapi.client.model.areas.*;
 
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseIntMember;
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseLongMember;
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseIntListMember;
 
 public final class AreaParser {
 
@@ -43,11 +42,16 @@ public final class AreaParser {
         Geometry boundingBox = parseGeometry(obj, "kartutsnitt");
         Geometry centerPoint = parseGeometry(obj, "senterpunkt");
 
-        Integer region = parseIntMember(obj, "region");
         Integer county = parseIntMember(obj, "fylke");
-        Integer roadDepartment = parseIntMember(obj, "vegavdeling");
 
-        return new Municipality(parseId(obj), number, name, county, region, boundingBox, centerPoint, roadDepartment);
+        return new Municipality(
+                parseId(obj),
+                number,
+                name,
+                county,
+                boundingBox,
+                centerPoint
+        );
     }
 
     public static County parseCounty(JsonObject obj) {
@@ -56,52 +60,53 @@ public final class AreaParser {
         Geometry boundingBox = parseGeometry(obj, "kartutsnitt");
         Geometry centerPoint = parseGeometry(obj, "senterpunkt");
 
-        Integer region = parseIntMember(obj, "region");
-
-        return new County(parseId(obj), number, name, boundingBox, centerPoint, region);
-    }
-
-    public static Region parseRegion(JsonObject obj) {
-        String name = parseStringMember(obj, "navn");
-        int number = parseIntMember(obj, "nummer");
-        Geometry boundingBox = parseGeometry(obj, "kartutsnitt");
-        Geometry centerPoint = parseGeometry(obj, "senterpunkt");
-
-        return new Region(parseId(obj), number, name, boundingBox, centerPoint);
-    }
-
-    public static RoadDepartment parseDepartment(JsonObject obj) {
-        String name = parseStringMember(obj, "navn");
-        int number = parseIntMember(obj, "nummer");
-
-        return new RoadDepartment(parseId(obj), number, name);
+        return new County(parseId(obj), number, name, boundingBox, centerPoint);
     }
 
     public static Route parseRoute(JsonObject obj) {
-        String name = parseStringMember(obj, "navn");
-        String number = parseStringMember(obj, "nummer");
-        String description = parseStringMember(obj, "beskrivelse");
-        String period = parseStringMember(obj, "periode");
-
-        return new Route(parseId(obj), number, name, description, period);
+        return new Route(
+                parseStringMember(obj, "nummer"),
+                parseStringMember(obj, "navn"),
+                parseStringMember(obj, "beskrivelse"),
+                parseStringMember(obj, "periode"),
+                parseArray(obj, "vegobjekter", AreaParser::parseRoadObjectId),
+                parseIntListMember(obj, "fylker"),
+                parseIntListMember(obj, "kommuner"));
     }
 
     public static ContractArea parseContractArea(JsonObject obj) {
-        String name = parseStringMember(obj, "navn");
-        Integer number = parseIntMember(obj, "nummer");
-        String type = parseStringMember(obj, "type");
+        return new ContractArea(
+                parseIntMember(obj, "nummer"),
+                parseStringMember(obj, "navn"),
+                parseStringMember(obj, "type"),
+                parseArray(obj, "vegobjekter", AreaParser::parseRoadObjectId),
+                parseIntListMember(obj, "fylker"),
+                parseIntListMember(obj, "kommuner")
+        );
+    }
 
-        return new ContractArea(parseId(obj), number, name, type);
+    public static ExtendedStreet parseStreet(JsonObject obj) {
+        return new ExtendedStreet(
+            parseStringMember(obj, "navn"),
+            parseIntMember(obj, "gatekode"),
+            parseBooleanMember(obj, "sideveg"),
+            parseIntMember(obj, "kommune"),
+            parseArray(obj, "vegobjekter", AreaParser::parseRoadObjectId)
+        );
     }
 
     private static RoadObjectId parseId(JsonObject obj) {
-        RoadObjectId id = null;
         if (obj.has("vegobjekt")) {
-            long fid = parseLongMember(obj, "vegobjekt.id");
-            int tid = parseIntMember(obj, "vegobjekt.type");
-            id = new RoadObjectId(tid, fid);
+            return parseRoadObjectId(obj.getAsJsonObject("vegobjekt"));
         }
-        return id;
+        return null;
+    }
+
+    private static RoadObjectId parseRoadObjectId(JsonObject obj) {
+        long fid = parseLongMember(obj, "id");
+        int tid = parseIntMember(obj, "type");
+        Integer version = parseIntMember(obj, "versjon");
+        return new RoadObjectId(tid, fid, version);
     }
 
     private static Geometry parseGeometry(JsonObject obj, String fieldName) {
@@ -110,7 +115,4 @@ public final class AreaParser {
         }
         return GeometryParser.parse(obj.getAsJsonObject(fieldName));
     }
-
-
-
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/AssociationTypeParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/AssociationTypeParser.java
index 56324f2..5f3de32 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/AssociationTypeParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/AssociationTypeParser.java
@@ -40,23 +40,33 @@ public final class AssociationTypeParser {
 
     public static AssociationType parse(JsonObject object) {
 
+        if (object.has("innhold")) {
+            Integer listId = parseIntMember(object, "id");
+            Integer maxNumber = parseIntMember(object, "maksimalt_antall_verdier");
+            Integer minNumber = parseIntMember(object, "minimalt_antall_verdier");
+
+            JsonObject content = object.getAsJsonObject("innhold");
+            return parseAssociation(content, listId, maxNumber, minNumber);
+        } else {
+            return parseAssociation(object, null, null, null);
+        }
+    }
+
+    private static AssociationType parseAssociation(JsonObject object, Integer listId, Integer maxNumber, Integer minNumber) {
         Integer id = parseIntMember(object, "id");
         LocalDate validFrom = parseDateMember(object, "objektliste_dato");
 
         AssociationType.InsideParent insideParent =
                 Optional.ofNullable(parseStringMember(object, "innenfor_mor"))
-                .map(AssociationType.InsideParent::from).orElse(null);
+                    .map(AssociationType.InsideParent::from).orElse(null);
         AssociationType.Affiliation affiliation =
                 Optional.ofNullable(parseStringMember(object, "relasjonstype"))
-                .map(AssociationType.Affiliation::from).orElse(null);
+                    .map(AssociationType.Affiliation::from).orElse(null);
         Integer featureTypeId = null;
         if (object.has("type")) {
             featureTypeId = parseIntMember(object.getAsJsonObject("type"), "id");
         }
 
-
-        return new AssociationType(id, featureTypeId, insideParent, affiliation, validFrom);
+        return new AssociationType(id, featureTypeId, insideParent, affiliation, validFrom, listId, maxNumber, minNumber);
     }
-
-
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/AttributeTypeParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/AttributeTypeParser.java
index f93990d..b76bb67 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/AttributeTypeParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/AttributeTypeParser.java
@@ -26,172 +26,378 @@
 package no.vegvesen.nvdbapi.client.gson;
 
 import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.LocationalType;
 import no.vegvesen.nvdbapi.client.model.SpatialType;
 import no.vegvesen.nvdbapi.client.model.datakatalog.*;
 
 import java.time.LocalDate;
-import java.time.LocalTime;
 import java.util.*;
+import java.util.stream.StreamSupport;
 
+import static java.util.stream.Collectors.toSet;
 import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
 
 public final class AttributeTypeParser {
-    private AttributeTypeParser() {
-    }
-
-    public static AttributeType parse(Map<Integer, DataType> typeMap, JsonObject object) {
-        int typeId = parseIntMember(object, "datatype");
-        boolean isList = parseBooleanMember(object, "liste");
-        DataType type = typeMap.get(Integer.valueOf(typeId));
-
-        Integer id = parseIntMember(object, "id");
-        String name = parseStringMember(object, "navn");
-        String description = parseStringMember(object, "beskrivelse");
-        Integer sortNumber = parseIntMember(object, "sorteringsnummer");
-        String requirementComment = parseStringMember(object, "veiledning");
-        String sosiName = parseStringMember(object, "sosinavn");
-        String sosiNvdbName = parseStringMember(object, "sosinvdbnavn");
-        AttributeType.Importance importance = AttributeType.Importance.from(parseIntMember(object, "viktighet"));
-        Integer sensitivityLevel = parseIntMember(object, "sensitivitet");
-        LocalDate validFrom = parseDateMember(object, "objektliste_dato");
-        AttributeTypeParameters parameters = GuidanceParametersParser.parseAttributeType(object.getAsJsonObject("styringsparametere"));
-
-        AttributeCommonProperties props = new AttributeCommonProperties(id, name, description, type, isList, sortNumber,
-                requirementComment, importance, sosiName, sosiNvdbName, sensitivityLevel, validFrom);
-
-        switch (type.getJavaType()) {
-            case TEXT:
-                Set<EnumValue> values = parseEnumValues(object);
-                Integer fieldLength = parseIntMember(object, "feltlengde");
-                String textDefaultValue = parseStringMember(object, "standardverdi");
-
-                return new StringAttributeType(props, parameters, textDefaultValue, fieldLength, values);
-            case CHARACTER:
-                Character charDefValue = Optional.ofNullable(parseStringMember(object, "standardverdi")).map(s -> s.charAt(0)).orElse(null);
-
-                return new CharacterAttributeType(props, parameters, charDefValue);
-            case BOOLEAN:
-                Boolean boolDefaultValue = parseBooleanMember(object, "standardverdi");
-                return new BooleanAttributeType(props, parameters, boolDefaultValue);
-            case NUMBER:
-                values = parseEnumValues(object);
-                fieldLength = parseIntMember(object, "feltlengde");
-
-                boolean isDouble = false;
-                if (object.has("desimaler")) {
-                    int decimalCount = parseIntMember(object, "desimaler");
-                    isDouble = decimalCount > 0;
-                }
-
-                if (!isDouble) {
-                    Integer intDefValue = parseIntMember(object, "standardverdi");
-                    Integer intMinValue = parseIntMember(object, "min_anbefalt"), intMaxValue = parseIntMember(object, "maks_anbefalt");
-                    Integer intAbsMinValue = parseIntMember(object, "min"), intAbsMaxValue = parseIntMember(object, "maks");
-                    Unit unit = object.has("enhet") ? parseUnit(object.getAsJsonObject("enhet")) : null;
-
-                    return new IntegerAttributeType(props, parameters, intDefValue, intMinValue, intMaxValue, intAbsMinValue,
-                            intAbsMaxValue, fieldLength, unit, values);
-                } else {
-                    values = parseEnumValues(object);
-
-                    fieldLength = parseIntMember(object, "feltlengde");
-                    Integer decimalCount = parseIntMember(object, "desimaler");
-                    Double doubleDefValue = parseDoubleMember(object, "standardverdi");
-                    Double doubleMinValue = parseDoubleMember(object, "min_anbefalt"), doubleMaxValue = parseDoubleMember(object, "maks_anbefalt");
-                    Double doubleAbsMinValue = parseDoubleMember(object, "min"), doubleAbsMaxValue = parseDoubleMember(object, "maks");
-                    Unit unit = object.has("enhet") ? parseUnit(object.getAsJsonObject("enhet")) : null;
-
-                    return new DoubleAttributeType(props, parameters, doubleDefValue, doubleMinValue, doubleMaxValue,
-                            doubleAbsMinValue, doubleAbsMaxValue, fieldLength, decimalCount, unit, values);
-                }
-            case SPATIAL:
-                SpatialType spatialType = determineSpatialType(type);
-
-                return new SpatialAttributeType(props, parameters, spatialType);
-            case LOCAL_DATE:
-                LocalDate defaultDateValue = parseDateMember(object, "standardverdi"), minDateValue = parseDateMember(object, "min");
-                LocalDate maxDateValue = parseDateMember(object, "maks");
-
-                return new DateAttributeType(props, parameters, defaultDateValue, minDateValue, maxDateValue);
-            case SHORT_DATE:
-                Integer intDefValue = parseIntMember(object, "standardverdi");
-                Integer intMinValue = parseIntMember(object, "min_anbefalt");
-                Integer intMaxValue = parseIntMember(object, "maks_anbefalt");
-
-                return new ShortDateAttributeType(props, parameters, intDefValue, intMinValue, intMaxValue);
-            case LOCAL_TIME:
-                LocalTime defaultTimeValue = parseTimeMember(object, "standardverdi");
-                LocalTime minTimeValue = parseTimeMember(object, "min_anbefalt");
-                LocalTime maxTimeValue = parseTimeMember(object, "maks_anbefalt");
-
-                return new TimeAttributeType(props, parameters, defaultTimeValue, minTimeValue, maxTimeValue);
-            case BINARY:
-                return new BinaryObjectAttributeType(props, parameters);
-            case STRUCTURE:
-                return new StructureAttributeType(props, parameters);
+    private AttributeTypeParser() {  }
+
+    public static AttributeType parse(Map<String, DataType> typeMap, JsonObject object) {
+        String egenskapstype = parseStringMember(object, "egenskapstype");
+        switch (egenskapstype) {
+            case "Tekst":
+                return parseStringAttributeType(object, parseCommonProperties(typeMap, object));
+            case "Tekstenum":
+                return parseStringEnumAttributeType(object, parseCommonProperties(typeMap, object));
+            case "Boolsk":
+                return parseBooleanAttributeType(typeMap, object);
+            case "Flyttall":
+                return parseDoubleAttributeType(object, parseCommonProperties(typeMap, object));
+            case "Flyttallenum":
+                return parseDoubleEnumAttributeType(object, parseCommonProperties(typeMap, object));
+            case "Heltall":
+                return parseIntegerAttributeType(object, parseCommonProperties(typeMap, object));
+            case "Heltallenum":
+                return parseIntegerEnumAttributeType(object, parseCommonProperties(typeMap, object));
+            case "Geometri":
+                return parseSpatialAttributeType(typeMap, object);
+            case "Stedfesting":
+                return parseLocationalAttributeType(typeMap, object);
+            case "Dato":
+                return parseDateAttributeType(typeMap, object);
+            case "Kortdato":
+                return parseShortDateAttributeType(typeMap, object);
+            case "Tid":
+                return parseTimeAttributeType(typeMap, object);
+            case "Binær":
+                return parseBinaryObjectAttributeType(typeMap, object);
+            case "Struktur":
+                return new StructureAttributeType(parseCommonProperties(typeMap, object));
+            case "Liste":
+                return parseListAttributeType(typeMap, object);
+            case "Assosiasjon":
+                return parseAssociationRoleType(typeMap, object);
             default:
-                throw new UnsupportedOperationException("Unrecognized data type" + type);
+                throw new UnsupportedOperationException("Unrecognized attribute type" + egenskapstype);
         }
     }
 
-    private static SpatialType determineSpatialType(DataType dataType) {
-        switch (dataType.getId()) {
-            case 17:
+    private static AssociationRoleType parseAssociationRoleType(Map<String, DataType> typeMap, JsonObject object) {
+        return new AssociationRoleType(
+            parseCommonProperties(typeMap, object),
+            parseIntMember(object, "tilknytning"),
+            parseIntMember(object, "vegobjekttypeid"),
+            parseIntMember(object, "innenfor_mor"),
+            parseDateMember(object, "startdato"),
+            parseDateMember(object, "sluttdato"),
+            parseIntMember(object, "assosiasjonskrav"),
+            parseStringMember(object, "assosiasjonskravkommentar"));
+    }
+
+    private static ListAttributeType parseListAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new ListAttributeType(
+            parseCommonProperties(typeMap, object),
+            parse(typeMap, object.getAsJsonObject("innhold")),
+            parseIntMember(object, "maksimalt_antall_verdier"),
+            parseIntMember(object, "minimalt_antall_verdier"));
+    }
+
+    private static BinaryObjectAttributeType parseBinaryObjectAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new BinaryObjectAttributeType(
+            parseCommonProperties(typeMap, object),
+            parseStringMember(object, "mediatype"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static TimeAttributeType parseTimeAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new TimeAttributeType(
+            parseCommonProperties(typeMap, object),
+            parseTimeMember(object, "standardverdi"),
+            parseTimeMember(object, "min_anbefalt"),
+            parseTimeMember(object, "maks_anbefalt"),
+            parseStringMember(object, "format"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static ShortDateAttributeType parseShortDateAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new ShortDateAttributeType(
+            parseCommonProperties(typeMap, object),
+            parseIntMember(object, "standardverdi"),
+            parseIntMember(object, "min_anbefalt"),
+            parseIntMember(object, "maks_anbefalt"),
+            parseStringMember(object, "format"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static DateAttributeType parseDateAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new DateAttributeType(
+            parseCommonProperties(typeMap, object),
+            parseDateMember(object, "standardverdi"),
+            parseDateMember(object, "min"),
+            parseDateMember(object, "maks"),
+            parseStringMember(object, "format"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static LocationalAttributeType parseLocationalAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new LocationalAttributeType(
+            parseCommonProperties(typeMap, object),
+            determineLocationalType(object),
+            parseBooleanMember(object, "overlapp_ok"),
+            parseStringMember(object, "kjørefelt_relevant"),
+            parseStringMember(object, "sideposisjon_relevant"),
+            parseStringMember(object, "ajourhold_i"),
+            parseStringMember(object, "ajourhold_splitt"),
+            parseBooleanMember(object, "innenfor_mor"),
+            parseStringMember(object, "overlappsautomatikk"),
+            parseBooleanMember(object, "retning_relevant"));
+    }
+
+    private static SpatialAttributeType parseSpatialAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new SpatialAttributeType(
+            parseCommonProperties(typeMap, object),
+            determineSpatialType(object),
+            parseIntMember(object, "dimensjoner"),
+            parseBooleanMember(object, "innenfor_mor"));
+    }
+
+    private static BooleanAttributeType parseBooleanAttributeType(Map<String, DataType> typeMap, JsonObject object) {
+        return new BooleanAttributeType(
+            parseCommonProperties(typeMap, object),
+            parseBooleanMember(object, "standardverdi"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static AttributeCommonProperties parseCommonProperties(Map<String, DataType> typeMap, JsonObject object) {
+        return new AttributeCommonProperties(
+            parseIntMember(object, "id"),
+            parseIntMember(object, "kategori"),
+            parseStringMember(object, "navn"),
+            parseStringMember(object, "kortnavn"),
+            parseStringMember(object, "beskrivelse"),
+            typeMap.get(parseStringMember(object, "datatype")),
+            parseIntMember(object, "sorteringsnummer"),
+            parseStringMember(object, "veiledning"),
+            AttributeType.Importance.from(parseStringMember(object, "viktighet")),
+            parseStringMember(object, "sosinavn"),
+            parseStringMember(object, "sosinvdbnavn"),
+            parseIntMember(object, "sensitivitet"),
+            parseDateMember(object, "objektliste_dato"),
+            parseDateMember(object, "slutt_dato"),
+            parseBooleanMember(object, "skrivebeskyttet"),
+            parseStringMember(object, "ledetekst"),
+            parseIntMember(object, "komplementær_egenskapstype"),
+            parseStringMember(object, "grunnrissreferanse"),
+            parseStringMember(object, "høydereferanse"),
+            parseStringMember(object, "sosi_referanse"),
+            parseBooleanMember(object, "referansegeometri_tilstrekkelig"),
+            parseIntMember(object, "høydereferanse_tall"),
+            parseDoubleMember(object, "nøyaktighetskrav_grunnriss"),
+            parseDoubleMember(object, "nøyaktighetskrav_høyde"),
+            parseStringListMember(object, "tilleggskrav"),
+            parseBooleanMember(object, "avledet"),
+            parseBooleanMember(object, "obligatorisk_verdi"));
+    }
+
+    private static DoubleAttributeType parseDoubleAttributeType(JsonObject object, AttributeCommonProperties props) {
+        return new DoubleAttributeType(
+            props,
+            parseDoubleMember(object, "standardverdi"),
+            parseDoubleMember(object, "min_anbefalt"),
+            parseDoubleMember(object, "maks_anbefalt"),
+            parseDoubleMember(object, "min"),
+            parseDoubleMember(object, "maks"),
+            parseIntMember(object, "feltlengde"),
+            parseIntMember(object, "desimaler"),
+            parseUnit(object.getAsJsonObject("enhet")),
+            parseBooleanMember(object, "fortegnsendring_snu"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static DoubleEnumAttributeType parseDoubleEnumAttributeType(JsonObject object, AttributeCommonProperties props) {
+        return new DoubleEnumAttributeType(
+            props,
+            parseDoubleMember(object, "standardverdi"),
+            parseDoubleMember(object, "min_anbefalt"),
+            parseDoubleMember(object, "maks_anbefalt"),
+            parseDoubleMember(object, "min"),
+            parseDoubleMember(object, "maks"),
+            parseIntMember(object, "feltlengde"),
+            parseIntMember(object, "desimaler"),
+            parseUnit(object.getAsJsonObject("enhet")),
+            parseEnumValues(object),
+            parseBooleanMember(object, "fortegnsendring_snu"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static AttributeType parseIntegerAttributeType(JsonObject object, AttributeCommonProperties props) {
+        return new IntegerAttributeType(
+            props,
+            parseIntMember(object, "standardverdi"),
+            parseIntMember(object, "min_anbefalt"),
+            parseIntMember(object, "maks_anbefalt"),
+            parseIntMember(object, "min"),
+            parseIntMember(object, "maks"),
+            parseIntMember(object, "feltlengde"),
+            parseUnit(object.getAsJsonObject("enhet")),
+            parseBooleanMember(object, "fortegnsendring_snu"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static IntegerEnumAttributeType parseIntegerEnumAttributeType(JsonObject object, AttributeCommonProperties props) {
+        return new IntegerEnumAttributeType(
+            props,
+            parseIntMember(object, "standardverdi"),
+            parseIntMember(object, "min_anbefalt"),
+            parseIntMember(object, "maks_anbefalt"),
+            parseIntMember(object, "min"),
+            parseIntMember(object, "maks"),
+            parseIntMember(object, "feltlengde"),
+            parseUnit(object.getAsJsonObject("enhet")),
+            parseEnumValues(object),
+            parseBooleanMember(object, "fortegnsendring_snu"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static StringAttributeType parseStringAttributeType(JsonObject object, AttributeCommonProperties props) {
+        return new StringAttributeType(
+            props,
+            parseStringMember(object, "standardverdi"),
+            parseIntMember(object, "feltlengde"),
+            parseStringMember(object, "format"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static StringEnumAttributeType parseStringEnumAttributeType(JsonObject object, AttributeCommonProperties props) {
+        return new StringEnumAttributeType(
+            props,
+            parseStringMember(object, "standardverdi"),
+            parseIntMember(object, "feltlengde"),
+            parseEnumValues(object),
+            parseStringMember(object, "format"),
+            parseBooleanMember(object, "ajourhold_snu"),
+            parseBooleanMember(object, "lengdeavhengig_verdi"));
+    }
+
+    private static SpatialType determineSpatialType(JsonObject object) {
+        String type = parseStringMember(object, "geometritype");
+        switch (type) {
+            case "PUNKT":
                 return SpatialType.POINT;
-            case 18:
+            case "LINJE":
                 return SpatialType.LINE_STRING;
-            case 19:
+            case "POLYGON":
                 return SpatialType.POLYGON;
-            case 20:
+            case "KOMPLEKS":
                 return SpatialType.COMPLEX;
-            case 21:
+            case "FLEREPUNKT":
                 return SpatialType.MULTI_POINT;
-            case 22:
+            case "FLERELINJE":
                 return SpatialType.MULTI_LINE_STRING;
-            case 23:
+            case "FLEREPOLYGON":
                 return SpatialType.MULTI_POLYGON;
             default:
                 return SpatialType.UNKNOWN;
         }
     }
 
-    private static Set<EnumValue> parseEnumValues(JsonObject obj) {
+    private static LocationalType determineLocationalType(JsonObject object){
+        String type = parseStringMember(object, "geometritype");
+        switch (type){
+            case "LINJE":
+                return LocationalType.LINE;
+            case "PUNKT":
+                return LocationalType.POINT;
+            default:
+                return LocationalType.UNKNOWN;
+        }
+    }
+
+    private static <T extends EnumValue> Set<T> parseEnumValues(JsonObject obj) {
         if (!obj.has("tillatte_verdier")) {
             return Collections.emptySet();
         }
-        Set<EnumValue> values = new HashSet<>();
-        JsonArray array = obj.get("tillatte_verdier").getAsJsonArray();
-        array.forEach(e -> {
-            JsonObject object = e.getAsJsonObject();
 
-            Integer id = parseIntMember(object, "id");
-            String shortValue = parseStringMember(object, "kortnavn");
-            String value = parseStringMember(object, "navn");
-            String description = parseStringMember(object, "beskrivelse");
-            Integer sortNumber = parseIntMember(object, "sorteringsnummer");
-            LocalDate objectListDate = parseDateMember(object, "objektliste_dato");
+        JsonArray array = obj.get("tillatte_verdier").getAsJsonArray();
+        return StreamSupport.stream(array.spliterator(), false)
+            .map(JsonElement::getAsJsonObject)
+            .map(allowedValue ->
+                AttributeTypeParser.<T>createEnumValue(
+                    allowedValue,
+                    parseStringMember(allowedValue, "type"),
+                    parseIntMember(allowedValue, "id"),
+                    parseIntMember(allowedValue, "sorteringsnummer"),
+                    parseStringMember(allowedValue, "kortnavn"),
+                    parseStringMember(allowedValue, "beskrivelse"),
+                    parseDateMember(allowedValue, "objektliste_dato")
+                ))
+            .collect(toSet());
+    }
 
-            values.add(new EnumValue(id, sortNumber, value, shortValue, description, objectListDate));
-        });
-        return values;
+    @SuppressWarnings("unchecked")
+    private static <T extends EnumValue> T createEnumValue(JsonObject obj,
+                                                           String type,
+                                                           Integer id,
+                                                           Integer sortNumber,
+                                                           String shortValue,
+                                                           String description,
+                                                           LocalDate objectListDate) {
+        switch (type) {
+            case "Tekst":
+                return (T) new StringEnumValue(id,
+                    sortNumber, parseStringMember(obj, "verdi"),
+                    shortValue, description, objectListDate,
+                    parseBooleanMember(obj, "standardverdi"),
+                    parseBooleanMember(obj, "kortnavn_brukbar"),
+                    parseIntMember(obj, "kortnavnlengde"),
+                    parseIntMember(obj, "komplementær_enumverdi"));
+            case "Heltall":
+                return (T) new IntegerEnumValue(id,
+                    sortNumber, parseIntMember(obj, "verdi"),
+                    shortValue, description, objectListDate,
+                    parseBooleanMember(obj, "standardverdi"),
+                    parseBooleanMember(obj, "kortnavn_brukbar"),
+                    parseIntMember(obj, "kortnavnlengde"),
+                    parseIntMember(obj, "komplementær_enumverdi"));
+            case "Flyttall":
+                return (T) new DoubleEnumValue(id,
+                    sortNumber, parseDoubleMember(obj, "verdi"),
+                    shortValue, description, objectListDate,
+                    parseBooleanMember(obj, "standardverdi"),
+                    parseBooleanMember(obj, "kortnavn_brukbar"),
+                    parseIntMember(obj, "kortnavnlengde"),
+                    parseIntMember(obj, "komplementær_enumverdi"));
+            default:
+                throw new IllegalArgumentException("Could not handle enum value of type " + type);
+        }
     }
 
     public static Unit parseUnit(JsonObject obj) {
-        Integer id = parseIntMember(obj, "id");
-        String name = parseStringMember(obj, "navn");
-        String shortName = parseStringMember(obj, "kortnavn");
-
-        return new Unit(id, name, shortName);
+        if(obj == null) return null;
+        return new Unit(
+            parseIntMember(obj, "id"),
+            parseStringMember(obj, "navn"),
+            parseStringMember(obj, "kortnavn"));
     }
 
     public static DataType parseDataType(JsonObject obj) {
-        Integer id = parseIntMember(obj, "id");
-        String name = parseStringMember(obj, "navn");
-        String shortName = parseStringMember(obj, "kortnavn");
-        String description = parseStringMember(obj, "beskrivelse");
 
-        return new DataType(id, name, shortName, description, determineActualType(id));
+        return new DataType(
+            parseIntMember(obj, "id"),
+            parseStringMember(obj, "navn"),
+            parseStringMember(obj, "kortnavn"),
+            parseStringMember(obj, "beskrivelse"),
+            determineActualType(parseIntMember(obj, "id")));
     }
 
     private static JavaType determineActualType(int typeId) {
@@ -216,7 +422,7 @@ public final class AttributeTypeParser {
             case 21:
             case 22:
             case 23:
-                return JavaType.SPATIAL;
+                return JavaType.GEOMETRY;
             case 26:
                 return JavaType.STRUCTURE;
             case 28:
@@ -230,8 +436,22 @@ public final class AttributeTypeParser {
             case 36:
             case 37:
                 return JavaType.BINARY;
+            case 38:
+                return JavaType.LIST;
+            case 39:
+                return JavaType.ASSOCIATION;
             default:
                 return JavaType.UNKNOWN;
         }
     }
+
+
+    public static AttributeTypeCategory parseCategory(JsonObject obj) {
+        return new AttributeTypeCategory(
+            parseIntMember(obj, "id"),
+            parseStringMember(obj, "navn"),
+            parseStringMember(obj, "kortnavn"),
+            parseStringMember(obj, "beskrivelse"),
+            parseIntMember(obj, "sorteringsnummer"));
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/util/ArgUtil.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/BriefRouteSegmentParser.java
similarity index 61%
rename from src/main/java/no/vegvesen/nvdbapi/client/util/ArgUtil.java
rename to src/main/java/no/vegvesen/nvdbapi/client/gson/BriefRouteSegmentParser.java
index ec0e59d..ca0d80b 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/util/ArgUtil.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/BriefRouteSegmentParser.java
@@ -23,30 +23,25 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.vegvesen.nvdbapi.client.util;
+package no.vegvesen.nvdbapi.client.gson;
 
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.time.ZonedDateTime;
-import java.time.format.DateTimeFormatter;
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.roadnet.route.BriefRouteSegment;
 
-public final class ArgUtil {
-    private static final DateTimeFormatter dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE;
-    private static final DateTimeFormatter timestampFormatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
-    private static final DateTimeFormatter zonelessTimestampFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
 
-    private ArgUtil() {
-    }
+public final class BriefRouteSegmentParser {
 
-    public static String date(LocalDate date) {
-        return dateFormatter.format(date);
+    private BriefRouteSegmentParser() {
     }
 
-    public static String date(ZonedDateTime date) {
-        return timestampFormatter.format(date);
+    public static BriefRouteSegment parse(JsonObject obj) {
+        return new BriefRouteSegment(
+                parseLongMember(obj, "veglenkesekvensid"),
+                parseDoubleMember(obj, "startposisjon"),
+                parseDoubleMember(obj, "sluttposisjon"),
+                parseStringMember(obj, "kortform"),
+                parseStringMember(obj, "type"));
     }
 
-    public static String date(LocalDateTime date) {
-        return zonelessTimestampFormatter.format(date);
-    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/ChangesParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/ChangesParser.java
index f94bec2..e89706b 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/ChangesParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/ChangesParser.java
@@ -27,19 +27,17 @@ package no.vegvesen.nvdbapi.client.gson;
 
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
+
 import no.vegvesen.nvdbapi.client.model.Change;
-import no.vegvesen.nvdbapi.client.model.datakatalog.DataType;
 import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObject;
 
-import java.util.Map;
-
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringMember;
 
 public class ChangesParser {
     private ChangesParser() {
     }
 
-    public static Change parse(Map<Integer, DataType> dataTypes, JsonObject obj, int typeId) {
+    public static Change parse(JsonObject obj, int typeId) {
 
         Change.Type type = Change.Type.from(parseStringMember(obj, "type"));
 
@@ -49,7 +47,7 @@ public class ChangesParser {
         if (e.isJsonPrimitive()) {
             featureId = e.getAsLong();
         } else {
-            roadObject = RoadObjectParser.parse(dataTypes, obj.getAsJsonObject("vegobjekt"));
+            roadObject = RoadObjectParser.parse(obj.getAsJsonObject("vegobjekt"));
             featureId = roadObject.getId();
         }
 
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/DetailedRouteSegmentParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/DetailedRouteSegmentParser.java
new file mode 100644
index 0000000..dfb7aef
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/DetailedRouteSegmentParser.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.gson;
+
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.roadnet.*;
+import no.vegvesen.nvdbapi.client.model.roadnet.route.DetailedRouteSegment;
+import no.vegvesen.nvdbapi.client.model.roadnet.route.RouteOnRoadNet;
+
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
+import static no.vegvesen.nvdbapi.client.gson.RoadObjectParser.parseContractAreas;
+import static no.vegvesen.nvdbapi.client.gson.RoadObjectParser.parseRoutes;
+
+public final class DetailedRouteSegmentParser  {
+
+    private DetailedRouteSegmentParser() {
+    }
+
+    public static DetailedRouteSegment parse(JsonObject obj) {
+        return new DetailedRouteSegment(
+                parseLongMember(obj, "veglenkesekvensid"),
+                parseLongMember(obj, "superstedfesting.veglenkesekvensid"),
+                parseDoubleMember(obj, "startposisjon"),
+                parseDoubleMember(obj, "sluttposisjon"),
+                parseIntMember(obj, "veglenkenummer"),
+                DetailLevel.fromTextValue(parseStringMember(obj, "detaljnivå")),
+                TypeOfRoad.fromTextValue(parseStringMember(obj, "typeVeg")),
+                parseStringMember(obj, "startnode"),
+                parseStringMember(obj, "sluttnode"),
+                parseDateMember(obj, "metadata.startdato"),
+                parseDateMember(obj, "metadata.sluttdato"),
+                parseIntMember(obj, "fylke"),
+                parseIntMember(obj, "kommune"),
+                GsonUtil.parseGeometryMember(obj, "geometri"),
+                parseDoubleMember(obj, "lengde"),
+                GsonUtil.parseRoadSysRefMember(obj, "vegsystemreferanse"),
+                RefLinkPartType.fromValue(parseStringMember(obj,"type")),
+                parseContractAreas(obj),
+                parseRoutes(obj));
+    }
+
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/FeatureTypeParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/FeatureTypeParser.java
index 5a36ab3..386a3d2 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/FeatureTypeParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/FeatureTypeParser.java
@@ -25,12 +25,9 @@
 
 package no.vegvesen.nvdbapi.client.gson;
 
-import com.google.gson.JsonArray;
 import com.google.gson.JsonObject;
 import no.vegvesen.nvdbapi.client.model.datakatalog.*;
 
-import java.time.LocalDate;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
@@ -40,51 +37,65 @@ public final class FeatureTypeParser {
     private FeatureTypeParser() {
     }
 
-    public static FeatureType parse(Map<Integer, DataType> dataTypes, JsonObject obj) {
-        Integer id = parseIntMember(obj, "id");
-        String name = parseStringMember(obj, "navn");
-        String description = parseStringMember(obj, "beskrivelse");
-        String instructions = parseStringMember(obj, "veiledning");
-        String sosiName = parseStringMember(obj, "sosinavn");
-        String sosiNvdbName = parseStringMember(obj, "sosinvdbnavn");
-        Integer sortNumber = parseIntMember(obj, "sorteringsnummer");
-        LocalDate objectListDate = parseDateMember(obj, "objektliste_dato");
-
-
-        List<AttributeType> attributeTypes = new ArrayList<>();
-        if (obj.has("egenskapstyper")) {
-            JsonArray attributeTypeArray = obj.getAsJsonArray("egenskapstyper");
-            attributeTypeArray.forEach(e -> attributeTypes.add(AttributeTypeParser.parse(dataTypes, e.getAsJsonObject())));
-        }
+    public static FeatureType parse(Map<String, DataType> dataTypes, JsonObject obj) {
+        return new FeatureType(
+            parseIntMember(obj, "id"),
+            parseStringMember(obj, "navn"),
+            parseStringMember(obj, "kortnavn"),
+            parseStringMember(obj, "beskrivelse"),
+            parseAttributeTypes(dataTypes, obj),
+            getAssociations(obj, "relasjonstyper.foreldre"),
+            getAssociations(obj, "relasjonstyper.barn"),
+            parseStringMember(obj, "veiledning"),
+            parseStringMember(obj, "sosinavn"),
+            parseStringMember(obj, "sosinvdbnavn"),
+            parseIntMember(obj, "sorteringsnummer"),
+            parseDateMember(obj, "objektliste_dato"),
+            parsePlacementType(obj),
+            parseLocationalAttribute(dataTypes, obj),
+            parseStringMember(obj, "status"),
+            parseStringMember(obj, "hovedkategori"),
+            parseBooleanMember(obj, "en_versjon"),
+            parseBooleanMember(obj, "abstrakt_type"),
+            parseBooleanMember(obj, "avledet"),
+            parseBooleanMember(obj, "må_ha_mor"),
+            parseBooleanMember(obj, "er_dataserie"),
+            parseBooleanMember(obj, "konnekteringslenke_ok"),
+            parseStringMember(obj, "tilleggsinformasjon"),
+            parseBooleanMember(obj, "sensitiv"));
+    }
 
-        List<AssociationType> parents = new ArrayList<>(), children = new ArrayList<>();
-        JsonArray childrenArray = getArray(obj, "relasjonstyper.barn").orElse(null);
-        if (childrenArray != null) {
-            childrenArray.forEach(e -> children.add(AssociationTypeParser.parse(e.getAsJsonObject())));
-        }
-        JsonArray parentsArray = getArray(obj, "relasjonstyper.foreldre").orElse(null);
-        if (parentsArray != null) {
-            parentsArray.forEach(e -> parents.add(AssociationTypeParser.parse(e.getAsJsonObject())));
+    private static AttributeType parseLocationalAttribute(Map<String, DataType> dataTypes, JsonObject obj) {
+        if(obj.has("stedfesting")){
+            return AttributeTypeParser.parse(dataTypes, obj.getAsJsonObject("stedfesting"));
+        } else {
+            return null;
         }
+    }
 
-        FeatureType.PlacementType placementType = FeatureType.PlacementType.from(parseStringMember(obj, "stedfesting"));
+    private static FeatureType.PlacementType parsePlacementType(JsonObject obj) {
+        JsonObject stedfesting = obj.getAsJsonObject("stedfesting");
+        if(stedfesting == null) return null;
+        JsonObject stedfestingObj = stedfesting.has("innhold") ? stedfesting.getAsJsonObject("innhold") : stedfesting;
+        return FeatureType.PlacementType.from(parseStringMember(stedfestingObj, "stedfestingstype"));
+    }
 
-        FeatureTypeParameters parameters = null;
-        if (obj.has("styringsparametere")) {
-            parameters = GuidanceParametersParser.parseFeatureType(obj.getAsJsonObject("styringsparametere"));
-        }
+    private static List<AssociationType> getAssociations(JsonObject obj, String path) {
+        return parseArray(obj, path, AssociationTypeParser::parse);
+    }
 
-        return new FeatureType(id, name, description, attributeTypes, parents, children, instructions, sosiName, sosiNvdbName, sortNumber, objectListDate, placementType, parameters);
+    private static List<AttributeType> parseAttributeTypes(Map<String, DataType> dataTypes, JsonObject obj) {
+        return parseArray(obj, "egenskapstyper", e -> AttributeTypeParser.parse(dataTypes, e));
     }
 
     public static FeatureTypeCategory parseCategory(JsonObject obj) {
-        Integer id = parseIntMember(obj, "id");
-        String name = parseStringMember(obj, "navn");
-        String shortName = parseStringMember(obj, "kortnavn");
-        String description = parseStringMember(obj, "beskrivelse");
-        Integer sortNumber = parseIntMember(obj, "sorteringsnummer");
-        LocalDate validFrom = parseDateMember(obj, "startdato");
-
-        return new FeatureTypeCategory(id, name, shortName, description, sortNumber, validFrom);
+        return new FeatureTypeCategory(
+            parseIntMember(obj, "id"),
+            parseStringMember(obj, "navn"),
+            parseStringMember(obj, "kortnavn"),
+            parseStringMember(obj, "beskrivelse"),
+            parseIntMember(obj, "sorteringsnummer"),
+            parseDateMember(obj, "startdato"),
+            parseBooleanMember(obj, "primærkategori"));
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/GeometryParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/GeometryParser.java
index 30856dc..4fee8cf 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/GeometryParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/GeometryParser.java
@@ -28,17 +28,16 @@ package no.vegvesen.nvdbapi.client.gson;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.GeometryAttributes;
 import no.vegvesen.nvdbapi.client.model.Projection;
 import no.vegvesen.nvdbapi.client.model.Quality;
 
-import java.time.LocalDate;
 import java.util.Optional;
 
 import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
 
 public final class GeometryParser {
-    private GeometryParser() {
-    }
+    private GeometryParser() {}
 
     public static Geometry parse(JsonObject obj) {
         if (obj==null) return null;
@@ -49,28 +48,54 @@ public final class GeometryParser {
         boolean isSimplified = Optional.ofNullable(parseBooleanMember(obj, "forenklet")).orElse(false);
         boolean isOwnGeometry = Optional.ofNullable(parseBooleanMember(obj, "egengeometri")).orElse(false);
 
-        Quality quality = null;
-        if (obj.has("kvalitet")) {
-            quality = parseQuality(obj.getAsJsonObject("kvalitet"));
-        }
+        GeometryAttributes geometryAttributes = getGeometryAttributes(obj);
 
-        return new Geometry(wkt, srid, quality, isSimplified, isOwnGeometry);
+        return new Geometry(wkt, srid, isSimplified, isOwnGeometry, geometryAttributes);
     }
 
-    public static Quality parseQuality(JsonObject qualityObj) {
-        Integer method = parseIntMember(qualityObj, "målemetode");
-        Integer accuracy = parseIntMember(qualityObj, "nøyaktighet");
-        Integer heightMethod = parseIntMember(qualityObj, "målemetodeHøyde");
-        Integer heightAccuracy = parseIntMember(qualityObj, "nøyaktighetHøyde");
-        Integer tolerance = parseIntMember(qualityObj, "toleranse");
-        Integer visibility = parseIntMember(qualityObj, "synbarhet");
-        LocalDate verifiedDate = parseDateMember(qualityObj, "datafangstdato");
-
-        Quality quality = new Quality(method, accuracy, heightMethod, heightAccuracy, tolerance, visibility, verifiedDate);
-        return quality;
+    private static GeometryAttributes getGeometryAttributes(JsonObject obj) {
+        return new GeometryAttributes(
+            parseDateMember(obj, "datafangstdato"),
+            parseDateMember(obj, "verifiseringsdato"),
+            parseDateMember(obj, "oppdateringsdato"),
+            parseStringMember(obj, "prosesshistorikk"),
+            parseIntMember(obj, "kommune"),
+            parseStringMember(obj, "medium"),
+            parseStringMember(obj, "sosinavn"),
+            parseIntMember(obj, "temakode"),
+            parseBooleanMember(obj, "referansegeometri"),
+            parseDoubleMember(obj, "lengde"),
+            parseIntMember(obj, "høydereferanse"),
+            getQuality(obj)
+        );
+    }
+
+    public static Geometry parseAttribute(JsonObject obj) {
+        if (obj==null) return null;
+
+        String wkt = parseStringMember(obj, "verdi");
+        Projection srid = Projection.UTM33;
+
+        GeometryAttributes geometryAttributes = getGeometryAttributes(obj);
+
+        return new Geometry(wkt, srid, false, true, geometryAttributes);
+    }
+
+    private static Quality getQuality(JsonObject obj) {
+        if (obj.has("kvalitet")) {
+            Integer method = parseIntMember(obj, "kvalitet.målemetode");
+            Integer accuracy = parseIntMember(obj, "kvalitet.nøyaktighet");
+            Integer heightMethod = parseIntMember(obj, "kvalitet.målemetodeHøyde");
+            Integer heightAccuracy = parseIntMember(obj, "kvalitet.nøyaktighetHøyde");
+            Integer tolerance = parseIntMember(obj, "kvalitet.maksimaltAvvik");
+            Integer visibility = parseIntMember(obj, "kvalitet.synbarhet");
+            return new Quality(method, accuracy, heightMethod, heightAccuracy, tolerance, visibility);
+        } else {
+            return null;
+        }
     }
 
-    static Projection parseProjection(JsonElement e) {
+    private static Projection parseProjection(JsonElement e) {
         return Projection.of(e.getAsInt()).orElse(null);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonMessageBodyHandler.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonMessageBodyHandler.java
index 0fb691a..5e9e9f0 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonMessageBodyHandler.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonMessageBodyHandler.java
@@ -32,7 +32,6 @@ import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
-
 import javax.ws.rs.Consumes;
 import javax.ws.rs.Produces;
 import javax.ws.rs.WebApplicationException;
@@ -45,14 +44,14 @@ import javax.ws.rs.ext.Provider;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 @Provider
 @Produces(MediaType.APPLICATION_JSON)
 @Consumes(MediaType.APPLICATION_JSON)
 public class GsonMessageBodyHandler implements MessageBodyWriter<Object>,
         MessageBodyReader<Object> {
 
-    private static final String UTF_8 = "UTF-8";
-
     private Gson gson;
 
     private Gson getGson() {
@@ -73,17 +72,15 @@ public class GsonMessageBodyHandler implements MessageBodyWriter<Object>,
     public Object readFrom(Class<Object> type, Type type1, Annotation[] antns,
                            MediaType mt, MultivaluedMap<String, String> mm, InputStream in)
             throws IOException, WebApplicationException {
-        InputStreamReader streamReader = new InputStreamReader(in, UTF_8);
-        try {
+        try (InputStreamReader streamReader = new InputStreamReader(in, UTF_8)) {
             Type jsonType;
             if (type.equals(type1)) {
                 jsonType = type;
-            } else {
+            }
+            else {
                 jsonType = type1;
             }
             return getGson().fromJson(streamReader, jsonType);
-        } finally {
-            streamReader.close();
         }
     }
 
@@ -104,17 +101,15 @@ public class GsonMessageBodyHandler implements MessageBodyWriter<Object>,
                         Annotation[] annotations, MediaType mediaType,
                         MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)
             throws IOException, WebApplicationException {
-        OutputStreamWriter writer = new OutputStreamWriter(entityStream, UTF_8);
-        try {
+        try (OutputStreamWriter writer = new OutputStreamWriter(entityStream, UTF_8)) {
             Type jsonType;
             if (type.equals(genericType)) {
                 jsonType = type;
-            } else {
+            }
+            else {
                 jsonType = genericType;
             }
             getGson().toJson(object, jsonType, writer);
-        } finally {
-            writer.close();
         }
     }
 
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonUtil.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonUtil.java
index 72225f7..0ccaac6 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonUtil.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/GsonUtil.java
@@ -25,32 +25,35 @@
 
 package no.vegvesen.nvdbapi.client.gson;
 
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonPrimitive;
-import no.vegvesen.nvdbapi.client.model.Quality;
-import no.vegvesen.nvdbapi.client.model.datakatalog.JavaType;
-import no.vegvesen.nvdbapi.client.util.Strings;
-
 import java.time.LocalDate;
 import java.time.LocalDateTime;
 import java.time.LocalTime;
 import java.time.format.DateTimeFormatter;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
 
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+
+import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.datakatalog.JavaType;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
+import no.vegvesen.nvdbapi.client.util.Strings;
+
+import static java.util.stream.Collectors.toList;
+
 public final class GsonUtil {
 
     private static final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss");
     private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
 
-    private GsonUtil() {
-    }
+    private GsonUtil() {}
 
     public static boolean hasNonBlankMember(JsonObject obj, String memberName) {
         return obj.has(memberName) && !Strings.isNullOrEmpty(obj.get(memberName).getAsString());
@@ -65,18 +68,12 @@ public final class GsonUtil {
     }
 
     public static Integer parseIntMember(JsonObject obj, String path) {
-        Optional<JsonPrimitive> e = getNode(obj, path).map(JsonElement::getAsJsonPrimitive);
-        if (e.isPresent() && !e.get().isNumber()) {
-            throw new IllegalArgumentException(path + " did not contain a number.");
-        }
+        Optional<JsonPrimitive> e = parseNodeToJsonPrimitive(obj, path);
         return e.map(JsonElement::getAsInt).orElse(null);
     }
 
     public static Long parseLongMember(JsonObject obj, String path) {
-        Optional<JsonPrimitive> e = getNode(obj, path).map(JsonElement::getAsJsonPrimitive);
-        if (e.isPresent() && !e.get().isNumber()) {
-            throw new IllegalArgumentException(path + " did not contain a number.");
-        }
+        Optional<JsonPrimitive> e = parseNodeToJsonPrimitive(obj, path);
         return e.map(JsonElement::getAsLong).orElse(null);
     }
 
@@ -88,6 +85,13 @@ public final class GsonUtil {
         return e.map(JsonElement::getAsString).orElse(null);
     }
 
+    public static Optional<String> parseOptionalStringMember(JsonObject obj, String path) {
+        return getNode(obj, path)
+            .map(JsonElement::getAsJsonPrimitive)
+            .filter(JsonPrimitive::isString)
+            .map(JsonElement::getAsString);
+    }
+
     public static Boolean parseBooleanMember(JsonObject obj, String path) {
         Optional<JsonPrimitive> e = getNode(obj, path).map(JsonElement::getAsJsonPrimitive);
         if (e.isPresent() && !e.get().isBoolean()) {
@@ -98,8 +102,8 @@ public final class GsonUtil {
 
     public static LocalDateTime parseDateTimeMember(JsonObject obj, String path) {
         return Optional.ofNullable(parseStringMember(obj, path))
-                .map(v -> v.contains("T") ? LocalDateTime.parse(v) : dateTimeFormatter.parse(v, LocalDateTime::from))
-                .orElse(null);
+            .map(v -> v.contains("T") ? LocalDateTime.parse(v) : dateTimeFormatter.parse(v, LocalDateTime::from))
+            .orElse(null);
     }
 
     public static LocalDate parseDateMember(JsonObject obj, String path) {
@@ -108,40 +112,43 @@ public final class GsonUtil {
 
     public static LocalTime parseTimeMember(JsonObject obj, String path) {
         return Optional.ofNullable(parseStringMember(obj, path))
-                .map(v -> LocalTime.parse(v, timeFormatter)).orElse(null);
+            .map(v -> LocalTime.parse(v, timeFormatter)).orElse(null);
     }
 
     public static LocalDate parseDateMember(JsonObject obj, String path, String pattern) {
         return Optional.ofNullable(parseStringMember(obj, path))
-                .map(s -> LocalDate.parse(s, DateTimeFormatter.ofPattern(pattern)))
-                .orElse(null);
+            .map(s -> LocalDate.parse(s, DateTimeFormatter.ofPattern(pattern)))
+            .orElse(null);
     }
 
-    public static List<Integer> parseIntListMember(JsonObject obj, String path) {
+    public static List<String> parseStringListMember(JsonObject obj, String path) {
         return getNode(obj, path)
-                .map(JsonElement::getAsJsonArray)
-                .map(a -> StreamSupport.stream(a.spliterator(), false)
-                        .map(JsonElement::getAsInt)
-                        .collect(Collectors.toList()))
-                .orElse(Collections.emptyList());
+            .map(JsonElement::getAsJsonArray)
+            .map(a -> StreamSupport.stream(a.spliterator(), false)
+                .map(JsonElement::getAsString)
+                .collect(Collectors.toList()))
+            .orElse(Collections.emptyList());
 
     }
 
-    public static List<Long> parseLongListMember(JsonObject obj, String path) {
+    public static List<Integer> parseIntListMember(JsonObject obj, String path) {
         return getNode(obj, path)
-                .map(JsonElement::getAsJsonArray)
-                .map(a -> StreamSupport.stream(a.spliterator(), false)
-                        .map(JsonElement::getAsLong)
-                        .collect(Collectors.toList()))
-                .orElse(null);
+            .map(JsonElement::getAsJsonArray)
+            .map(a -> StreamSupport.stream(a.spliterator(), false)
+                .map(JsonElement::getAsInt)
+                .collect(Collectors.toList()))
+            .orElse(Collections.emptyList());
 
     }
 
-    public static Quality parseQualityMember(JsonObject obj, String path) {
+    public static List<Long> parseLongListMember(JsonObject obj, String path) {
         return getNode(obj, path)
-                .map(JsonElement::getAsJsonObject)
-                .map(GeometryParser::parseQuality)
-                .orElse(null);
+            .map(JsonElement::getAsJsonArray)
+            .map(a -> StreamSupport.stream(a.spliterator(), false)
+                .map(JsonElement::getAsLong)
+                .collect(Collectors.toList()))
+            .orElse(null);
+
     }
 
     public static Object parseAttributeValue(JsonObject obj, String path, JavaType datatype) {
@@ -168,7 +175,7 @@ public final class GsonUtil {
     public static Optional<JsonElement> getNode(JsonObject start, String path) {
         Optional<JsonElement> temp = Optional.ofNullable(start);
 
-        List<String> elements = Arrays.asList(path.split("\\."));
+        String[] elements = path.split("\\.");
         for (String p : elements) {
             if (!temp.isPresent()) {
                 return temp;
@@ -180,8 +187,8 @@ public final class GsonUtil {
 
 
             temp = temp.map(JsonElement::getAsJsonObject)
-                       .map(o -> o.get(p))
-                       .filter(o -> !o.isJsonNull());
+                .map(o -> o.get(p))
+                .filter(o -> !o.isJsonNull());
         }
         return temp;
     }
@@ -189,4 +196,48 @@ public final class GsonUtil {
     public static Optional<JsonArray> getArray(JsonObject node, String path) {
         return getNode(node, path).map(JsonElement::getAsJsonArray);
     }
+
+    public static <T> List<T> parseArray(JsonObject obj, String path, Function<JsonObject, T> parser) {
+        return getArray(obj, path)
+            .map(array ->
+                StreamSupport.stream(array.spliterator(), false)
+                    .map(JsonElement::getAsJsonObject)
+                    .map(parser)
+                    .collect(toList()))
+            .orElseGet(Collections::emptyList);
+    }
+
+    public static Geometry parseGeometryMember(JsonObject obj, String path) {
+        if (obj.has(path)) {
+            return GeometryParser.parse(obj.getAsJsonObject(path));
+        } else {
+            return null;
+        }
+    }
+
+    public static RoadSysRef parseRoadSysRefMember(JsonObject obj, String path) {
+        if (obj.has(path) && obj.getAsJsonObject(path).size() > 0) {
+            return RoadSysRefParser.parse(obj.getAsJsonObject(path));
+        } else {
+            return null;
+        }
+    }
+
+    public static <T> Function<JsonObject, T> rt(Function<JsonObject, T> f) {
+        return obj -> {
+            try {
+                return f.apply(obj);
+            } catch (Exception e) {
+                throw new RuntimeException("Error processing \n" + obj, e);
+            }
+        };
+    }
+
+    private static Optional<JsonPrimitive> parseNodeToJsonPrimitive(JsonObject obj, String path) {
+        Optional<JsonPrimitive> jsonElement = getNode(obj, path).map(JsonElement::getAsJsonPrimitive);
+        if (jsonElement.isPresent() && !jsonElement.get().isNumber()) {
+            throw new IllegalArgumentException(path + " did not contain a number.");
+        }
+        return jsonElement;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/GuidanceParametersParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/GuidanceParametersParser.java
deleted file mode 100644
index 505a382..0000000
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/GuidanceParametersParser.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.vegvesen.nvdbapi.client.gson;
-
-import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.model.datakatalog.FeatureType;
-import no.vegvesen.nvdbapi.client.model.datakatalog.AttributeTypeParameters;
-import no.vegvesen.nvdbapi.client.model.datakatalog.FeatureTypeParameters;
-
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
-
-public final class GuidanceParametersParser {
-
-    private GuidanceParametersParser() {
-    }
-
-    public static AttributeTypeParameters parseAttributeType(JsonObject obj) {
-        Boolean derived = parseBooleanMember(obj, "avledet");
-        Boolean requiredValue = parseBooleanMember(obj, "obligatorisk_verdi");
-
-        return new AttributeTypeParameters(derived, requiredValue);
-    }
-
-    public static FeatureTypeParameters parseFeatureType(JsonObject obj) {
-        Boolean timeRelevant = parseBooleanMember(obj, "tidsrom_relevant");
-        Boolean secType20K = parseBooleanMember(obj, "sektype_20k");
-        Boolean isAbstract = parseBooleanMember(obj, "abstrakt_type");
-        Boolean hasFiltration = parseBooleanMember(obj, "filtrering");
-        Boolean isDerived = parseBooleanMember(obj, "avledet");
-        Boolean needsParent = parseBooleanMember(obj, "må_ha_mor");
-        Boolean isMeasureSet = parseBooleanMember(obj, "er_dataserie");
-        String coverage = parseStringMember(obj, "dekningsgrad");
-        Boolean overlaps = parseBooleanMember(obj, "overlapp");
-
-        FeatureType.Relevant laneRelevant =
-                FeatureType.Relevant.from(parseStringMember(obj, "kjørefelt_relevant"));
-        FeatureType.Relevant sidePositionRelevant =
-                FeatureType.Relevant.from(parseStringMember(obj, "sideposisjon_relevant"));
-        Boolean heightRelevant = parseBooleanMember(obj, "høyde_relevant");
-        Boolean directionRelevant = parseBooleanMember(obj, "retning_relevant");
-        Boolean movable = parseBooleanMember(obj, "flyttbar");
-        FeatureType.Survivability survivability =
-                FeatureType.Survivability.from(parseStringMember(obj, "ajourhold_i"));
-        FeatureType.Splitability split =
-                FeatureType.Splitability.from(parseStringMember(obj, "ajourhold_splitt"));
-
-
-        return new FeatureTypeParameters(timeRelevant, secType20K, isAbstract, hasFiltration, isDerived, needsParent,
-                isMeasureSet, coverage, laneRelevant, sidePositionRelevant, directionRelevant, heightRelevant,
-                overlaps, movable, survivability, split);
-    }
-}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/LinkParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/LinkParser.java
deleted file mode 100644
index 227c92f..0000000
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/LinkParser.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.vegvesen.nvdbapi.client.gson;
-
-import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.model.Geometry;
-import no.vegvesen.nvdbapi.client.model.roadnet.Link;
-import no.vegvesen.nvdbapi.client.model.roadnet.Ltema;
-import no.vegvesen.nvdbapi.client.model.roadnet.SosiMedium;
-import no.vegvesen.nvdbapi.client.model.roadnet.TopologyLevel;
-import no.vegvesen.nvdbapi.client.model.roadobjects.RoadRef;
-
-import java.time.LocalDate;
-import java.util.Optional;
-
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
-
-public final class LinkParser {
-
-    private LinkParser() {
-    }
-
-    public static Link parse(JsonObject obj) {
-        // Metadata
-        LocalDate fromDate = parseDateMember(obj, "metadata.startdato"), toDate = parseDateMember(obj, "metadata.sluttdato");
-
-        long id = parseLongMember(obj, "veglenkeid");
-        Double start = parseDoubleMember(obj, "startposisjon"), end = parseDoubleMember(obj, "sluttposisjon");
-        String startNode = parseStringMember(obj, "startnode"), endNode = parseStringMember(obj, "sluttnode");
-
-        boolean isConnectionLink = parseBooleanMember(obj, "konnekteringslenke");
-
-        SosiMedium medium = Optional.ofNullable(parseStringMember(obj, "medium")).map(SosiMedium::from).orElse(null);
-        Ltema ltema = Optional.ofNullable(parseIntMember(obj, "temakode")).map(Ltema::from).orElse(null);
-        TopologyLevel level = Optional.ofNullable(parseIntMember(obj, "topologinivå")).map(TopologyLevel::from).orElse(null);
-
-        // Areas
-        Integer municipality = parseIntMember(obj, "kommune");
-        Integer region = parseIntMember(obj, "region");
-        Integer county = parseIntMember(obj, "fylke");
-        Integer roadDepartment = parseIntMember(obj, "vegavdeling");
-
-        // Geometry
-        Geometry geo = null;
-        if (obj.has("geometri")) {
-            geo = GeometryParser.parse(obj.getAsJsonObject("geometri"));
-        }
-
-        RoadRef roadRef = null;
-        if (obj.has("vegreferanse")) {
-            roadRef = RoadRefParser.parse(obj.getAsJsonObject("vegreferanse"));
-        }
-
-        Long superLinkId = null;
-        if(obj.has("foreldrelenkeid")) {
-            superLinkId = parseLongMember(obj, "foreldrelenkeid");
-        }
-
-        return new Link(id, superLinkId, start, end, startNode, endNode, fromDate, toDate, medium, ltema, level, region, county, municipality, roadDepartment, geo, roadRef, isConnectionLink);
-    }
-
-}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/PlacementParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/PlacementParser.java
index 3e0cec4..2dcd82a 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/PlacementParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/PlacementParser.java
@@ -25,33 +25,41 @@
 
 package no.vegvesen.nvdbapi.client.gson;
 
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.model.Geometry;
+
+import no.vegvesen.nvdbapi.client.model.Direction;
 import no.vegvesen.nvdbapi.client.model.Position;
-import no.vegvesen.nvdbapi.client.model.RefLinkPosition;
 import no.vegvesen.nvdbapi.client.model.RoadPlacement;
-import no.vegvesen.nvdbapi.client.model.roadobjects.RoadRef;
+import no.vegvesen.nvdbapi.client.model.SidePosition;
+import no.vegvesen.nvdbapi.client.model.roadobjects.Placement;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RefLinkExtentPlacement;
+import no.vegvesen.nvdbapi.client.model.roadobjects.TurnExtentPlacement;
 
-import java.util.List;
-import java.util.stream.Collectors;
-import java.util.stream.StreamSupport;
+import static java.util.Objects.isNull;
 
-public final class PlacementParser {
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseDoubleMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseLongMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringListMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringMember;
 
-    private PlacementParser() {}
+public final class PlacementParser {
 
-    public static RoadPlacement parsePlacement(JsonObject obj) {
-        RoadRef roadRef = RoadRefParser.parse(obj.getAsJsonObject("vegreferanse"));
-        RefLinkPosition refLink = ShortRefLinkParser.parseShortRefLink(obj.getAsJsonObject("veglenke"));
-        Geometry point = GeometryParser.parse(obj.getAsJsonObject("geometri"));
+    private PlacementParser() {
+    }
 
-        return new RoadPlacement(roadRef, refLink, point);
+    private static RoadPlacement parseRoadPlacement(JsonObject obj) {
+        return RoadPlacementParser.parseRoadPlacement(obj);
     }
 
     public static Position.Result parsePosition(JsonObject obj) {
-        RoadPlacement placement = parsePlacement(obj);
+        RoadPlacement placement = parseRoadPlacement(obj);
         Double distance = obj.getAsJsonPrimitive("avstand").getAsDouble();
 
         return new Position.Result(placement, distance);
@@ -59,9 +67,64 @@ public final class PlacementParser {
 
     public static List<Position.Result> parseList(JsonArray array) {
         return StreamSupport.stream(array.spliterator(), false)
-                                .map(JsonElement::getAsJsonObject)
-                                .map(PlacementParser::parsePosition)
-                                .collect(Collectors.toList());
+            .map(JsonElement::getAsJsonObject)
+            .map(PlacementParser::parsePosition)
+            .collect(Collectors.toList());
+    }
+
+    static Placement parsePlacement(JsonObject obj) {
+        return parsePlacement(obj, "startposisjon", "sluttposisjon");
+    }
+
+    public static RefLinkExtentPlacement parseRefLinkExtentPlacement(JsonObject obj) {
+        return parseRefLinkExtentPlacement(obj, "startposisjon", "sluttposisjon");
+    }
+
+    private static Placement parsePlacement(JsonObject obj, String startPosField, String endPosField) {
+        if (isNull(obj)) return null;
+        String type = parseStringMember(obj, "type");
+        if (type != null && type.equalsIgnoreCase("sving")) {
+            return parseTurnExtentPlacement(obj, startPosField, endPosField);
+        }
+
+        return parseRefLinkExtentPlacement(obj, startPosField, endPosField);
+    }
+
+    private static TurnExtentPlacement parseTurnExtentPlacement(JsonObject obj, String startPosField,
+                                                                String endPosField) {
+        if (isNull(obj)) return null;
+        Long nodeid = parseLongMember(obj, "nodeid");
+        RefLinkExtentPlacement startposisjon = parseRefLinkExtentPlacement(obj.getAsJsonObject("startpunkt"),
+            startPosField, endPosField);
+        RefLinkExtentPlacement sluttposisjon = parseRefLinkExtentPlacement(obj.getAsJsonObject("sluttpunkt"),
+            startPosField, endPosField);
+
+        return new TurnExtentPlacement(nodeid, startposisjon, sluttposisjon);
+    }
+
+    private static RefLinkExtentPlacement parseRefLinkExtentPlacement(JsonObject obj, String startPosField,
+                                                                      String endPosField) {
+        if (isNull(obj)) return null;
+
+        long netElementId = parseLongMember(obj, "veglenkesekvensid");
+
+        double startPos, endPos;
+        if (obj.has("relativPosisjon")) {
+            startPos = endPos = parseDoubleMember(obj, "relativPosisjon");
+        } else {
+            startPos = parseDoubleMember(obj, startPosField);
+            endPos = parseDoubleMember(obj, endPosField);
+        }
+
+        Direction dir = Optional.ofNullable(parseStringMember(obj, "retning"))
+            .map(Direction::from)
+            .orElse(null);
+        SidePosition sidePos = Optional.ofNullable(parseStringMember(obj, "sideposisjon"))
+            .map(SidePosition::from)
+            .orElse(null);
+        List<String> lane = parseStringListMember(obj, "kjørefelt");
+
+        return new RefLinkExtentPlacement(netElementId, startPos, endPos, dir, sidePos, lane);
     }
 
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadNetParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadNetParser.java
new file mode 100644
index 0000000..142fda9
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadNetParser.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.gson;
+
+import java.time.LocalDate;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.StreamSupport;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+
+import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.roadnet.*;
+
+import static java.util.stream.Collectors.toList;
+
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseBooleanMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseDateMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseDoubleMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseIntMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseLongMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringMember;
+
+public final class RoadNetParser {
+
+    private RoadNetParser() { }
+
+    public static LinkSequence parseLinkSequence(JsonObject obj){
+        if(obj==null) return null;
+
+        long id = parseLongMember(obj, "veglenkesekvensid");
+        List<Port> ports = parsePorts(obj.getAsJsonArray("porter"));
+        List<Link> links = parseLinkPorts(obj.getAsJsonArray("veglenker"));
+
+        double length = parseDoubleMember(obj, "lengde");
+        boolean fixedLength = parseBooleanMember(obj, "låst_lengde");
+        return new LinkSequence(id, ports, links, length, fixedLength);
+    }
+
+    public static Node parseNode(JsonObject obj){
+        if(obj==null) return null;
+
+        Long id = parseLongMember(obj, "id");
+        Geometry geometry = GeometryParser.parse(obj.getAsJsonObject("geometri"));
+        LocalDate startDate = parseDateMember(obj, "startdato");
+        LocalDate endDate = parseDateMember(obj, "sluttdato");
+        List<Port> ports = parsePorts(obj.getAsJsonArray("porter"));
+
+        return new Node(id, geometry, startDate, endDate, ports);
+    }
+
+    private static List<Link> parseLinkPorts(JsonArray obj) {
+        return StreamSupport
+                .stream(obj.spliterator(), false)
+                .map(JsonElement::getAsJsonObject)
+                .map(o -> new Link(
+                        parseIntMember(o, "veglenkenummer"),
+                        parseType(o, "type"),
+                        TopologyLevel.fromValue(parseStringMember(o, "topologinivå")),
+                        parseIntMember(o, "startport"),
+                        parseIntMember(o, "sluttport"),
+                        parseDoubleMember(o, "startposisjon"),
+                        parseDoubleMember(o, "sluttposisjon"),
+                        parseIntMember(o, "geometri.kommune"),
+                        parseIntMember(o, "geometri.kommune"),
+                        parseDoubleMember(o, "geometri.lengde"),
+                        parseStringMember(o, "målemetode"),
+                        parseDateMember(o, "måledato"),
+                        SosiMedium.from(parseStringMember(o, "medium")),
+                        Ltema.from(parseIntMember(o, "geometri.temakode")),
+                        PlacementParser.parseRefLinkExtentPlacement(o.getAsJsonObject("superstedfesting")),
+                        TypeOfRoad.fromTextValue(parseStringMember(o, "typeVeg")),
+                        parseStringMember(o, "detaljnivå"),
+                        GeometryParser.parse(o.getAsJsonObject("geometri")),
+                        parseFields(o.getAsJsonArray("feltoversikt")),
+                        parseDateMember(o, "startdato"),
+                        parseDateMember(o, "sluttdato")
+                ))
+                .collect(toList());
+    }
+
+    private static LinkType parseType(JsonObject o, String type) {
+        return LinkType.valueOf(o.get(type).getAsString().toUpperCase());
+    }
+
+    private static List<String> parseFields(JsonArray obj) {
+        List<String> fields = new ArrayList<>();
+        if (obj != null) {
+            obj.forEach(p -> fields.add(p.toString()));
+        }
+        return fields;
+    }
+
+    private static List<Port> parsePorts(JsonArray obj) {
+        List<Port> ports = new ArrayList<>();
+        if (obj != null) {
+            obj.forEach(p ->
+                    ports.add(new Port(
+                            parseIntMember(p.getAsJsonObject(), "id"),
+                            parseDoubleMember(p.getAsJsonObject(), "relativPosisjon"),
+                            getTilkobling(p))));
+        }
+        return ports;
+    }
+
+    private static PortConnection getTilkobling(JsonElement p) {
+        JsonObject tilkobling = p.getAsJsonObject().getAsJsonObject("tilkobling");
+        return tilkobling == null
+                ? null
+                : getPortConnection(tilkobling);
+    }
+
+    private static PortConnection getPortConnection(JsonObject tilkobling) {
+        boolean pointsToNode = tilkobling.has("nodeid");
+        Long netelementid = pointsToNode ?
+                parseLongMember(tilkobling, "nodeid") :
+                parseLongMember(tilkobling, "veglenkesekvensid");
+        NetElementType netElementType = pointsToNode ? NetElementType.NODE : NetElementType.LENKE;
+        return new PortConnection(
+                parseIntMember(tilkobling, "portnummer"),
+                netelementid,
+                netElementType);
+    }
+
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadObjectParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadObjectParser.java
index 90e8238..c519a55 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadObjectParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadObjectParser.java
@@ -25,31 +25,79 @@
 
 package no.vegvesen.nvdbapi.client.gson;
 
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.LocalTime;
+import java.time.MonthDay;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
+
 import no.vegvesen.nvdbapi.client.model.Direction;
 import no.vegvesen.nvdbapi.client.model.Geometry;
-import no.vegvesen.nvdbapi.client.model.Quality;
 import no.vegvesen.nvdbapi.client.model.SidePosition;
 import no.vegvesen.nvdbapi.client.model.areas.ContractArea;
 import no.vegvesen.nvdbapi.client.model.areas.Route;
-import no.vegvesen.nvdbapi.client.model.roadobjects.*;
-import no.vegvesen.nvdbapi.client.model.datakatalog.DataType;
-
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.util.*;
-import java.util.stream.Collectors;
-import java.util.stream.StreamSupport;
-
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
+import no.vegvesen.nvdbapi.client.model.areas.Street;
+import no.vegvesen.nvdbapi.client.model.datakatalog.Unit;
+import no.vegvesen.nvdbapi.client.model.roadnet.DetailLevel;
+import no.vegvesen.nvdbapi.client.model.roadnet.RefLinkPartType;
+import no.vegvesen.nvdbapi.client.model.roadnet.TypeOfRoad;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
+import no.vegvesen.nvdbapi.client.model.roadobjects.Association;
+import no.vegvesen.nvdbapi.client.model.roadobjects.Location;
+import no.vegvesen.nvdbapi.client.model.roadobjects.Placement;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObject;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObjectType;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObjectTypeWithStats;
+import no.vegvesen.nvdbapi.client.model.roadobjects.Segment;
+import no.vegvesen.nvdbapi.client.model.roadobjects.Statistics;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.AssociationAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.Attribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.BlobAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.BooleanAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.DateAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.IntegerAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.IntegerEnumAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.ListAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.RealAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.RealEnumAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.ReflinkExtentAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.ShortDateAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.SpatialAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.StringAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.StringEnumAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.StructAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.TimeAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.TurnExtent;
+
+import static java.util.stream.Collectors.toList;
+
+import static no.vegvesen.nvdbapi.client.gson.AttributeTypeParser.parseUnit;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.getArray;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseBooleanMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseDateMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseDateTimeMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseDoubleMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseIntListMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseIntMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseLongMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringListMember;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringMember;
 
 public final class RoadObjectParser {
-    private RoadObjectParser() {
-    }
+    private RoadObjectParser() {}
 
-    public static RoadObject parse(Map<Integer, DataType> dataTypes, JsonObject obj) {
+    public static RoadObject parse(JsonObject obj) {
         Integer id = parseIntMember(obj, "id");
 
         Integer typeId = parseIntMember(obj, "metadata.type.id");
@@ -57,203 +105,313 @@ public final class RoadObjectParser {
         LocalDate startDate = parseDateMember(obj, "metadata.startdato"), endDate = parseDateMember(obj, "metadata.sluttdato");
         LocalDateTime lastModified = parseDateTimeMember(obj, "metadata.sist_modifisert");
 
-        List<Attribute> attributes = Collections.emptyList();
-        JsonArray egenskaper = obj.getAsJsonArray("egenskaper");
-        if (egenskaper != null) {
-            attributes = StreamSupport.stream(egenskaper.spliterator(), false).map(e -> parseAttribute(dataTypes, e.getAsJsonObject())).collect(Collectors.toList());
-        }
+        List<Attribute> attributes = parseAttributes(obj);
 
-        List<Association> childrenList = Collections.emptyList();
-        JsonArray children = getArray(obj, "relasjoner.barn").orElse(null);
-        if (children != null) {
-            childrenList = StreamSupport.stream(children.spliterator(), false).map(e -> parseAssociation(dataTypes, e.getAsJsonObject())).collect(Collectors.toList());
-        }
+        List<Association> childrenList = parseChildren(obj);
 
-        List<Association> parentList = Collections.emptyList();
-        JsonArray parents = getArray(obj, "relasjoner.foreldre").orElse(null);
-        if (parents != null) {
-            parentList = StreamSupport.stream(parents.spliterator(), false).map(e -> parseAssociation(dataTypes, e.getAsJsonObject())).collect(Collectors.toList());
-        }
+        List<Association> parentList = parseParents(obj);
 
-        JsonElement loc = obj.get("lokasjon");
-        Location location = Optional.ofNullable(loc).map(e -> parseLocation(e.getAsJsonObject())).orElse(null);
+        Location location = Optional.ofNullable(obj.get("lokasjon"))
+            .map(e -> parseLocation(e.getAsJsonObject())).orElse(null);
 
         Geometry geometry = null;
         if (obj.has("geometri")) {
             geometry = GeometryParser.parse(obj.getAsJsonObject("geometri"));
         }
 
-        SegmentationFilter segFilter = null;
-        JsonElement segmentation = obj.get("segmentering");
-        if (segmentation != null) {
-            segFilter = parseSegmentFilter(segmentation.getAsJsonObject());
-        }
+        List<Segment> segments = parseSegments(obj);
 
+        return new RoadObject(id, typeId, version, startDate, endDate, segments, location, geometry,
+            lastModified, attributes, childrenList, parentList);
+    }
+
+    private static List<Segment> parseSegments(JsonObject obj) {
         List<Segment> segments = Collections.emptyList();
         JsonArray segmenter = obj.getAsJsonArray("vegsegmenter");
         if (segmenter != null) {
-            segments = StreamSupport.stream(segmenter.spliterator(), false).map(e -> parseSegment(e.getAsJsonObject())).collect(Collectors.toList());
+            return StreamSupport.stream(segmenter.spliterator(), false)
+                .map(e -> parseSegment(e.getAsJsonObject()))
+                .collect(toList());
         }
+        return segments;
+    }
 
-        return new RoadObject(id, typeId, version, startDate, endDate, segFilter, segments, location, geometry,
-                lastModified, attributes, childrenList, parentList);
+    private static List<Association> parseParents(JsonObject obj) {
+        JsonArray parents = getArray(obj, "relasjoner.foreldre").orElse(null);
+        return getAssociations(parents);
     }
 
-    private static Location parseLocation(JsonObject obj) {
+    private static List<Association> parseChildren(JsonObject obj) {
+        JsonArray children = getArray(obj, "relasjoner.barn").orElse(null);
+        return getAssociations(children);
+    }
 
-        List<Integer> municipalities = parseIntListMember(obj, "kommuner");
-        List<Integer> counties = parseIntListMember(obj, "fylker");
-        List<Integer> regions  = parseIntListMember(obj, "regioner");
-        List<Integer> departments = parseIntListMember(obj, "vegavdelinger");
-        List<ContractArea> contractAreas = Collections.emptyList();
-        if (obj.has("kontraktsområder")) {
-            contractAreas = StreamSupport.stream(obj.getAsJsonArray("kontraktsområder").spliterator(), false)
-                    .map(JsonElement::getAsJsonObject).map(AreaParser::parseContractArea).collect(Collectors.toList());
+    private static List<Association> getAssociations(JsonArray parents) {
+        if (parents != null) {
+            return StreamSupport.stream(parents.spliterator(), false)
+                .map(e -> parseAssociation(e.getAsJsonObject()))
+                .collect(toList());
+        } else {
+            return Collections.emptyList();
         }
-        List<Route> nationalRoutes = Collections.emptyList();
-        if (obj.has("riksvegruter")) {
-            nationalRoutes = StreamSupport.stream(obj.getAsJsonArray("riksvegruter").spliterator(), false)
-                    .map(JsonElement::getAsJsonObject).map(AreaParser::parseRoute).collect(Collectors.toList());
+    }
+
+    static List<Attribute> parseAttributes(JsonObject obj) {
+        JsonArray egenskaper = obj.getAsJsonArray("egenskaper");
+        if (egenskaper != null) {
+            return parseInnhold(egenskaper);
+        } else {
+            return Collections.emptyList();
         }
+    }
+
+    static Location parseLocation(JsonObject obj) {
+        List<Integer> municipalities = parseIntListMember(obj, "kommuner");
+        List<Integer> counties = parseIntListMember(obj, "fylker");
+        List<ContractArea> contractAreas = parseContractAreas(obj);
+        List<Route> nationalRoutes = parseRoutes(obj);
+        List<Street> streets = parseStreets(obj);
 
         Geometry geometry = null;
         if (obj.has("geometri")) {
             geometry = GeometryParser.parse(obj.get("geometri").getAsJsonObject());
         }
 
-        JsonArray refs = obj.getAsJsonArray("vegreferanser");
-        List<RoadRef> roadRefs = Collections.emptyList();
+        JsonArray refs = obj.getAsJsonArray("vegsystemreferanser");
+        List<RoadSysRef> roadRefs = Collections.emptyList();
         if (refs != null) {
-            roadRefs = StreamSupport.stream(refs.spliterator(), false).map(e -> RoadRefParser.parse(e.getAsJsonObject())).collect(Collectors.toList());
+            roadRefs = StreamSupport.stream(refs.spliterator(), false)
+                .map(JsonElement::getAsJsonObject)
+                .map(RoadSysRefParser::parse)
+                .collect(toList());
         }
 
         List<Placement> placements = Collections.emptyList();
         JsonArray placementsArray = getArray(obj, "stedfestinger").orElse(null);
         if (placementsArray != null) {
             placements = StreamSupport.stream(placementsArray.spliterator(), false)
-                    .map(JsonElement::getAsJsonObject)
-                    .map(RoadObjectParser::parsePlacement)
-                    .collect(Collectors.toList());
+                .map(JsonElement::getAsJsonObject)
+                .map(PlacementParser::parsePlacement)
+                .collect(toList());
         }
 
-        Double length = parseDoubleMember(obj, "strekningslengde");
+        Double length = parseDoubleMember(obj, "lengde");
 
-        return new Location(municipalities, counties, regions,
-                departments, length, placements, roadRefs,
-                contractAreas, nationalRoutes, geometry);
+        return new Location(municipalities, counties, length, placements, roadRefs, contractAreas,
+            nationalRoutes, streets, geometry);
     }
 
-    private static SegmentationFilter parseSegmentFilter(JsonObject object) {
-        List<Integer> municipalities = Optional.ofNullable(parseIntListMember(object, "kommuner")).orElse(Collections.emptyList());
-        List<Integer> counties = Optional.ofNullable(parseIntListMember(object, "fylker")).orElse(Collections.emptyList());
-        List<Integer> regions = Optional.ofNullable(parseIntListMember(object, "regioner")).orElse(Collections.emptyList());
-        List<Integer> roadDepartments = Optional.ofNullable(parseIntListMember(object, "vegavdelinger")).orElse(Collections.emptyList());
-        List<RoadRefFilter> roadRefFilters = Optional.ofNullable(parseRoadRefFilter(object)).orElse(Collections.emptyList());
-
-        return new SegmentationFilter(municipalities, counties,
-                regions, roadDepartments, roadRefFilters);
+    static List<Route> parseRoutes(JsonObject obj) {
+        List<Route> nationalRoutes = Collections.emptyList();
+        if (obj.has("riksvegruter")) {
+            nationalRoutes = StreamSupport.stream(obj.getAsJsonArray("riksvegruter").spliterator(), false)
+                .map(JsonElement::getAsJsonObject).map(AreaParser::parseRoute)
+                .collect(Collectors.toList());
+        }
+        return nationalRoutes;
     }
 
-    private static Segment parseSegment(JsonObject obj) {
-        Placement placement = parsePlacement(obj.getAsJsonObject("stedfesting"));
-
-        Geometry geo = GeometryParser.parse(obj.getAsJsonObject("geometri"));
-
-        Integer municipality = Optional.ofNullable(parseIntMember(obj, "kommune")).orElse(0);
-        Integer county = Optional.ofNullable(parseIntMember(obj, "fylke")).orElse(0);
-        Integer region  = Optional.ofNullable(parseIntMember(obj, "region")).orElse(0);
-        Integer department = Optional.ofNullable(parseIntMember(obj, "vegavdeling")).orElse(0);
-
-        RoadRef ref = null;
-        if (obj.has("vegreferanse")) {
-            ref = RoadRefParser.parse(obj.get("vegreferanse").getAsJsonObject());
+    static List<Street> parseStreets(JsonObject obj) {
+        List<Street> streets = Collections.emptyList();
+        if (obj.has("gater")) {
+            streets = StreamSupport.stream(obj.getAsJsonArray("gater").spliterator(), false)
+                .map(JsonElement::getAsJsonObject)
+                .map(street -> new Street(
+                        parseStringMember(street, "navn"),
+                        parseIntMember(street,"gatekode"),
+                        parseBooleanMember(street, "sideveg")
+                ))
+                .collect(Collectors.toList());
         }
-
-        Integer length = parseIntMember(obj, "strekningslengde");
-
-        return new Segment(geo, municipality, county, region, department, placement, ref, length);
+        return streets;
     }
 
-    private static Placement parsePlacement(JsonObject obj) {
-        int netElementId = parseIntMember(obj, "veglenkeid");
-
-        double startPos, endPos;
-        if (obj.has("posisjon")) {
-            startPos = endPos = parseDoubleMember(obj, "posisjon");
+    static Street parseStreet(JsonObject obj) {
+        if(obj.has("gate")) {
+            JsonObject street = obj.getAsJsonObject("gate");
+            return new Street(
+                    parseStringMember(street, "navn"),
+                    parseIntMember(street,"gatekode"),
+                    parseBooleanMember(street, "sideveg")
+            );
         } else {
-            startPos = parseDoubleMember(obj, "fra_posisjon");
-            endPos = parseDoubleMember(obj, "til_posisjon");
+            return null;
         }
+    }
 
-        Direction dir = Optional.of(parseStringMember(obj, "retning")).map(Direction::from).orElse(null);
-        SidePosition sidePos = Optional.ofNullable(parseStringMember(obj, "sideposisjon")).map(SidePosition::from).orElse(null);
-        String lane = parseStringMember(obj, "felt");
-        return new Placement(netElementId, startPos, endPos, dir, sidePos, lane);
+    static List<ContractArea> parseContractAreas(JsonObject obj) {
+        List<ContractArea> contractAreas = Collections.emptyList();
+        if (obj.has("kontraktsområder")) {
+            contractAreas = StreamSupport.stream(obj.getAsJsonArray("kontraktsområder").spliterator(), false)
+                .map(JsonElement::getAsJsonObject)
+                .map(AreaParser::parseContractArea)
+                .collect(Collectors.toList());
+        }
+        return contractAreas;
     }
 
-    private static List<RoadRefFilter> parseRoadRefFilter(JsonObject object) {
-        if (!object.has("vegreferanser")) {
-            return Collections.emptyList();
+    private static Segment parseSegment(JsonObject obj) {
+
+        Geometry geo = GeometryParser.parse(obj.getAsJsonObject("geometri"));
+
+        Integer municipality = parseIntMember(obj, "kommune");
+        Integer county = parseIntMember(obj, "fylke");
+
+        RoadSysRef ref = null;
+        if (obj.has("vegsystemreferanse")) {
+            ref = RoadSysRefParser.parse(obj.getAsJsonObject("vegsystemreferanse"));
         }
 
-        JsonArray a = object.getAsJsonArray("vegreferanser");
-
-        return StreamSupport.stream(a.spliterator(), false).map(JsonElement::getAsJsonObject)
-                .map(o -> {
-                    Integer c = parseIntMember(o, "fylke");
-                    Integer m = parseIntMember(o, "kommune");
-                    String cat = parseStringMember(o, "kategori");
-                    String stat = parseStringMember(o, "status");
-                    Integer n = parseIntMember(o, "nummer");
-                    Integer fromHp = null, toHp = null;
-                    if (o.has("hp")) {
-                        fromHp = parseIntMember(o, "hp");
-                    } else {
-                        fromHp = parseIntMember(o, "fra_hp");
-                        toHp = parseIntMember(o, "til_hp");
-                    }
-
-                    return new RoadRefFilter(c, m, cat, stat, n, fromHp, toHp);
-                })
-                .collect(Collectors.toList());
+        Integer length = parseIntMember(obj, "lengde");
+
+        boolean isPoint = obj.has("relativPosisjon");
+        double startPos = isPoint ? parseDoubleMember(obj, "relativPosisjon") : parseDoubleMember(obj, "startposisjon");
+        double endPos   = isPoint ? startPos : parseDoubleMember(obj, "sluttposisjon");
+
+        return new Segment(
+            parseLongMember(obj, "veglenkesekvensid"),
+            startPos,
+            endPos,
+            Direction.from(parseStringMember(obj, "retning")),
+            geo,
+            municipality,
+            county,
+            ref,
+            length,
+            parseDateMember(obj, "startdato"),
+            parseDateMember(obj, "sluttdato"),
+            RefLinkPartType.fromValue(parseStringMember(obj, "veglenkeType")),
+            DetailLevel.fromTextValue(parseStringMember(obj, "detaljnivå")),
+            TypeOfRoad.fromTextValue(parseStringMember(obj, "typeVeg")));
     }
 
-    public static Attribute parseAttribute(Map<Integer, DataType> dataTypes, JsonObject obj) {
+    public static Attribute parseAttribute(JsonObject obj) {
         Integer id = parseIntMember(obj, "id");
-        String name = parseStringMember(obj, "navn");
-        Integer enumId = parseIntMember(obj, "enum_id");
-        int dataTypeId = parseIntMember(obj, "datatype");
-        DataType dataType = dataTypes.get(dataTypeId);
-        Object value = parseAttributeValue(obj, "verdi", dataType.getJavaType());
-
-        Quality quality = null;
-        if (obj.has("kvalitet")) {
-            quality = parseQualityMember(obj, "kvalitet");
+        String egenskapstype = parseStringMember(obj, "egenskapstype");
+
+        switch (egenskapstype) {
+            case "Assosiasjon":
+                return new AssociationAttribute(id, parseLongMember(obj, "verdi"));
+            case "Binær":
+                return new BlobAttribute(
+                    id,
+                    parseIntMember(obj, "blob_id"),
+                    parseStringMember(obj, "blob_format"),
+                    parseStringMember(obj, "href"));
+            case "Boolsk":
+                return new BooleanAttribute(id, parseBooleanMember(obj, "verdi"));
+            case "Dato":
+                return new DateAttribute(id, parseDateMember(obj, "verdi"));
+            case "Flyttall":
+                return new RealAttribute(id, parseDoubleMember(obj, "verdi"), getUnit(obj));
+            case "Flyttallenum":
+                return new RealEnumAttribute(id, parseIntMember(obj, "enum_id"), parseDoubleMember(obj, "verdi"));
+            case "Geometri":
+                return new SpatialAttribute(id, GeometryParser.parseAttribute(obj));
+            case "Heltall":
+                return new IntegerAttribute(id, parseIntMember(obj, "verdi"), getUnit(obj));
+            case "Heltallenum":
+                return new IntegerEnumAttribute(id, parseIntMember(obj, "enum_id"), parseIntMember(obj, "verdi"));
+            case "Kortdato":
+                return new ShortDateAttribute(id, MonthDay.parse("--" + parseStringMember(obj, "verdi")));
+            case "Liste":
+                return new ListAttribute(
+                    id,
+                    parseInnhold(obj.getAsJsonArray("innhold")));
+            case "Stedfesting":
+                String stedfestingstype = parseStringMember(obj, "stedfestingstype");
+                switch (stedfestingstype) {
+                    case "Punkt":
+                        return new ReflinkExtentAttribute(
+                            id,
+                            parseLongMember(obj, "veglenkesekvensid"),
+                            Direction.from(parseStringMember(obj, "retning")),
+                            SidePosition.from(parseStringMember(obj, "sideposisjon")),
+                            parseStringListMember(obj, "kjørefelt"),
+                            parseDoubleMember(obj, "relativPosisjon"),
+                            parseDoubleMember(obj, "relativPosisjon")
+                        );
+                    case "Linje":
+                        return new ReflinkExtentAttribute(
+                            id,
+                            parseLongMember(obj, "veglenkesekvensid"),
+                            Direction.from(parseStringMember(obj, "retning")),
+                            SidePosition.from(parseStringMember(obj, "sideposisjon")),
+                            parseStringListMember(obj, "kjørefelt"),
+                            parseDoubleMember(obj, "startposisjon"),
+                            parseDoubleMember(obj, "sluttposisjon")
+                        );
+                    case "Sving": return new TurnExtent(
+                        id,
+                        parseLongMember(obj, "nodeid"),
+                        PlacementParser.parseRefLinkExtentPlacement(obj.getAsJsonObject("startpunkt")),
+                        PlacementParser.parseRefLinkExtentPlacement(obj.getAsJsonObject("sluttpunkt"))
+                    );
+                    default: throw new IllegalArgumentException("Unknown stedfestingstype " + stedfestingstype);
+                }
+            case "Struktur":
+                return new StructAttribute(
+                    id,
+                    parseInnhold(obj.getAsJsonArray("innhold"))
+                    );
+            case "Tekst":
+                return new StringAttribute(id, parseStringMember(obj, "verdi"));
+            case "Tekstenum":
+                return new StringEnumAttribute(id, parseIntMember(obj, "enum_id"), parseStringMember(obj, "verdi"));
+            case "Tid":
+                return new TimeAttribute(id, LocalTime.parse(parseStringMember(obj, "verdi")));
+            default: throw new RuntimeException("Ukjent egenskapstype: " + egenskapstype);
         }
+    }
+
+    private static Unit getUnit(JsonObject obj) {
+        return obj.has("enhet") ? parseUnit(obj.getAsJsonObject("enhet")) : null;
+    }
 
-        return new Attribute(id, name, dataType, value, Optional.ofNullable(enumId), Optional.ofNullable(quality));
+    private static List<Attribute> parseInnhold(JsonArray innhold) {
+        return StreamSupport.stream(innhold.spliterator(), false)
+            .map(JsonElement::getAsJsonObject)
+            .map(RoadObjectParser::parseAttribute)
+            .collect(toList());
     }
 
-    private static Association parseAssociation(Map<Integer, DataType> dataTypes, JsonObject obj) {
+    private static Association parseAssociation(JsonObject obj) {
         Integer typeId = parseIntMember(obj, "type.id");
         JsonArray objects = obj.get("vegobjekter").getAsJsonArray();
-        Set<RoadObject> roadObjects = StreamSupport.stream(objects.spliterator(), false).map(e -> {
-            RoadObject ro;
-            if (e.isJsonPrimitive()) {
-                ro = new RoadObject(e.getAsLong(), typeId, null, null, null, null, null, null, null, null, null, null, null);
-            } else {
-                ro = parse(dataTypes, e.getAsJsonObject());
-            }
-            return ro;
-        }).collect(Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(RoadObject::getId))));
+        Set<RoadObject> roadObjects = StreamSupport.stream(objects.spliterator(), false)
+            .map(e -> {
+                RoadObject ro;
+                if (e.isJsonPrimitive()) {
+                    ro = new RoadObject(e.getAsLong(), typeId, null, null, null, null, null, null, null, null, null, null);
+                } else {
+                    ro = parse(e.getAsJsonObject());
+                }
+                return ro;
+            }).collect(Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(RoadObject::getId))));
 
         return new Association(typeId, roadObjects);
     }
 
     public static Statistics parseStatistics(JsonObject obj) {
         int numFound = parseIntMember(obj, "antall");
-        long length = parseLongMember(obj, "strekningslengde");
+        double length = parseDoubleMember(obj, "lengde");
 
         return new Statistics(numFound, length);
     }
+
+    public static RoadObjectType parseRoadObjectType(JsonObject obj){
+        if(obj == null) return null;
+        Integer id = parseIntMember(obj, "id");
+        String name = parseStringMember(obj, "navn");
+
+        return new RoadObjectType(id, name, parseStatistics(obj.getAsJsonObject("statistikk")));
+    }
+
+    public static RoadObjectTypeWithStats parseRoadObjectTypeWithStats(JsonObject o) {
+        return new RoadObjectTypeWithStats(
+            o.get("id").getAsInt(),
+            o.get("navn").getAsString(),
+            parseStatistics(o.getAsJsonObject("statistikk"))
+        );
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadPlacementParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadPlacementParser.java
index a6e8bf4..bf5753c 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadPlacementParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadPlacementParser.java
@@ -28,10 +28,10 @@ package no.vegvesen.nvdbapi.client.gson;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import no.vegvesen.nvdbapi.client.model.Geometry;
-import no.vegvesen.nvdbapi.client.model.RoadPlacement;
 import no.vegvesen.nvdbapi.client.model.RefLinkPosition;
+import no.vegvesen.nvdbapi.client.model.RoadPlacement;
 import no.vegvesen.nvdbapi.client.model.RoadPlacementBulkResult;
-import no.vegvesen.nvdbapi.client.model.roadobjects.RoadRef;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
 
 public final class RoadPlacementParser {
     private RoadPlacementParser() {}
@@ -47,11 +47,11 @@ public final class RoadPlacementParser {
     }
 
     public static RoadPlacement parseRoadPlacement(JsonObject obj) {
-        RoadRef roadRef = RoadRefParser.parse(obj.getAsJsonObject("vegreferanse"));
-        RefLinkPosition refLinkPosition = ShortRefLinkParser.parseShortRefLink(obj.getAsJsonObject("veglenke"));
+        RoadSysRef roadRef = RoadSysRefParser.parse(obj.getAsJsonObject("vegsystemreferanse"));
+        RefLinkPosition refLinkPosition = ShortRefLinkParser.parseShortRefLink(obj.getAsJsonObject("veglenkesekvens"));
         Geometry point = GeometryParser.parse(obj.getAsJsonObject("geometri"));
-
-       return new RoadPlacement(roadRef, refLinkPosition, point);
+        Integer municipality = obj.has("kommune") ? obj.getAsJsonPrimitive("kommune").getAsInt() : null;
+        return new RoadPlacement(roadRef, refLinkPosition, point, municipality);
     }
 
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadRefParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadRefParser.java
deleted file mode 100644
index 9340f81..0000000
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadRefParser.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.vegvesen.nvdbapi.client.gson;
-
-import com.google.gson.JsonObject;
-import no.vegvesen.nvdbapi.client.model.roadobjects.RoadRef;
-
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseIntMember;
-import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseStringMember;
-
-public final class RoadRefParser {
-    private RoadRefParser() {}
-
-    public static RoadRef parse(JsonObject obj) {
-        Integer county = parseIntMember(obj, "fylke");
-        Integer municipality = parseIntMember(obj, "kommune");
-
-        String category = parseStringMember(obj, "kategori");
-        String status = parseStringMember(obj, "status");
-        Integer number = parseIntMember(obj, "nummer");
-        String shortName = parseStringMember(obj, "kortform");
-
-        if (obj.has("hp")) {
-            Integer hp = parseIntMember(obj, "hp");
-            if (obj.has("fra_meter")) {
-                Integer fromMeter = parseIntMember(obj, "fra_meter");
-                Integer toMeter = parseIntMember(obj, "til_meter");
-
-                return RoadRef.stretch(county, municipality, category, status, number, hp, fromMeter, toMeter, shortName);
-            } else {
-                Integer meter = parseIntMember(obj, "meter");
-
-                return RoadRef.point(county, municipality, category, status, number, hp, meter, shortName);
-            }
-        } else {
-            Integer fromHp = parseIntMember(obj, "fra_hp");
-            Integer toHp = parseIntMember(obj, "til_hp");
-            Integer fromMeter = parseIntMember(obj, "fra_meter");
-            Integer toMeter = parseIntMember(obj, "til_meter");
-
-            return RoadRef.merged(county, municipality, category, status, number, fromHp, toHp, fromMeter, toMeter, shortName);
-        }
-    }
-}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadSysRefParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadSysRefParser.java
new file mode 100644
index 0000000..de1da24
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/RoadSysRefParser.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.gson;
+
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.roadnet.RoadUserGroup;
+import no.vegvesen.nvdbapi.client.model.roadnet.SeparatePassages;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.*;
+
+import static java.util.Objects.isNull;
+import static java.util.Objects.nonNull;
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
+
+public final class RoadSysRefParser {
+    private RoadSysRefParser() {}
+
+    public static RoadSysRef parse(JsonObject obj) {
+        if (isNull(obj)) return null;
+
+        if(!obj.has("vegsystem")) return  null;
+        return new RoadSysRef(
+            parseRoadSystem(obj.getAsJsonObject("vegsystem")),
+            parseSection(obj.getAsJsonObject("strekning")),
+            parseIntersection(obj.getAsJsonObject("kryssystem")),
+            parseSideArea(obj.getAsJsonObject("sideanlegg")),
+            parseStringMember(obj, "kortform"));
+    }
+
+    private static RoadSystem parseRoadSystem(JsonObject obj) {
+        return new RoadSystem(
+            parseLongMember(obj, "id"),
+            parseIntMember(obj, "versjon"),
+            parseIntMember(obj,"nummer"),
+            RoadCategory.valueOf(parseStringMember(obj, "vegkategori")),
+            Phase.valueOf(parseStringMember(obj, "fase")));
+    }
+
+    private static Double getFromMeter(JsonObject obj) {
+        Double fromMeter = parseDoubleMember(obj, "fra_meter");
+        if (isNull(fromMeter) ) {
+            return parseDoubleMember(obj, "meter");
+        }
+        return fromMeter;
+    }
+
+    private static Double getToMeter(JsonObject obj) {
+        Double toMeter = parseDoubleMember(obj, "til_meter");
+
+        if (isNull(toMeter)) {
+            return parseDoubleMember(obj, "meter");
+        }
+        return toMeter;
+    }
+
+    private static Section parseSection(JsonObject obj) {
+        if (isNull(obj)) return null;
+        return new Section(
+            parseLongMember(obj, "id"),
+            parseIntMember(obj, "versjon"),
+            parseIntMember(obj, "strekning"),
+            parseIntMember(obj, "delstrekning"),
+            parseBooleanMember(obj, "arm"),
+            parseOptionalStringMember(obj, "adskilte_løp").map(SeparatePassages::fromValue).orElse(null),
+            RoadUserGroup.fromValue(parseStringMember(obj, "trafikantgruppe")),
+            getFromMeter(obj),
+            getToMeter(obj),
+            Direction.from(parseStringMember(obj, "retning")));
+    }
+
+    private static Intersection parseIntersection(JsonObject obj) {
+        if (isNull(obj)) return null;
+
+        Integer intersectionNumber = parseIntMember(obj, "kryssystem");
+        if (nonNull(intersectionNumber)) {
+            return new Intersection(
+                parseLongMember(obj, "id"),
+                parseIntMember(obj, "versjon"),
+                intersectionNumber,
+                parseIntMember(obj, "kryssdel"),
+                getFromMeter(obj),
+                getToMeter(obj),
+                Direction.from(parseStringMember(obj, "retning")),
+                RoadUserGroup.fromValue(parseStringMember(obj, "trafikantgruppe")));
+        }
+        return null;
+    }
+
+    private static SideArea parseSideArea(JsonObject obj) {
+        if (isNull(obj)) return null;
+
+        Integer sideAreaNumber = parseIntMember(obj, "sideanlegg");
+        if (nonNull(sideAreaNumber)) {
+            return new SideArea(
+                parseLongMember(obj, "id"),
+                parseIntMember(obj, "versjon"),
+                sideAreaNumber,
+                parseIntMember(obj, "sideanleggsdel"),
+                getFromMeter(obj),
+                getToMeter(obj),
+                Direction.from(parseStringMember(obj, "retning")),
+                RoadUserGroup.fromValue(parseStringMember(obj, "trafikantgruppe")));
+        }
+        return null;
+    }
+
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/RouteParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/RouteParser.java
new file mode 100644
index 0000000..60dfea4
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/RouteParser.java
@@ -0,0 +1,46 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.roadnet.route.RouteOnRoadNet;
+import no.vegvesen.nvdbapi.client.model.roadnet.route.RouteStatus;
+
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
+public class RouteParser {
+    static class RouteResponseField {
+        static final String ROUTE_SEGMENTS = "vegnettsrutesegmenter";
+        static final String METADATA = "metadata";
+        static final String LENGTH = "lengde";
+        static final String STATUS = "status";
+        static final String STATUS_TEXT = "status_tekst";
+    }
+
+    public static RouteOnRoadNet parseDetailed(JsonObject result) {
+        JsonObject metadata = result.getAsJsonObject(RouteResponseField.METADATA);
+        JsonArray segmenter = result.getAsJsonArray(RouteResponseField.ROUTE_SEGMENTS);
+        return new RouteOnRoadNet(
+            StreamSupport.stream(
+                    segmenter.spliterator(), false)
+                    .map(JsonElement::getAsJsonObject)
+                    .map(DetailedRouteSegmentParser::parse)
+                    .collect(Collectors.toList()),
+                metadata.get(RouteResponseField.LENGTH).getAsDouble(),
+                RouteStatus.valueOfCode(metadata.get(RouteResponseField.STATUS).getAsInt()));
+    }
+
+    public static RouteOnRoadNet parseBrief(JsonObject result) {
+        JsonObject metadata = result.getAsJsonObject(RouteResponseField.METADATA);
+        JsonArray segmenter = result.getAsJsonArray(RouteResponseField.ROUTE_SEGMENTS);
+        return new RouteOnRoadNet(
+                StreamSupport.stream(
+                        segmenter.spliterator(), false)
+                        .map(JsonElement::getAsJsonObject)
+                        .map(BriefRouteSegmentParser::parse)
+                        .collect(Collectors.toList()),
+                metadata.get(RouteResponseField.LENGTH).getAsDouble(),
+                RouteStatus.valueOfCode(metadata.get(RouteResponseField.STATUS).getAsInt()));
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/SegmentedLinkParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/SegmentedLinkParser.java
new file mode 100644
index 0000000..c18f1cb
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/SegmentedLinkParser.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.gson;
+
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.SidePosition;
+import no.vegvesen.nvdbapi.client.model.roadnet.*;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RefLinkExtentPlacement;
+
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
+import static no.vegvesen.nvdbapi.client.gson.RoadObjectParser.*;
+
+public final class SegmentedLinkParser {
+
+    private SegmentedLinkParser() {
+    }
+
+    public static SegmentedLink parse(JsonObject obj) {
+        return new SegmentedLink(
+                parseLongMember(obj, "veglenkesekvensid"),
+                parseDoubleMember(obj, "startposisjon"),
+                parseDoubleMember(obj, "sluttposisjon"),
+                parseIntMember(obj, "veglenkenummer"),
+                parseIntMember(obj, "segmentnummer"),
+                DetailLevel.fromTextValue(parseStringMember(obj, "detaljnivå")),
+                TopologyLevel.fromValue(parseStringMember(obj, "topologinivå")),
+                TypeOfRoad.fromTextValue(parseStringMember(obj, "typeVeg")),
+                parseStringMember(obj, "startnode"),
+                parseStringMember(obj, "sluttnode"),
+                parseSuperlinkExtent(obj),
+                parseDateMember(obj, "metadata.startdato"),
+                parseDateMember(obj, "metadata.sluttdato"),
+                parseIntMember(obj, "fylke"),
+                parseIntMember(obj, "kommune"),
+                GsonUtil.parseGeometryMember(obj, "geometri"),
+                parseDoubleMember(obj, "lengde"),
+                GsonUtil.parseRoadSysRefMember(obj, "vegsystemreferanse"),
+                RefLinkPartType.fromValue(parseStringMember(obj,"type")),
+                parseContractAreas(obj),
+                parseRoutes(obj),
+                parseStreet(obj));
+    }
+
+    private static RefLinkExtentPlacement parseSuperlinkExtent(JsonObject obj) {
+        Long superLinkId = parseLongMember(obj, "superstedfesting.veglenkesekvensid");
+        if(superLinkId != null) {
+            return new RefLinkExtentPlacement(
+                superLinkId,
+                parseDoubleMember(obj, "superstedfesting.startposisjon"),
+                parseDoubleMember(obj, "superstedfesting.sluttposisjon"),
+                parseOptionalStringMember(obj, "superstedfesting.retning").map(Direction::from).orElse(null),
+                parseOptionalStringMember(obj, "superstedfesting.sideposisjon").map(SidePosition::from).orElse(null),
+                parseStringListMember(obj, "superstedfesting.kjørefelt")
+            );
+        } else {
+            return null;
+        }
+    }
+
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/ShortRefLinkParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/ShortRefLinkParser.java
index 8a3771d..68137e7 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/ShortRefLinkParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/ShortRefLinkParser.java
@@ -36,8 +36,8 @@ public final class ShortRefLinkParser {
     private ShortRefLinkParser() {}
 
     public static RefLinkPosition parseShortRefLink(JsonObject reflink) {
-        int id = parseIntMember(reflink, "id");
-        double position = parseDoubleMember(reflink, "posisjon");
+        int id = parseIntMember(reflink, "veglenkesekvensid");
+        double position = parseDoubleMember(reflink, "relativPosisjon");
         String shortName = parseStringMember(reflink, "kortform");
 
         return new RefLinkPosition(id, position, shortName);
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/StatusParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/StatusParser.java
index bbb3dfb..59d6f0b 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/gson/StatusParser.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/StatusParser.java
@@ -28,6 +28,7 @@ package no.vegvesen.nvdbapi.client.gson;
 import com.google.gson.JsonObject;
 import no.vegvesen.nvdbapi.client.model.Status;
 import no.vegvesen.nvdbapi.client.model.datakatalog.Version;
+import no.vegvesen.nvdbapi.client.model.transaction.TransactionId;
 
 import java.time.LocalDateTime;
 
@@ -36,9 +37,11 @@ import static no.vegvesen.nvdbapi.client.gson.GsonUtil.parseDateTimeMember;
 public class StatusParser {
 
     public static Status parseStatus(JsonObject obj) {
-        LocalDateTime date = parseDateTimeMember(obj, "datagrunnlag.sist_oppdatert");
-        Version version = DatakatalogVersionParser.parseVersion(obj.getAsJsonObject("datakatalog"));
+        JsonObject datagrunnlag = obj.get("datagrunnlag").getAsJsonObject();
+        LocalDateTime date = parseDateTimeMember(datagrunnlag, "sist_oppdatert");
+        TransactionId transactionId = TransactionIdParser.parseTransactionId(datagrunnlag.getAsJsonObject("sist_prosesserte_transaksjon"));
+        Version version = DatakatalogVersionParser.parseVersion(datagrunnlag.getAsJsonObject("datakatalog"));
 
-        return new Status(date, version);
+        return new Status(date, transactionId, version);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/TransactionIdParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/TransactionIdParser.java
new file mode 100644
index 0000000..a659026
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/TransactionIdParser.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.gson;
+
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.transaction.TransactionId;
+
+import java.time.LocalDateTime;
+
+public class TransactionIdParser {
+
+    public static TransactionId parseTransactionId(JsonObject obj) {
+
+        Integer id = GsonUtil.parseIntMember(obj, "transaksjonsid");
+        LocalDateTime date = GsonUtil.parseDateTimeMember(obj, "transaksjonstidspunkt");
+
+        return new TransactionId(id, date);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/gson/TransactionParser.java b/src/main/java/no/vegvesen/nvdbapi/client/gson/TransactionParser.java
new file mode 100644
index 0000000..c4f23f7
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/gson/TransactionParser.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.gson;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import no.vegvesen.nvdbapi.client.model.transaction.*;
+
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.util.ArrayList;
+import java.util.List;
+
+import static no.vegvesen.nvdbapi.client.gson.GsonUtil.*;
+
+public class TransactionParser {
+
+    public static Transaction parseTransaction(JsonObject obj) {
+        return new Transaction(
+            parseTransactionId(obj), parseIntMember(obj, "taskTypeId"), parseStringMember(obj, "brukerid"),
+            parseRoadObjects(obj.getAsJsonArray("objekter")));
+    }
+
+    private static TransactionId parseTransactionId(JsonObject obj){
+        Integer taskId = parseIntMember(obj, "taskId");
+        LocalDateTime dateTime = parseDateTimeMember(obj, "tidspunkt");
+        return new TransactionId(taskId, dateTime);
+    }
+
+    private static List<RoadObject> parseRoadObjects(JsonArray obj) {
+        List<RoadObject> roadObjects = new ArrayList<>();
+        if(obj != null) {
+            obj.forEach(e -> roadObjects.add(new RoadObject(
+                parseIntMember(e.getAsJsonObject(), "id"),
+                parseRoadObjectMetadata(e.getAsJsonObject().getAsJsonObject("metadata")),
+                Type.from(parseStringMember(e.getAsJsonObject(), "transaksjonstype_tekst")))));
+        }
+        return roadObjects;
+    }
+
+    private static RoadObjectMetadata parseRoadObjectMetadata(JsonObject obj) {
+        if(obj==null) return null;
+        Integer version = parseIntMember(obj, "versjon");
+        LocalDate startDate = parseDateMember(obj, "startdato");
+        LocalDate endDate = parseDateMember(obj, "sluttdato");
+        LocalDateTime lastModified = parseDateTimeMember(obj, "sist_modifisert");
+
+        return new RoadObjectMetadata(parseRoadObjectType(obj.getAsJsonObject("type")), version, startDate, endDate, lastModified);
+    }
+
+    private static RoadObjectType parseRoadObjectType(JsonObject obj) {
+        if(obj==null) return null;
+        int id = parseIntMember(obj, "id");
+        String name = parseStringMember(obj, "navn");
+
+        return new RoadObjectType(id, name);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Coordinates.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Coordinates.java
new file mode 100644
index 0000000..9aa6614
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Coordinates.java
@@ -0,0 +1,55 @@
+package no.vegvesen.nvdbapi.client.model;
+
+import java.util.Objects;
+
+public class Coordinates {
+    private final Projection projection;
+    private final double lat_easting;
+    private final double long_northing;
+
+    private Coordinates(Projection projection, double lat_easting, double long_northing) {
+        this.projection = projection;
+        this.lat_easting = lat_easting;
+        this.long_northing = long_northing;
+    }
+
+    public static Coordinates wgs84(double lat, double lng) {
+        return new Coordinates(Projection.WGS84, lat, lng);
+    }
+
+    public static Coordinates utm33(double easting, double northing) {
+        return new Coordinates(Projection.UTM33, easting, northing);
+    }
+
+    public Projection getProjection() {
+        return projection;
+    }
+
+    public double getLatEasting() {
+        return lat_easting;
+    }
+
+    public double getLongNorthing() {
+        return long_northing;
+    }
+
+    @Override
+    public String toString() {
+        return lat_easting + "," + long_northing;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Coordinates that = (Coordinates) o;
+        return Double.compare(that.lat_easting, lat_easting) == 0 &&
+            Double.compare(that.long_northing, long_northing) == 0 &&
+            Objects.equals(projection, that.projection);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(projection, lat_easting, long_northing);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Direction.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Direction.java
index fa780e0..6d32cd7 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/Direction.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Direction.java
@@ -25,8 +25,6 @@
 
 package no.vegvesen.nvdbapi.client.model;
 
-import java.util.Arrays;
-
 public enum Direction {
     WITH("MED"), AGAINST("MOT");
 
@@ -36,7 +34,17 @@ public enum Direction {
         this.apiValue = apiValue;
     }
 
+    public String getApiValue() {
+        return apiValue;
+    }
+
     public static Direction from(String apiValue) {
-        return Arrays.stream(values()).filter(d -> d.apiValue.equalsIgnoreCase(apiValue)).findAny().orElse(null);
+        if(WITH.apiValue.equalsIgnoreCase(apiValue)) {
+            return WITH;
+        } else if (AGAINST.apiValue.equalsIgnoreCase(apiValue)) {
+            return AGAINST;
+        } else {
+            return null;
+        }
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Geometry.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Geometry.java
index d2def89..966d959 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/Geometry.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Geometry.java
@@ -30,20 +30,28 @@ import java.util.Objects;
 public class Geometry {
     private final String wkt;
     private final Projection projection;
-    private final Quality quality;
+    private final GeometryAttributes geometryAttributes;
     private final boolean isSimplified;
     private final boolean isOwnGeometry;
 
     public Geometry(String wkt, Projection projection, boolean isSimplified, boolean isOwnGeometry) {
-        this(wkt, projection, null, isSimplified, isOwnGeometry);
+        this(wkt, projection, isSimplified, isOwnGeometry, null);
     }
 
-    public Geometry(String wkt, Projection projection, Quality quality, boolean isSimplified, boolean isOwnGeometry) {
+    public Geometry(String wkt,
+                    Projection projection,
+                    boolean isSimplified,
+                    boolean isOwnGeometry,
+                    GeometryAttributes geometryAttributes) {
         this.wkt = wkt;
         this.projection = projection;
-        this.quality = quality;
         this.isSimplified = isSimplified;
         this.isOwnGeometry = isOwnGeometry;
+        this.geometryAttributes = geometryAttributes;
+    }
+
+    public GeometryAttributes getGeometryAttributes() {
+        return geometryAttributes;
     }
 
     public boolean isSimplified() {
@@ -62,10 +70,6 @@ public class Geometry {
         return projection;
     }
 
-    public Quality getQuality() {
-        return quality;
-    }
-
     @Override
     public String toString() {
         return toString(true);
@@ -84,11 +88,11 @@ public class Geometry {
                 isOwnGeometry == geometry.isOwnGeometry &&
                 Objects.equals(wkt, geometry.wkt) &&
                 Objects.equals(projection, geometry.projection) &&
-                Objects.equals(quality, geometry.quality);
+                Objects.equals(geometryAttributes, geometry.geometryAttributes);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(wkt, projection, quality, isSimplified, isOwnGeometry);
+        return Objects.hash(wkt, projection, isSimplified, isOwnGeometry, geometryAttributes);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/GeometryAttributes.java b/src/main/java/no/vegvesen/nvdbapi/client/model/GeometryAttributes.java
new file mode 100644
index 0000000..ddf779e
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/GeometryAttributes.java
@@ -0,0 +1,137 @@
+package no.vegvesen.nvdbapi.client.model;
+
+import java.time.LocalDate;
+import java.util.Objects;
+
+public class GeometryAttributes {
+
+    private final LocalDate capturedDate;     //               indexed by: roadnet
+    private final LocalDate verifiedDate;     //               indexed by: roadnet & roadobject
+    private final LocalDate updatedDate;      //               indexed by: roadnet
+    private final String processHistory;      //
+    private final Integer municipality;       //               indexed by: roadnet
+    private final String medium;              //               indexed by: roadnet
+    private final String objectCode;         // (sosi name)
+    private final Integer classCode;          // (ltema)       indexed by: roadnet
+    private final Boolean referenceGeometry;  //
+    private final Double length;              //               indexed by: roadnet & roadobject
+    private final Integer heightRef;          //               indexed by: roadnet
+    private final Quality quality;
+
+    public GeometryAttributes(LocalDate capturedDate,
+                              LocalDate verifiedDate,
+                              LocalDate updatedDate,
+                              String processHistory,
+                              Integer municipality,
+                              String medium,
+                              String objectCode,
+                              Integer classCode,
+                              Boolean referenceGeometry,
+                              Double length,
+                              Integer heightRef,
+                              Quality quality) {
+        this.capturedDate = capturedDate;
+        this.verifiedDate = verifiedDate;
+        this.updatedDate = updatedDate;
+        this.processHistory = processHistory;
+        this.municipality = municipality;
+        this.medium = medium;
+        this.objectCode = objectCode;
+        this.classCode = classCode;
+        this.referenceGeometry = referenceGeometry;
+        this.length = length;
+        this.heightRef = heightRef;
+        this.quality = quality;
+    }
+
+    public LocalDate getCapturedDate() {
+        return capturedDate;
+    }
+
+    public LocalDate getVerifiedDate() {
+        return verifiedDate;
+    }
+
+    public LocalDate getUpdatedDate() {
+        return updatedDate;
+    }
+
+    public String getProcessHistory() {
+        return processHistory;
+    }
+
+    public Integer getMunicipality() {
+        return municipality;
+    }
+
+    public String getMedium() {
+        return medium;
+    }
+
+    public String getObjectCode() {
+        return objectCode;
+    }
+
+    public Integer getClassCode() {
+        return classCode;
+    }
+
+    public Boolean getReferenceGeometry() {
+        return referenceGeometry;
+    }
+
+    public Double getLength() {
+        return length;
+    }
+
+    public Integer getHeightRef() {
+        return heightRef;
+    }
+
+    public Quality getQuality() {
+        return quality;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        GeometryAttributes that = (GeometryAttributes) o;
+        return Objects.equals(capturedDate, that.capturedDate) &&
+            Objects.equals(verifiedDate, that.verifiedDate) &&
+            Objects.equals(updatedDate, that.updatedDate) &&
+            Objects.equals(processHistory, that.processHistory) &&
+            Objects.equals(municipality, that.municipality) &&
+            Objects.equals(medium, that.medium) &&
+            Objects.equals(objectCode, that.objectCode) &&
+            Objects.equals(classCode, that.classCode) &&
+            Objects.equals(referenceGeometry, that.referenceGeometry) &&
+            Objects.equals(length, that.length) &&
+            Objects.equals(heightRef, that.heightRef) &&
+            Objects.equals(quality, that.quality);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(capturedDate, verifiedDate, updatedDate, processHistory, municipality, medium,
+            objectCode, classCode, referenceGeometry, length, heightRef, quality);
+    }
+
+    @Override
+    public String toString() {
+        return "GeometryAttributes{" +
+            "capturedDate=" + capturedDate +
+            ", verifiedDate=" + verifiedDate +
+            ", updatedDate=" + updatedDate +
+            ", processHistory='" + processHistory + '\'' +
+            ", municipality=" + municipality +
+            ", medium='" + medium + '\'' +
+            ", objectCode='" + objectCode + '\'' +
+            ", classCode=" + classCode +
+            ", referenceGeometry=" + referenceGeometry +
+            ", length=" + length +
+            ", heightRef=" + heightRef +
+            ", quality=" + quality +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/LocationalType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/LocationalType.java
new file mode 100644
index 0000000..b5381e4
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/LocationalType.java
@@ -0,0 +1,27 @@
+package no.vegvesen.nvdbapi.client.model;
+
+import java.util.Arrays;
+
+public enum LocationalType {
+
+    POINT("Point"),
+    LINE("Line"),
+    UNKNOWN("Unknown");
+
+    private final String name;
+
+    LocationalType(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public static LocationalType from(String type) {
+        return Arrays.stream(values())
+            .filter(v -> v.name.equalsIgnoreCase(type))
+            .findAny()
+            .orElse(UNKNOWN);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Page.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Page.java
index 6e5b1f6..2bdf822 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/Page.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Page.java
@@ -47,14 +47,6 @@ public final class Page {
         return DEFAULT;
     }
 
-    public static Page subPage(int count, String start) {
-        return new Page(count, start);
-    }
-
-    public static Page subPage(int count, Integer start) {
-        return new Page(count, Optional.ofNullable(start).map(s -> s.toString()).orElse(null));
-    }
-
     public static Page count(Integer count) {
         Objects.requireNonNull(count, "Missing count argument!");
         if (count < 1) {
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Position.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Position.java
index d84648c..fbf52de 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/Position.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Position.java
@@ -25,7 +25,7 @@
 
 package no.vegvesen.nvdbapi.client.model;
 
-import no.vegvesen.nvdbapi.client.model.roadobjects.RoadRef;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
 
 import java.util.List;
 import java.util.Objects;
@@ -58,8 +58,8 @@ public class Position {
             return placement.getPoint();
         }
 
-        public RoadRef getRoadRef() {
-            return placement.getRoadRef();
+        public RoadSysRef getRoadRef() {
+            return placement.getRoadSysRef();
         }
 
         public RefLinkPosition getRefLink() {
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Projection.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Projection.java
index e374873..2ff8276 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/Projection.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Projection.java
@@ -26,14 +26,20 @@
 package no.vegvesen.nvdbapi.client.model;
 
 import java.io.Serializable;
-import java.util.Arrays;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.stream.Stream;
 
 public class Projection implements Serializable {
+    /**
+     * ETRS89 / UTM zone 33 + NN2000 height
+     * https://epsg.io/5973
+     */
     public static final Projection UTM33 = new Projection(5973, "utm33");
-    public static final Projection UTM33_32633 = new Projection(32633, "utm33");
+    /**
+     * WGS 84
+     * https://epsg.io/4326
+     */
     public static final Projection WGS84 = new Projection(4326, "wgs84");
 
     private final String alias;
@@ -76,6 +82,6 @@ public class Projection implements Serializable {
     }
 
     public static Optional<Projection> of(int srid) {
-        return Stream.of(UTM33, WGS84, UTM33_32633).filter(p -> p.getSrid() == srid).findAny();
+        return Stream.of(UTM33, WGS84).filter(p -> p.getSrid() == srid).findAny();
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Quality.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Quality.java
index 18f7768..9a4653a 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/Quality.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Quality.java
@@ -25,12 +25,9 @@
 
 package no.vegvesen.nvdbapi.client.model;
 
-import java.time.LocalDate;
 import java.util.Objects;
-import java.util.Optional;
 
 public class Quality {
-    private final Optional<LocalDate> verifiedDate;
     private final Integer method;
     private final Integer accuracy;
     private final Integer visibility;
@@ -38,8 +35,12 @@ public class Quality {
     private final Integer heightAccuracy;
     private final Integer tolerance;
 
-    public Quality(Integer method, Integer accuracy, Integer heightMethod, Integer heightAccuracy, Integer tolerance, Integer visibility, LocalDate verifiedDate) {
-        this.verifiedDate = Optional.ofNullable(verifiedDate);
+    public Quality(Integer method,
+                   Integer accuracy,
+                   Integer heightMethod,
+                   Integer heightAccuracy,
+                   Integer tolerance,
+                   Integer visibility) {
         this.method = method;
         this.accuracy = accuracy;
         this.visibility = visibility;
@@ -48,10 +49,6 @@ public class Quality {
         this.tolerance = tolerance;
     }
 
-    public Optional<LocalDate> getVerifiedDate() {
-        return verifiedDate;
-    }
-
     public Integer getMethod() {
         return method;
     }
@@ -81,17 +78,28 @@ public class Quality {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Quality quality = (Quality) o;
-        return method == quality.method &&
-                visibility == quality.visibility &&
-                heightAccuracy == quality.heightAccuracy &&
-                tolerance == quality.tolerance &&
-                Objects.equals(verifiedDate, quality.verifiedDate) &&
-                Objects.equals(accuracy, quality.accuracy) &&
-                Objects.equals(heightMethod, quality.heightMethod);
+        return Objects.equals(method, quality.method) &&
+            Objects.equals(accuracy, quality.accuracy) &&
+            Objects.equals(visibility, quality.visibility) &&
+            Objects.equals(heightMethod, quality.heightMethod) &&
+            Objects.equals(heightAccuracy, quality.heightAccuracy) &&
+            Objects.equals(tolerance, quality.tolerance);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(verifiedDate, method, accuracy, visibility, heightMethod, heightAccuracy, tolerance);
+        return Objects.hash(method, accuracy, visibility, heightMethod, heightAccuracy, tolerance);
+    }
+
+    @Override
+    public String toString() {
+        return "Quality{" +
+            "method=" + method +
+            ", accuracy=" + accuracy +
+            ", visibility=" + visibility +
+            ", heightMethod=" + heightMethod +
+            ", heightAccuracy=" + heightAccuracy +
+            ", tolerance=" + tolerance +
+            '}';
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/RefLinkPosition.java b/src/main/java/no/vegvesen/nvdbapi/client/model/RefLinkPosition.java
index 81b156e..aa97f33 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/RefLinkPosition.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/RefLinkPosition.java
@@ -29,17 +29,21 @@ import java.util.Objects;
 
 public class RefLinkPosition {
 
-    private final int id;
+    private final long id;
     private final double position;
     private final String shortName;
 
-    public RefLinkPosition(int id, double position, String shortName) {
+    public RefLinkPosition(long id, double position, String shortName) {
         this.id = id;
         this.position = position;
         this.shortName = shortName;
     }
 
-    public int getId() {
+    public RefLinkPosition(long id, double position) {
+        this(id, position, position + "@" + id);
+    }
+
+    public long getId() {
         return id;
     }
 
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/RoadPlacement.java b/src/main/java/no/vegvesen/nvdbapi/client/model/RoadPlacement.java
index 29c1be7..a1cb81d 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/RoadPlacement.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/RoadPlacement.java
@@ -25,24 +25,29 @@
 
 package no.vegvesen.nvdbapi.client.model;
 
-import no.vegvesen.nvdbapi.client.model.roadobjects.RoadRef;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
 
 import java.util.Objects;
 
 public class RoadPlacement {
 
-    private final RoadRef roadRef;
+    private final RoadSysRef roadSysRef;
     private final RefLinkPosition refLinkPosition;
     private final Geometry point;
+    private final Integer municipality;
 
-    public RoadPlacement(RoadRef roadRef, RefLinkPosition refLinkPosition, Geometry point) {
-        this.roadRef = roadRef;
+    public RoadPlacement(RoadSysRef roadSysRef,
+                         RefLinkPosition refLinkPosition,
+                         Geometry point,
+                         Integer municipality) {
+        this.roadSysRef = roadSysRef;
         this.refLinkPosition = refLinkPosition;
         this.point = point;
+        this.municipality = municipality;
     }
 
-    public RoadRef getRoadRef() {
-        return roadRef;
+    public RoadSysRef getRoadSysRef() {
+        return roadSysRef;
     }
 
     public RefLinkPosition getRefLinkPosition() {
@@ -53,10 +58,14 @@ public class RoadPlacement {
         return point;
     }
 
+    public Integer getMunicipality() {
+        return municipality;
+    }
+
     @Override
     public String toString() {
         return "RoadPlacement{" +
-                "roadRef=" + roadRef +
+                "roadSysRef=" + roadSysRef +
                 ", refLinkPosition=" + refLinkPosition +
                 ", point=" + point +
                 '}';
@@ -67,13 +76,14 @@ public class RoadPlacement {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         RoadPlacement that = (RoadPlacement) o;
-        return Objects.equals(roadRef, that.roadRef) &&
+        return Objects.equals(roadSysRef, that.roadSysRef) &&
                 Objects.equals(refLinkPosition, that.refLinkPosition) &&
-                Objects.equals(point, that.point);
+                Objects.equals(point, that.point) &&
+                Objects.equals(municipality, that.municipality);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(roadRef, refLinkPosition, point);
+        return Objects.hash(roadSysRef, refLinkPosition, point, municipality);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/SidePosition.java b/src/main/java/no/vegvesen/nvdbapi/client/model/SidePosition.java
index aa186b0..361ce6f 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/SidePosition.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/SidePosition.java
@@ -26,11 +26,13 @@
 package no.vegvesen.nvdbapi.client.model;
 
 import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
 
 public enum SidePosition {
     LEFT("V"),
     RIGHT("H"),
-    LEFT_AND_RIGHT("M"),
+    LEFT_AND_RIGHT("HV"),
     MIDDLE("M"),
     CROSSING("K"),
     MIDDLE_LEFT("MV"),
@@ -46,8 +48,14 @@ public enum SidePosition {
         this.apiValue = apiValue;
     }
 
+    private static Map<String, SidePosition> mapping = new HashMap<>();
     public static SidePosition from(String apiValue) {
-        return Arrays.stream(values()).filter(d -> d.apiValue.equalsIgnoreCase(apiValue)).findAny().orElse(null);
+        return mapping.computeIfAbsent(
+            apiValue,
+            v -> Arrays.stream(values())
+                .filter(d -> d.apiValue.equalsIgnoreCase(v))
+                .findAny()
+                .orElse(null));
     }
 
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/Status.java b/src/main/java/no/vegvesen/nvdbapi/client/model/Status.java
index 0901888..3d4024f 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/Status.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/Status.java
@@ -26,16 +26,19 @@
 package no.vegvesen.nvdbapi.client.model;
 
 import no.vegvesen.nvdbapi.client.model.datakatalog.Version;
+import no.vegvesen.nvdbapi.client.model.transaction.TransactionId;
 
 import java.time.LocalDateTime;
 
 public class Status {
 
     private final LocalDateTime lastUpdated;
+    private final TransactionId lastProcessedTransaction;
     private final Version datakatalogVersion;
 
-    public Status(LocalDateTime lastUpdated, Version datakatalogVersion) {
+    public Status(LocalDateTime lastUpdated, TransactionId lastProcessedTransaction, Version datakatalogVersion) {
         this.lastUpdated = lastUpdated;
+        this.lastProcessedTransaction = lastProcessedTransaction;
         this.datakatalogVersion = datakatalogVersion;
     }
 
@@ -43,6 +46,10 @@ public class Status {
         return lastUpdated;
     }
 
+    public TransactionId getLastProcessedTransaction() {
+        return lastProcessedTransaction;
+    }
+
     public Version getDatakatalogVersion() {
         return datakatalogVersion;
     }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/UtmCoordinates.java b/src/main/java/no/vegvesen/nvdbapi/client/model/UtmCoordinates.java
index 573a951..c903466 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/UtmCoordinates.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/UtmCoordinates.java
@@ -55,21 +55,15 @@ public final class UtmCoordinates implements Serializable {
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-
         UtmCoordinates that = (UtmCoordinates) o;
-
-        if (!northing.equals(that.northing)) return false;
-        if (!easting.equals(that.easting)) return false;
-        return altitude.equals(that.altitude);
-
+        return Objects.equals(northing, that.northing) &&
+            Objects.equals(easting, that.easting) &&
+            Objects.equals(altitude, that.altitude);
     }
 
     @Override
     public int hashCode() {
-        int result = northing.hashCode();
-        result = 31 * result + easting.hashCode();
-        result = 31 * result + altitude.hashCode();
-        return result;
+        return Objects.hash(northing, easting, altitude);
     }
 
     @Override
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/ContractArea.java b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/ContractArea.java
index 98901f7..57aa9bf 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/ContractArea.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/ContractArea.java
@@ -26,21 +26,28 @@
 package no.vegvesen.nvdbapi.client.model.areas;
 
 import java.io.Serializable;
+import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 
 public final class ContractArea implements Serializable {
 
-    private final Optional<RoadObjectId> id;
     private final Integer number;
     private final String name;
     private final String type;
+    private final List<RoadObjectId> objects;
+    private final List<Integer> counties;
+    private final List<Integer> municipalities;
 
-    public ContractArea(RoadObjectId id, Integer number, String name, String type) {
-        this.id = Optional.ofNullable(id);
+    public ContractArea(Integer number, String name, String type,
+                        List<RoadObjectId> objects,
+                        List<Integer> counties, List<Integer> municipalities) {
         this.number = number;
         this.name = name;
         this.type = type;
+        this.objects = objects;
+        this.counties = counties;
+        this.municipalities = municipalities;
     }
 
     public Optional<Integer> getNumber() {
@@ -55,19 +62,34 @@ public final class ContractArea implements Serializable {
         return type;
     }
 
+    public List<RoadObjectId> getObjects() {
+        return objects;
+    }
+
+    public List<Integer> getCounties() {
+        return counties;
+    }
+
+    public List<Integer> getMunicipalities() {
+        return municipalities;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         ContractArea that = (ContractArea) o;
-        return Objects.equals(id, that.id) &&
-                Objects.equals(number, that.number) &&
-                Objects.equals(name, that.name) &&
-                Objects.equals(type, that.type);
+        return
+            Objects.equals(number, that.number) &&
+            Objects.equals(name, that.name) &&
+            Objects.equals(type, that.type) &&
+            Objects.equals(objects, that.objects) &&
+            Objects.equals(counties, that.counties) &&
+            Objects.equals(municipalities, that.municipalities);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(id, number, name, type);
+        return Objects.hash(number, name, type, objects, counties, municipalities);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/County.java b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/County.java
index ab4fabf..dda8aa4 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/County.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/County.java
@@ -38,15 +38,13 @@ public final class County implements Serializable {
     private final String name;
     private final Optional<Geometry> boundingBox;
     private final Optional<Geometry> centerPoint;
-    private final int region;
 
-    public County(RoadObjectId id, int number, String name, Geometry boundingBox, Geometry centerPoint, int region) {
+    public County(RoadObjectId id, int number, String name, Geometry boundingBox, Geometry centerPoint) {
         this.id = Optional.ofNullable(id);
         this.number = number;
         this.name = name;
         this.boundingBox = Optional.ofNullable(boundingBox);
         this.centerPoint = Optional.ofNullable(centerPoint);
-        this.region = region;
     }
 
     public Optional<RoadObjectId> getId() {
@@ -69,17 +67,12 @@ public final class County implements Serializable {
         return centerPoint;
     }
 
-    public int getRegion() {
-        return region;
-    }
-
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         County county = (County) o;
         return number == county.number &&
-                region == county.region &&
                 Objects.equals(id, county.id) &&
                 Objects.equals(name, county.name) &&
                 Objects.equals(boundingBox, county.boundingBox) &&
@@ -88,6 +81,6 @@ public final class County implements Serializable {
 
     @Override
     public int hashCode() {
-        return Objects.hash(id, number, name, boundingBox, centerPoint, region);
+        return Objects.hash(id, number, name, boundingBox, centerPoint);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/ExtendedStreet.java b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/ExtendedStreet.java
new file mode 100644
index 0000000..594cf28
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/ExtendedStreet.java
@@ -0,0 +1,53 @@
+package no.vegvesen.nvdbapi.client.model.areas;
+
+import java.io.Serializable;
+import java.util.List;
+import java.util.Objects;
+
+public class ExtendedStreet extends Street implements Serializable {
+    private final int municipality;
+    private final List<RoadObjectId> objects;
+
+    public ExtendedStreet(String name,
+                          int streetCode,
+                          Boolean sideStreet,
+                          int municipality,
+                          List<RoadObjectId> objects) {
+        super(name, streetCode, sideStreet);
+        this.municipality = municipality;
+        this.objects = objects;
+    }
+
+
+    public int getMunicipality() {
+        return municipality;
+    }
+
+    public List<RoadObjectId> getObjects() {
+        return objects;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        ExtendedStreet street = (ExtendedStreet) o;
+        return municipality == street.municipality && Objects.equals(objects, street.objects);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), municipality, objects);
+    }
+
+    @Override
+    public String toString() {
+        return "Street{" +
+            "name='" + getName() + '\'' +
+            ", streetCode=" + getStreetCode() +
+            ", municipality=" + municipality +
+            ", objects=" + objects +
+            "} " + super.toString();
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Municipality.java b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Municipality.java
index 3b20f72..2c0bd8b 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Municipality.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Municipality.java
@@ -38,19 +38,21 @@ public final class Municipality implements Serializable {
     private final String name;
     private final Optional<Geometry> boundingBox;
     private final Optional<Geometry> centerPoint;
-    private final int region;
     private final int county;
-    private final int roadDepartment;
 
-    public Municipality(RoadObjectId id, int number, String name, int county, int region, Geometry boundingBox, Geometry centerPoint, int roadDepartment) {
+
+    public Municipality(RoadObjectId id,
+                        int number,
+                        String name,
+                        int county,
+                        Geometry boundingBox,
+                        Geometry centerPoint) {
         this.id = Optional.ofNullable(id);
         this.number = number;
         this.name = name;
         this.boundingBox = Optional.ofNullable(boundingBox);
         this.centerPoint = Optional.ofNullable(centerPoint);
-        this.region = region;
         this.county = county;
-        this.roadDepartment = roadDepartment;
     }
 
     public Optional<RoadObjectId> getId() {
@@ -73,27 +75,17 @@ public final class Municipality implements Serializable {
         return centerPoint;
     }
 
-    public int getRegion() {
-        return region;
-    }
-
     public int getCounty() {
         return county;
     }
 
-    public int getRoadDepartment() {
-        return roadDepartment;
-    }
-
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Municipality that = (Municipality) o;
         return number == that.number &&
-                region == that.region &&
                 county == that.county &&
-                roadDepartment == that.roadDepartment &&
                 Objects.equals(id, that.id) &&
                 Objects.equals(name, that.name) &&
                 Objects.equals(boundingBox, that.boundingBox) &&
@@ -102,6 +94,6 @@ public final class Municipality implements Serializable {
 
     @Override
     public int hashCode() {
-        return Objects.hash(id, number, name, boundingBox, centerPoint, region, county, roadDepartment);
+        return Objects.hash(id, number, name, boundingBox, centerPoint, county);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/RoadObjectId.java b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/RoadObjectId.java
index 0376f7e..bb6a08b 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/RoadObjectId.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/RoadObjectId.java
@@ -30,10 +30,16 @@ import java.util.Objects;
 public class RoadObjectId {
     private final int featureTypeId;
     private final long featureId;
+    private final Integer version;
 
     public RoadObjectId(int featureTypeId, long featureId) {
+        this(featureTypeId, featureId, null);
+    }
+
+    public RoadObjectId(int featureTypeId, long featureId, Integer version) {
         this.featureTypeId = featureTypeId;
         this.featureId = featureId;
+        this.version = version;
     }
 
     public int getFeatureTypeId() {
@@ -44,17 +50,31 @@ public class RoadObjectId {
         return featureId;
     }
 
+    public Integer getVersion() {
+        return version;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         RoadObjectId that = (RoadObjectId) o;
         return featureTypeId == that.featureTypeId &&
-                featureId == that.featureId;
+            featureId == that.featureId &&
+            Objects.equals(version, that.version);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(featureTypeId, featureId);
+        return Objects.hash(featureTypeId, featureId, version);
+    }
+
+    @Override
+    public String toString() {
+        return "RoadObjectId{" +
+            "featureTypeId=" + featureTypeId +
+            ", featureId=" + featureId +
+            (version == null ? "" : ", version=" + version) +
+            '}';
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Route.java b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Route.java
index 108901f..6f23bd6 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Route.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Route.java
@@ -26,27 +26,29 @@
 package no.vegvesen.nvdbapi.client.model.areas;
 
 import java.io.Serializable;
+import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
 
 public final class Route implements Serializable {
 
-    private final Optional<RoadObjectId> id;
     private final String number;
     private final String name;
     private final String description;
     private final String period;
+    private final List<RoadObjectId> objects;
+    private final List<Integer> counties;
+    private final List<Integer> municipalities;
 
-    public Route(RoadObjectId id, String number, String name, String description, String period) {
-        this.id = Optional.ofNullable(id);
+    public Route(String number, String name, String description, String period,
+                 List<RoadObjectId> objects,
+                 List<Integer> counties, List<Integer> municipalities) {
         this.number = number;
         this.name = name;
         this.description = description;
         this.period = period;
-    }
-
-    public Optional<RoadObjectId> getId() {
-        return id;
+        this.objects = objects;
+        this.counties = counties;
+        this.municipalities = municipalities;
     }
 
     public String getNumber() {
@@ -65,20 +67,31 @@ public final class Route implements Serializable {
         return period;
     }
 
+    public List<Integer> getCounties() {
+        return counties;
+    }
+
+    public List<Integer> getMunicipalities() {
+        return municipalities;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Route route = (Route) o;
-        return Objects.equals(id, route.id) &&
-                Objects.equals(number, route.number) &&
-                Objects.equals(name, route.name) &&
-                Objects.equals(description, route.description) &&
-                Objects.equals(period, route.period);
+        return
+            Objects.equals(number, route.number) &&
+            Objects.equals(name, route.name) &&
+            Objects.equals(description, route.description) &&
+            Objects.equals(period, route.period) &&
+            Objects.equals(objects, route.objects) &&
+            Objects.equals(counties, route.counties) &&
+            Objects.equals(municipalities, route.municipalities);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(id, number, name, description, period);
+        return Objects.hash(number, name, description, period, objects, counties, municipalities);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Street.java b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Street.java
new file mode 100644
index 0000000..379a412
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Street.java
@@ -0,0 +1,53 @@
+package no.vegvesen.nvdbapi.client.model.areas;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+public class Street implements Serializable {
+    private final String name;
+    private final int streetCode;
+    private final Boolean sideStreet;
+
+    public Street(String name,
+                  int streetCode,
+                  Boolean sideStreet) {
+        this.name = name;
+        this.streetCode = streetCode;
+        this.sideStreet = sideStreet;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public int getStreetCode() {
+        return streetCode;
+    }
+
+    public Boolean isSideStreet() {
+        return sideStreet;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Street that = (Street) o;
+        return streetCode == that.streetCode
+                && Objects.equals(name, that.name)
+                && sideStreet == that.sideStreet;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(name, streetCode, sideStreet);
+    }
+
+    @Override
+    public String toString() {
+        return "Street{" +
+            "name='" + name + '\'' +
+            ", streetCode=" + streetCode +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AbstractEnumAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AbstractEnumAttributeType.java
index c68504c..ad6c7f8 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AbstractEnumAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AbstractEnumAttributeType.java
@@ -29,44 +29,44 @@ import java.util.*;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-public abstract class AbstractEnumAttributeType extends AttributeType implements EnumAttributeType {
+public abstract class AbstractEnumAttributeType<T extends EnumValue> extends AttributeType implements EnumAttributeType<T> {
 
-    private final Set<EnumValue> values;
+    private final Set<T> values;
 
-    protected AbstractEnumAttributeType(AttributeCommonProperties props,
-                                        AttributeTypeParameters parameters, Set<EnumValue> values) {
-        super(props, parameters);
+    AbstractEnumAttributeType(AttributeCommonProperties props,
+                                        Set<T> values) {
+        super(props);
         this.values = Optional.ofNullable(values).orElse(Collections.emptySet());
     }
 
     @Override
-     public boolean isEnum() {
-        return !values.isEmpty();
-    }
-
-    @Override
-    public Set<EnumValue> getValues() {
+    public Set<T> getValues() {
         return values;
     }
 
     @Override
-    public EnumValue getValue(Integer id) {
-        return values().filter(v -> v.getId().equals(id)).findAny().orElse(null);
+    public T getValue(Integer id) {
+        return values()
+                .filter(v -> v.getId().equals(id))
+                .findAny()
+                .orElse(null);
     }
 
     @Override
-    public List<EnumValue> getValueList() {
+    public List<T> getValueList() {
         return new ArrayList<>(values);
     }
 
     @Override
-    public Stream<EnumValue> values() {
+    public Stream<T> values() {
         return values.stream();
     }
 
     @Override
-    public List<EnumValue> getSortedValuesList() {
-        return values.stream().sorted(Comparator.comparing(EnumValue::getSortNumber)).collect(Collectors.toList());
+    public List<T> getSortedValuesList() {
+        return values.stream()
+                .sorted(Comparator.comparing(EnumValue::getSortNumber))
+                .collect(Collectors.toList());
     }
 
     @Override
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AssociationRoleType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AssociationRoleType.java
new file mode 100644
index 0000000..9e173c3
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AssociationRoleType.java
@@ -0,0 +1,55 @@
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.time.LocalDate;
+
+public class AssociationRoleType extends AttributeType {
+
+    private final int affiliation;
+    private final int featureTypeId;
+    private final int insideParent;
+    private final LocalDate startDate;
+    private final LocalDate endDate;
+    private final int associationRequirement;
+    private final String associationRequirementComment;
+
+    public AssociationRoleType(AttributeCommonProperties props, int affiliation,
+                               int featureTypeId, int insideParent, LocalDate startDate, LocalDate endDate,
+                               int associationRequirement, String associationRequirementComment) {
+        super(props);
+        this.affiliation = affiliation;
+        this.featureTypeId = featureTypeId;
+        this.insideParent = insideParent;
+        this.startDate = startDate;
+        this.endDate = endDate;
+        this.associationRequirement = associationRequirement;
+        this.associationRequirementComment = associationRequirementComment;
+    }
+
+    public int getAffiliation() {
+        return affiliation;
+    }
+
+    public int getFeatureTypeId() {
+        return featureTypeId;
+    }
+
+    public int getInsideParent() {
+        return insideParent;
+    }
+
+    public LocalDate getStartDate() {
+        return startDate;
+    }
+
+    public LocalDate getEndDate() {
+        return endDate;
+    }
+
+    public int getAssociationRequirement() {
+        return associationRequirement;
+    }
+
+    public String getAssociationRequirementComment() {
+        return associationRequirementComment;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AssociationType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AssociationType.java
index 6c92101..6e8e182 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AssociationType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AssociationType.java
@@ -36,13 +36,23 @@ public class AssociationType implements Serializable {
     private final Affiliation affiliation;
     private final LocalDate validFrom;
 
+    // List associations
+    private Integer listId;
+    private Integer maxNumber;
+    private Integer minNumber;
+
     public AssociationType(Integer id, Integer featureTypeId, InsideParent insideParent, Affiliation affiliation,
-                           LocalDate validFrom) {
+                           LocalDate validFrom, Integer listId, Integer maxNumber, Integer minNumber) {
         this.id = id;
         this.featureTypeId = featureTypeId;
         this.insideParent = insideParent;
         this.affiliation = affiliation;
         this.validFrom = validFrom;
+
+        // List associations
+        this.listId = listId;
+        this.maxNumber = maxNumber;
+        this.minNumber = minNumber;
     }
 
     public Integer getId() {
@@ -61,6 +71,12 @@ public class AssociationType implements Serializable {
         return insideParent;
     }
 
+    public Integer getListId() { return listId; }
+
+    public Integer getMaxNumber() { return maxNumber; }
+
+    public Integer getMinNumber() { return minNumber; }
+
     public Affiliation getAffiliation() {
         return affiliation;
     }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeCommonProperties.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeCommonProperties.java
index acd8b75..a40fef9 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeCommonProperties.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeCommonProperties.java
@@ -26,13 +26,16 @@
 package no.vegvesen.nvdbapi.client.model.datakatalog;
 
 import java.time.LocalDate;
+import java.util.List;
+import java.util.Objects;
 
 public class AttributeCommonProperties {
     private final Integer id;
+    private final Integer category;
     private final String name;
+    private final String shortname;
     private final String description;
     private final DataType type;
-    private final boolean isList;
     private final Integer sortNumber;
     private final String requirementComment;
     private final AttributeType.Importance importance;
@@ -40,13 +43,54 @@ public class AttributeCommonProperties {
     private final String sosiNvdbName;
     private final Integer sensitiveLevel;
     private final LocalDate objectListDate;
+    private final LocalDate validTo;
+    private final Boolean readOnly;
+    private final String caption;
+    private final Integer complementaryattrtypeid;
+    private final String planviewreftext;
+    private final String heightreftext;
+    private final String referencesosi;
+    private final Boolean referencegeometry;
+    private final Integer reqheightref;
+    private final Double reqaccuracyplan;
+    private final Double reqaccuracyheight;
+    private final List<String> conditionalRequirements;
+    private final Boolean derived;
+    private final Boolean required;
 
-    public AttributeCommonProperties(Integer id, String name, String description, DataType type, boolean isList, Integer sortNumber, String requirementComment, AttributeType.Importance importance, String sosiName, String sosiNvdbName, Integer sensitiveLevel, LocalDate objectListDate) {
+    public AttributeCommonProperties(Integer id,
+                                     Integer category,
+                                     String name,
+                                     String shortname,
+                                     String description,
+                                     DataType type,
+                                     Integer sortNumber,
+                                     String requirementComment,
+                                     AttributeType.Importance importance,
+                                     String sosiName,
+                                     String sosiNvdbName,
+                                     Integer sensitiveLevel,
+                                     LocalDate objectListDate,
+                                     LocalDate validTo,
+                                     boolean readOnly,
+                                     String caption,
+                                     Integer complementaryattrtypeid,
+                                     String planviewreftext,
+                                     String heightreftext,
+                                     String referencesosi,
+                                     boolean referencegeometry,
+                                     Integer reqheightref,
+                                     Double reqaccuracyplan,
+                                     Double reqaccuracyheight,
+                                     List<String> conditionalRequirements,
+                                     Boolean derived,
+                                     Boolean required) {
         this.id = id;
+        this.category = category;
         this.name = name;
+        this.shortname = shortname;
         this.description = description;
         this.type = type;
-        this.isList = isList;
         this.sortNumber = sortNumber;
         this.requirementComment = requirementComment;
         this.importance = importance;
@@ -54,6 +98,20 @@ public class AttributeCommonProperties {
         this.sosiNvdbName = sosiNvdbName;
         this.sensitiveLevel = sensitiveLevel;
         this.objectListDate = objectListDate;
+        this.validTo = validTo;
+        this.readOnly = readOnly;
+        this.caption = caption;
+        this.complementaryattrtypeid = complementaryattrtypeid;
+        this.planviewreftext = planviewreftext;
+        this.heightreftext = heightreftext;
+        this.referencesosi = referencesosi;
+        this.referencegeometry = referencegeometry;
+        this.reqheightref = reqheightref;
+        this.reqaccuracyplan = reqaccuracyplan;
+        this.reqaccuracyheight = reqaccuracyheight;
+        this.conditionalRequirements = conditionalRequirements;
+        this.derived = derived;
+        this.required = required;
     }
 
     public Integer getId() {
@@ -72,10 +130,6 @@ public class AttributeCommonProperties {
         return type;
     }
 
-    public boolean isList() {
-        return isList;
-    }
-
     public Integer getSortNumber() {
         return sortNumber;
     }
@@ -103,4 +157,143 @@ public class AttributeCommonProperties {
     public LocalDate getObjectListDate() {
         return objectListDate;
     }
+
+    public Integer getCategory() {
+        return category;
+    }
+
+    public String getShortname() {
+        return shortname;
+    }
+
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    public String getCaption() {
+        return caption;
+    }
+
+    public Integer getComplementaryattrtypeid() {
+        return complementaryattrtypeid;
+    }
+
+    public String getPlanviewreftext() {
+        return planviewreftext;
+    }
+
+    public String getHeightreftext() {
+        return heightreftext;
+    }
+
+    public String getReferencesosi() {
+        return referencesosi;
+    }
+
+    public boolean isReferencegeometry() {
+        return referencegeometry;
+    }
+
+    public int getReqheightref() {
+        return reqheightref;
+    }
+
+    public double getReqaccuracyplan() {
+        return reqaccuracyplan;
+    }
+
+    public double getReqaccuracyheight() {
+        return reqaccuracyheight;
+    }
+
+    public List<String> getConditionalRequirements() {
+        return conditionalRequirements;
+    }
+
+    public LocalDate getValidTo() {
+        return validTo;
+    }
+
+    public Boolean getDerived() {
+        return derived;
+    }
+
+    public Boolean getRequired() {
+        return required;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        AttributeCommonProperties that = (AttributeCommonProperties) o;
+        return readOnly == that.readOnly &&
+            referencegeometry == that.referencegeometry &&
+            reqheightref.equals(that.reqheightref) &&
+            Double.compare(that.reqaccuracyplan, reqaccuracyplan) == 0 &&
+            Double.compare(that.reqaccuracyheight, reqaccuracyheight) == 0 &&
+            Objects.equals(id, that.id) &&
+            Objects.equals(category, that.category) &&
+            Objects.equals(name, that.name) &&
+            Objects.equals(shortname, that.shortname) &&
+            Objects.equals(description, that.description) &&
+            Objects.equals(type, that.type) &&
+            Objects.equals(sortNumber, that.sortNumber) &&
+            Objects.equals(requirementComment, that.requirementComment) &&
+            importance == that.importance &&
+            Objects.equals(sosiName, that.sosiName) &&
+            Objects.equals(sosiNvdbName, that.sosiNvdbName) &&
+            Objects.equals(sensitiveLevel, that.sensitiveLevel) &&
+            Objects.equals(objectListDate, that.objectListDate) &&
+            Objects.equals(validTo, that.validTo) &&
+            Objects.equals(caption, that.caption) &&
+            Objects.equals(complementaryattrtypeid, that.complementaryattrtypeid) &&
+            Objects.equals(planviewreftext, that.planviewreftext) &&
+            Objects.equals(heightreftext, that.heightreftext) &&
+            Objects.equals(referencesosi, that.referencesosi) &&
+            Objects.equals(conditionalRequirements, that.conditionalRequirements) &&
+            Objects.equals(derived, that.derived) &&
+            Objects.equals(required, that.required);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, category, name, shortname, description, type, sortNumber, requirementComment,
+            importance, sosiName, sosiNvdbName, sensitiveLevel, objectListDate, validTo, readOnly, caption,
+            complementaryattrtypeid, planviewreftext, heightreftext, referencesosi, referencegeometry, reqheightref,
+            reqaccuracyplan, reqaccuracyheight, conditionalRequirements, derived, required);
+    }
+
+    @Override
+    public String toString() {
+        return "AttributeCommonProperties{" +
+            "id=" + id +
+            ", category=" + category +
+            ", name='" + name + '\'' +
+            ", shortname='" + shortname + '\'' +
+            ", description='" + description + '\'' +
+            ", type=" + type +
+            ", sortNumber=" + sortNumber +
+            ", requirementComment='" + requirementComment + '\'' +
+            ", importance=" + importance +
+            ", sosiName='" + sosiName + '\'' +
+            ", sosiNvdbName='" + sosiNvdbName + '\'' +
+            ", sensitiveLevel=" + sensitiveLevel +
+            ", objectListDate=" + objectListDate +
+            ", validTo=" + validTo +
+            ", readOnly=" + readOnly +
+            ", caption='" + caption + '\'' +
+            ", complementaryattrtypeid=" + complementaryattrtypeid +
+            ", planviewreftext='" + planviewreftext + '\'' +
+            ", heightreftext='" + heightreftext + '\'' +
+            ", referencesosi='" + referencesosi + '\'' +
+            ", referencegeometry=" + referencegeometry +
+            ", reqheightref=" + reqheightref +
+            ", reqaccuracyplan=" + reqaccuracyplan +
+            ", reqaccuracyheight=" + reqaccuracyheight +
+            ", conditionalRequirements=" + conditionalRequirements +
+            ", derived=" + derived +
+            ", required=" + required +
+            '}';
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeType.java
index fbee33e..3194659 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeType.java
@@ -32,25 +32,27 @@ import java.util.Arrays;
 public abstract class AttributeType implements Serializable {
 
     private final AttributeCommonProperties props;
-    private final AttributeTypeParameters parameters;
 
-    protected AttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters) {
+    protected AttributeType(AttributeCommonProperties props) {
         this.props = props;
-        this.parameters = parameters;
-    }
-
-    public boolean isEnum() {
-        return false;
     }
 
     public Integer getId() {
         return props.getId();
     }
 
+    public Integer getCategoryId() {
+        return props.getCategory();
+    }
+
     public String getName() {
         return props.getName();
     }
 
+    public String getShortname() {
+        return props.getShortname();
+    }
+
     public String getDescription() {
         return props.getDescription();
     }
@@ -67,18 +69,10 @@ public abstract class AttributeType implements Serializable {
         return props.getType();
     }
 
-    public boolean isList() {
-        return props.isList();
-    }
-
     public LocalDate getObjectListDate() {
         return props.getObjectListDate();
     }
 
-    public AttributeTypeParameters getParameters() {
-        return parameters;
-    }
-
     public Integer getSortNumber() {
         return props.getSortNumber();
     }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeTypeCategory.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeTypeCategory.java
new file mode 100644
index 0000000..0e1f35a
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/AttributeTypeCategory.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+public class AttributeTypeCategory implements Serializable {
+    private final int id;
+    private final String name;
+    private final String shortName;
+    private final String description;
+    private final int sortNumber;
+
+    public AttributeTypeCategory(int id, String name, String shortName, String description, int sortNumber) {
+        this.id = id;
+        this.name = name;
+        this.shortName = shortName;
+        this.description = description;
+        this.sortNumber = sortNumber;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getShortName() {
+        return shortName;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public int getSortNumber() {
+        return sortNumber;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        AttributeTypeCategory that = (AttributeTypeCategory) o;
+        return id == that.id &&
+                sortNumber == that.sortNumber &&
+                Objects.equals(name, that.name) &&
+                Objects.equals(shortName, that.shortName) &&
+                Objects.equals(description, that.description);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, name, shortName, description, sortNumber);
+    }
+
+    @Override
+    public String toString() {
+        return "AttributeTypeCategory{" +
+                "id=" + id +
+                ", name='" + name + '\'' +
+                ", shortName='" + shortName + '\'' +
+                ", description='" + description + '\'' +
+                ", sortNumber=" + sortNumber +
+                '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BinaryObjectAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BinaryObjectAttributeType.java
index a97c048..8f3eccf 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BinaryObjectAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BinaryObjectAttributeType.java
@@ -27,7 +27,28 @@ package no.vegvesen.nvdbapi.client.model.datakatalog;
 
 public class BinaryObjectAttributeType extends AttributeType {
 
-    public BinaryObjectAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters) {
-        super(props, parameters);
+    private final String blobformat;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
+
+    public BinaryObjectAttributeType(AttributeCommonProperties props,
+                                     String blobformat, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props);
+        this.blobformat = blobformat;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
+    }
+
+    public String getBlobformat() {
+
+        return blobformat;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BooleanAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BooleanAttributeType.java
index a1d4c65..90ebcbf 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BooleanAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/BooleanAttributeType.java
@@ -27,14 +27,28 @@ package no.vegvesen.nvdbapi.client.model.datakatalog;
 
 public class BooleanAttributeType extends AttributeType {
     private final Boolean defaultValue;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
     public BooleanAttributeType(AttributeCommonProperties props,
-                                AttributeTypeParameters parameters, Boolean defaultValue) {
-        super(props, parameters);
+                                Boolean defaultValue,
+                                boolean isdirectionsensitive,
+                                boolean isextentsensitive) {
+        super(props);
         this.defaultValue = defaultValue;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public Boolean getDefaultValue() {
         return defaultValue;
     }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/CharacterAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/CharacterAttributeType.java
index c967762..bb38ea2 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/CharacterAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/CharacterAttributeType.java
@@ -28,14 +28,26 @@ package no.vegvesen.nvdbapi.client.model.datakatalog;
 public class CharacterAttributeType extends AttributeType {
 
     private final Character defaultValue;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
-    public CharacterAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters,
-                                  Character defaultValue) {
-        super(props, parameters);
+    public CharacterAttributeType(AttributeCommonProperties props,
+                                  Character defaultValue, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props);
         this.defaultValue = defaultValue;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public Character getDefaultValue() {
         return defaultValue;
     }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Datakatalog.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Datakatalog.java
index 237bbc0..c8290e8 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Datakatalog.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Datakatalog.java
@@ -25,19 +25,22 @@
 
 package no.vegvesen.nvdbapi.client.model.datakatalog;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 public class Datakatalog {
     private final List<FeatureType> featureTypes;
     private final Version version;
     private final List<Unit> units;
-    private final Map<Integer, DataType> dataTypes;
+    private final Map<String, DataType> dataTypes;
 
-    public Datakatalog(Version version, List<FeatureType> featureTypes, List<Unit> units, Map<Integer, DataType> dataTypes) {
+    public Datakatalog(Version version,
+                       List<FeatureType> featureTypes,
+                       List<Unit> units,
+                       Map<String, DataType> dataTypes) {
         this.version = version;
         this.featureTypes = featureTypes;
         this.units = units;
@@ -49,10 +52,10 @@ public class Datakatalog {
     }
 
     public List<DataType> getDataTypes() {
-        return dataTypes.entrySet().stream().map(kvp -> kvp.getValue()).collect(Collectors.toList());
+        return new ArrayList<>(this.dataTypes.values());
     }
 
-    public Map<Integer, DataType> getDataTypeMap() {
+    public Map<String, DataType> getDataTypeMap() {
         return dataTypes;
     }
 
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DateAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DateAttributeType.java
index aab2b40..683fafb 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DateAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DateAttributeType.java
@@ -31,13 +31,20 @@ public class DateAttributeType extends AttributeType {
     private final LocalDate defaultValue;
     private final LocalDate minValue;
     private final LocalDate maxValue;
+    private final String format;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
-    public DateAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters,
-                             LocalDate defaultValue, LocalDate minValue, LocalDate maxValue) {
-        super(props, parameters);
+    public DateAttributeType(AttributeCommonProperties props,
+                             LocalDate defaultValue, LocalDate minValue, LocalDate maxValue,
+                             String format, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props);
         this.defaultValue = defaultValue;
         this.minValue = minValue;
         this.maxValue = maxValue;
+        this.format = format;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public LocalDate getDefaultValue() {
@@ -51,4 +58,16 @@ public class DateAttributeType extends AttributeType {
     public LocalDate getMaxValue() {
         return maxValue;
     }
+
+    public String getFormat() {
+        return format;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleAttributeType.java
index 00623c5..0a7c2e5 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleAttributeType.java
@@ -25,9 +25,7 @@
 
 package no.vegvesen.nvdbapi.client.model.datakatalog;
 
-import java.util.Set;
-
-public class DoubleAttributeType extends AbstractEnumAttributeType {
+public class DoubleAttributeType extends AttributeType {
     private final Double defaultvalue;
     private final Double minValue;
     private final Double maxValue;
@@ -36,12 +34,23 @@ public class DoubleAttributeType extends AbstractEnumAttributeType {
     private final Integer fieldLength;
     private final Integer decimalCount;
     private final Unit unit;
+    private final Boolean complementarysign;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
     public DoubleAttributeType(AttributeCommonProperties props,
-                               AttributeTypeParameters parameters, Double defaultvalue, Double minValue, Double maxValue,
-                               Double absMinValue, Double absMaxValue, Integer fieldLength, Integer decimalCount, Unit unit,
-                               Set<EnumValue> values) {
-        super(props, parameters, values);
+                               Double defaultvalue,
+                               Double minValue,
+                               Double maxValue,
+                               Double absMinValue,
+                               Double absMaxValue,
+                               Integer fieldLength,
+                               Integer decimalCount,
+                               Unit unit,
+                               Boolean complementarysign,
+                               boolean isdirectionsensitive,
+                               boolean isextentsensitive) {
+        super(props);
         this.defaultvalue = defaultvalue;
         this.minValue = minValue;
         this.maxValue = maxValue;
@@ -50,6 +59,9 @@ public class DoubleAttributeType extends AbstractEnumAttributeType {
         this.fieldLength = fieldLength;
         this.decimalCount = decimalCount;
         this.unit = unit;
+        this.complementarysign = complementarysign;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public Double getDefaultvalue() {
@@ -83,4 +95,16 @@ public class DoubleAttributeType extends AbstractEnumAttributeType {
     public Unit getUnit() {
         return unit;
     }
+
+    public Boolean getComplementarysign() {
+        return complementarysign;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleEnumAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleEnumAttributeType.java
new file mode 100644
index 0000000..23b3099
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleEnumAttributeType.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.util.Set;
+
+public class DoubleEnumAttributeType extends AbstractEnumAttributeType<DoubleEnumValue> {
+    private final Double defaultvalue;
+    private final Double minValue;
+    private final Double maxValue;
+    private final Double absMinValue;
+    private final Double absMaxValue;
+    private final Integer fieldLength;
+    private final Integer decimalCount;
+    private final Unit unit;
+    private final Boolean complementarysign;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
+
+    public DoubleEnumAttributeType(AttributeCommonProperties props,
+                                   Double defaultvalue,
+                                   Double minValue,
+                                   Double maxValue,
+                                   Double absMinValue,
+                                   Double absMaxValue,
+                                   Integer fieldLength,
+                                   Integer decimalCount,
+                                   Unit unit,
+                                   Set<DoubleEnumValue> values,
+                                   Boolean complementarysign, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props, values);
+        this.defaultvalue = defaultvalue;
+        this.minValue = minValue;
+        this.maxValue = maxValue;
+        this.absMinValue = absMinValue;
+        this.absMaxValue = absMaxValue;
+        this.fieldLength = fieldLength;
+        this.decimalCount = decimalCount;
+        this.unit = unit;
+        this.complementarysign = complementarysign;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
+    }
+
+    public Double getDefaultvalue() {
+        return defaultvalue;
+    }
+
+    public Double getMinValue() {
+        return minValue;
+    }
+
+    public Double getMaxValue() {
+        return maxValue;
+    }
+
+    public Double getAbsMinValue() {
+        return absMinValue;
+    }
+
+    public Double getAbsMaxValue() {
+        return absMaxValue;
+    }
+
+    public Integer getFieldLength() {
+        return fieldLength;
+    }
+
+    public Integer getDecimalCount() {
+        return decimalCount;
+    }
+
+    public Unit getUnit() {
+        return unit;
+    }
+
+    public Boolean getComplementarysign() {
+        return complementarysign;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleEnumValue.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleEnumValue.java
new file mode 100644
index 0000000..ca0ae62
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/DoubleEnumValue.java
@@ -0,0 +1,19 @@
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.time.LocalDate;
+
+public class DoubleEnumValue extends EnumValue<Double> {
+    public DoubleEnumValue(Integer id,
+                           Integer sortNumber,
+                           Double value,
+                           String shortName,
+                           String description,
+                           LocalDate objectListDate,
+                           boolean isDefault,
+                           boolean isShortValueUsable,
+                           Integer shortValueLength,
+                           Integer complimentaryId) {
+        super(id, sortNumber, value, shortName, description, objectListDate, isDefault,
+                isShortValueUsable, shortValueLength, complimentaryId);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumAttributeType.java
index 2f549f0..575273d 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumAttributeType.java
@@ -29,17 +29,17 @@ import java.io.Serializable;
 import java.util.*;
 import java.util.stream.Stream;
 
-public interface EnumAttributeType extends Serializable {
+public interface EnumAttributeType<T extends EnumValue> extends Serializable {
 
-    EnumValue getValue(Integer id);
+    T getValue(Integer id);
 
-    Set<EnumValue> getValues();
+    Set<T> getValues();
 
-    List<EnumValue> getValueList();
+    List<T> getValueList();
 
-    Stream<EnumValue> values();
+    Stream<T> values();
 
-    List<EnumValue> getSortedValuesList();
+    List<T> getSortedValuesList();
 
     /**
      * @return The number of enum alternatives.
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumValue.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumValue.java
index 7508216..2920168 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumValue.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/EnumValue.java
@@ -28,21 +28,38 @@ package no.vegvesen.nvdbapi.client.model.datakatalog;
 import java.io.Serializable;
 import java.time.LocalDate;
 
-public final class EnumValue implements Serializable {
+public abstract class EnumValue<T> implements Serializable {
     private final Integer id;
     private final Integer sortNumber;
-    private final String name;
+    private final T value;
     private final String shortName;
     private final String description;
     private final LocalDate objectListDate;
+    private final boolean isDefault;
+    private final boolean isShortValueUsable;
+    private final Integer shortValueLength;
+    private final Integer complimentaryId;
 
-    public EnumValue(Integer id, Integer sortNumber, String name, String shortName, String description, LocalDate objectListDate) {
+    public EnumValue(Integer id,
+                     Integer sortNumber,
+                     T value,
+                     String shortName,
+                     String description,
+                     LocalDate objectListDate,
+                     boolean isDefault,
+                     boolean isShortValueUsable,
+                     Integer shortValueLength,
+                     Integer complimentaryId) {
         this.id = id;
         this.sortNumber = sortNumber;
-        this.name = name;
+        this.value = value;
         this.shortName = shortName;
         this.description = description;
         this.objectListDate = objectListDate;
+        this.isDefault = isDefault;
+        this.isShortValueUsable = isShortValueUsable;
+        this.shortValueLength = shortValueLength;
+        this.complimentaryId = complimentaryId;
     }
 
     public Integer getId() {
@@ -53,8 +70,8 @@ public final class EnumValue implements Serializable {
         return sortNumber;
     }
 
-    public String getName() {
-        return name;
+    public T getValue() {
+        return value;
     }
 
     public String getShortName() {
@@ -68,4 +85,20 @@ public final class EnumValue implements Serializable {
     public LocalDate getObjectListDate() {
         return objectListDate;
     }
+
+    public boolean isDefault() {
+        return isDefault;
+    }
+
+    public boolean isShortValueUsable() {
+        return isShortValueUsable;
+    }
+
+    public Integer getShortValueLength() {
+        return shortValueLength;
+    }
+
+    public Integer getComplimentaryId() {
+        return complimentaryId;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureType.java
index 64b8cec..7f75087 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureType.java
@@ -34,6 +34,7 @@ public final class FeatureType implements Serializable {
 
     private final Integer id;
     private final String name;
+    private final String shortname;
     private final String description;
     private final String instructions;
     private final String sosiName;
@@ -44,11 +45,45 @@ public final class FeatureType implements Serializable {
     private final List<AttributeType> attributeTypes;
     private final List<AssociationType> parents;
     private final List<AssociationType> children;
-    private final FeatureTypeParameters parameters;
-
-    public FeatureType(Integer id, String name, String description, List<AttributeType> attributeTypes, List<AssociationType> parents, List<AssociationType> children, String instructions, String sosiName, String sosiNvdbName, Integer sortNumber, LocalDate objectListDate, PlacementType placementType, FeatureTypeParameters featureTypeParameters) {
+    private final AttributeType locationalAttribute;
+
+    private final String status;
+    private final String mainCategory;
+    private final boolean abstractType;
+    private final boolean derived;
+    private final boolean needParent;
+    private final boolean measureSet;
+    private final boolean connectingLinkOk;
+    private final String additionalInformasion;
+    private final boolean sensitive;
+    private final boolean onlyOneVersion;
+
+    public FeatureType(Integer id,
+                       String name,
+                       String shortname,
+                       String description,
+                       List<AttributeType> attributeTypes,
+                       List<AssociationType> parents,
+                       List<AssociationType> children,
+                       String instructions, String sosiName,
+                       String sosiNvdbName,
+                       Integer sortNumber,
+                       LocalDate objectListDate,
+                       PlacementType placementType,
+                       AttributeType locationalAttribute,
+                       String status,
+                       String mainCategory,
+                       boolean onlyOneVersion,
+                       boolean abstractType,
+                       boolean derived,
+                       boolean needParent,
+                       boolean measureSet,
+                       boolean connectingLinkOk,
+                       String additionalInformasion,
+                       boolean sensitive) {
         this.id = id;
         this.name = name;
+        this.shortname = shortname;
         this.description = description;
         this.instructions = instructions;
         this.sosiName = sosiName;
@@ -56,10 +91,20 @@ public final class FeatureType implements Serializable {
         this.sortNumber = sortNumber;
         this.objectListDate = objectListDate;
         this.placementType = placementType;
-        this.parameters = featureTypeParameters;
         this.children = Optional.ofNullable(children).orElse(Collections.emptyList());
         this.parents = Optional.ofNullable(parents).orElse(Collections.emptyList());
         this.attributeTypes = Optional.ofNullable(attributeTypes).orElse(Collections.emptyList());
+        this.locationalAttribute = locationalAttribute;
+        this.status = status;
+        this.mainCategory = mainCategory;
+        this.onlyOneVersion = onlyOneVersion;
+        this.abstractType = abstractType;
+        this.derived = derived;
+        this.needParent = needParent;
+        this.measureSet = measureSet;
+        this.connectingLinkOk = connectingLinkOk;
+        this.additionalInformasion = additionalInformasion;
+        this.sensitive = sensitive;
     }
 
     public Integer getId() {
@@ -74,10 +119,6 @@ public final class FeatureType implements Serializable {
         return sosiNvdbName;
     }
 
-    public FeatureTypeParameters getParameters() {
-        return parameters;
-    }
-
     public Integer getSortNumber() {
         return sortNumber;
     }
@@ -102,6 +143,30 @@ public final class FeatureType implements Serializable {
         return sosiName;
     }
 
+    public String getShortname() {
+        return shortname;
+    }
+
+    public boolean isDerived() {
+        return derived;
+    }
+
+    public boolean isNeedParent() {
+        return needParent;
+    }
+
+    public boolean isMeasureSet() {
+        return measureSet;
+    }
+
+    public boolean isConnectingLinkOk() {
+        return connectingLinkOk;
+    }
+
+    public AttributeType getLocationalAttribute() {
+        return locationalAttribute;
+    }
+
     public AssociationType getAssociationType(Integer id) {
         return associationTypes().filter(at -> at.getId().equals(id)).findAny().orElse(null);
     }
@@ -118,6 +183,10 @@ public final class FeatureType implements Serializable {
         return Stream.concat(children.stream(), parents.stream());
     }
 
+    public boolean isSensitive() {
+        return sensitive;
+    }
+
     /**
      * Convenience method for retriving a specific attribute type
      *
@@ -137,7 +206,10 @@ public final class FeatureType implements Serializable {
      * @return the attribute type requested or null if not present
      */
     public <T extends AttributeType> T getAttributeType(Integer id, Class<T> clazz) {
-        return Optional.ofNullable(getAttributeType(id)).map(at -> clazz.cast(at)).orElse(null);
+        return Optional.ofNullable(getAttributeType(id))
+                .filter(clazz::isInstance)
+                .map(clazz::cast)
+                .orElse(null);
     }
 
     public List<AttributeType> getAttributeTypes() {
@@ -158,10 +230,31 @@ public final class FeatureType implements Serializable {
         return attributeTypes().sorted(Comparator.comparing(AttributeType::getSortNumber));
     }
 
+    public String getStatus() {
+        return status;
+    }
+
+    public String getMainCategory() {
+        return mainCategory;
+    }
+
+    public boolean isAbstractType() {
+        return abstractType;
+    }
+
+    public String getAdditionalInformasion() {
+        return additionalInformasion;
+    }
+
+    public boolean isOnlyOneVersion() {
+        return onlyOneVersion;
+    }
+
     public enum PlacementType {
         NONE("INGEN"),
         POINT("PUNKT"),
         LINE("LINJE"),
+        TURN("SVING"),
         MULTI_POINT("MULTIPUNKT");
 
         private final String name;
@@ -190,7 +283,10 @@ public final class FeatureType implements Serializable {
         }
 
         public static Relevant from(String text) {
-            return Arrays.asList(values()).stream().filter(s -> s.name.equalsIgnoreCase(text)).findAny().orElse(null);
+            return Arrays.stream(values())
+                    .filter(s -> s.name.equalsIgnoreCase(text))
+                    .findAny()
+                    .orElse(null);
         }
     }
 
@@ -206,7 +302,10 @@ public final class FeatureType implements Serializable {
         }
 
         public static Survivability from(String text) {
-            return Arrays.asList(values()).stream().filter(s -> s.name.equalsIgnoreCase(text)).findAny().orElse(null);
+            return Arrays.stream(values())
+                    .filter(s -> s.name.equalsIgnoreCase(text))
+                    .findAny()
+                    .orElse(null);
         }
     }
 
@@ -222,7 +321,10 @@ public final class FeatureType implements Serializable {
         }
 
         public static Splitability from(String text) {
-            return Arrays.asList(values()).stream().filter(s -> s.name.equalsIgnoreCase(text)).findAny().orElse(null);
+            return Arrays.stream(values())
+                    .filter(s -> s.name.equalsIgnoreCase(text))
+                    .findAny()
+                    .orElse(null);
         }
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureTypeCategory.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureTypeCategory.java
index a1e67d2..f4446b6 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureTypeCategory.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureTypeCategory.java
@@ -26,6 +26,7 @@ package no.vegvesen.nvdbapi.client.model.datakatalog;
 
 import java.io.Serializable;
 import java.time.LocalDate;
+import java.util.Objects;
 import java.util.Optional;
 
 public class FeatureTypeCategory implements Serializable {
@@ -35,14 +36,17 @@ public class FeatureTypeCategory implements Serializable {
     private final String description;
     private final int sortNumber;
     private final LocalDate startDate;
+    private final boolean isPrimary;
 
-    public FeatureTypeCategory(int id, String name, String shortName, String description, int sortNumber, LocalDate startDate) {
+    public FeatureTypeCategory(int id, String name, String shortName, String description,
+                               int sortNumber, LocalDate startDate, boolean isPrimary) {
         this.id = id;
         this.name = name;
         this.shortName = shortName;
         this.description = description;
         this.sortNumber = sortNumber;
         this.startDate = startDate;
+        this.isPrimary = isPrimary;
     }
 
     public int getId() {
@@ -69,30 +73,27 @@ public class FeatureTypeCategory implements Serializable {
         return Optional.ofNullable(startDate);
     }
 
+    public boolean isPrimary() {
+        return isPrimary;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-
         FeatureTypeCategory that = (FeatureTypeCategory) o;
-
-        if (id != that.id) return false;
-        if (sortNumber != that.sortNumber) return false;
-        if (!name.equals(that.name)) return false;
-        if (!shortName.equals(that.shortName)) return false;
-        if (!description.equals(that.description)) return false;
-        return startDate != null ? startDate.equals(that.startDate) : that.startDate == null;
+        return id == that.id &&
+                sortNumber == that.sortNumber &&
+                isPrimary == that.isPrimary &&
+                Objects.equals(name, that.name) &&
+                Objects.equals(shortName, that.shortName) &&
+                Objects.equals(description, that.description) &&
+                Objects.equals(startDate, that.startDate);
     }
 
     @Override
     public int hashCode() {
-        int result = id;
-        result = 31 * result + name.hashCode();
-        result = 31 * result + shortName.hashCode();
-        result = 31 * result + description.hashCode();
-        result = 31 * result + sortNumber;
-        result = 31 * result + (startDate != null ? startDate.hashCode() : 0);
-        return result;
+        return Objects.hash(id, name, shortName, description, sortNumber, startDate, isPrimary);
     }
 
     @Override
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureTypeParameters.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureTypeParameters.java
deleted file mode 100644
index b8db847..0000000
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/FeatureTypeParameters.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.vegvesen.nvdbapi.client.model.datakatalog;
-
-import java.io.Serializable;
-
-public class FeatureTypeParameters implements Serializable {
-
-    private final boolean timeRelevance;
-    private final Boolean sekType2Ok;
-    private final Boolean abstractType;
-    private final Boolean filtration;
-    private final Boolean derived;
-    private final Boolean parentRequired;
-    private final Boolean measureSet;
-    private final String coverage;
-
-    private final FeatureType.Relevant laneRelevance;
-    private final FeatureType.Relevant sidePositionRelevance;
-    private final Boolean directionRelevant;
-    private final Boolean heightRelevant;
-    private final Boolean overlaps;
-    private final Boolean movable;
-    private final FeatureType.Survivability ajourholdI;
-    private final FeatureType.Splitability ajourholdSplitt;
-
-    public FeatureTypeParameters(Boolean timeRelevance, Boolean sekType2Ok, Boolean abstractType, Boolean filtration,
-                                 Boolean derived, Boolean parentRequired, Boolean measureSet, String coverage,
-                                 FeatureType.Relevant laneRelevance,
-                                 FeatureType.Relevant sidePositionRelevance, Boolean directionRelevant,
-                                 Boolean heightRelevant, Boolean overlaps, Boolean movable,
-                                 FeatureType.Survivability ajourholdI,
-                                 FeatureType.Splitability ajourholdSplitt) {
-        this.timeRelevance = timeRelevance;
-        this.sekType2Ok = sekType2Ok;
-        this.abstractType = abstractType;
-        this.filtration = filtration;
-        this.derived = derived;
-        this.parentRequired = parentRequired;
-        this.measureSet = measureSet;
-        this.coverage = coverage;
-        this.laneRelevance = laneRelevance;
-        this.sidePositionRelevance = sidePositionRelevance;
-        this.directionRelevant = directionRelevant;
-        this.heightRelevant = heightRelevant;
-        this.overlaps = overlaps;
-        this.movable = movable;
-        this.ajourholdI = ajourholdI;
-        this.ajourholdSplitt = ajourholdSplitt;
-    }
-
-    public boolean isTimeRelevant() {
-        return timeRelevance;
-    }
-
-    public boolean isSekType2Ok() {
-        return sekType2Ok;
-    }
-
-    public boolean isAbstractType() {
-        return abstractType;
-    }
-
-    public boolean isFilteringOn() {
-        return filtration;
-    }
-
-    public boolean isDerived() {
-        return derived;
-    }
-
-    public boolean isParentRequired() {
-        return parentRequired;
-    }
-
-    public boolean isMeasureSet() {
-        return measureSet;
-    }
-
-    public String getCoverage() {
-        return coverage;
-    }
-
-    public FeatureType.Relevant getLaneRelevance() {
-        return laneRelevance;
-    }
-
-    public FeatureType.Relevant getSidePositionRelevance() {
-        return sidePositionRelevance;
-    }
-
-    public boolean isDirectionRelevant() {
-        return directionRelevant;
-    }
-
-    public boolean isHeightRelevant() {
-        return heightRelevant;
-    }
-
-    public boolean isOverlap() {
-        return overlaps;
-    }
-
-    public boolean isMovable() {
-        return movable;
-    }
-
-    public FeatureType.Survivability getSurvivability() {
-        return ajourholdI;
-    }
-
-    public FeatureType.Splitability getSplitability() {
-        return ajourholdSplitt;
-    }
-}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerAttributeType.java
index 8287610..80a63fb 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerAttributeType.java
@@ -25,9 +25,7 @@
 
 package no.vegvesen.nvdbapi.client.model.datakatalog;
 
-import java.util.Set;
-
-public class IntegerAttributeType extends AbstractEnumAttributeType {
+public class IntegerAttributeType extends AttributeType {
     private final Integer defaultvalue;
     private final Integer minValue;
     private final Integer maxValue;
@@ -35,11 +33,22 @@ public class IntegerAttributeType extends AbstractEnumAttributeType {
     private final Integer absMaxValue;
     private final Integer fieldLength;
     private final Unit unit;
+    private final Boolean complementarysign;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
-    public IntegerAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters,
-                                Integer defaultvalue, Integer minValue, Integer maxValue,
-                                Integer absMinValue, Integer absMaxValue, Integer fieldLength, Unit unit, Set<EnumValue> values) {
-        super(props, parameters, values);
+    public IntegerAttributeType(AttributeCommonProperties props,
+                                Integer defaultvalue,
+                                Integer minValue,
+                                Integer maxValue,
+                                Integer absMinValue,
+                                Integer absMaxValue,
+                                Integer fieldLength,
+                                Unit unit,
+                                Boolean complementarysign,
+                                boolean isdirectionsensitive,
+                                boolean isextentsensitive) {
+        super(props);
         this.defaultvalue = defaultvalue;
         this.minValue = minValue;
         this.maxValue = maxValue;
@@ -47,6 +56,9 @@ public class IntegerAttributeType extends AbstractEnumAttributeType {
         this.absMaxValue = absMaxValue;
         this.fieldLength = fieldLength;
         this.unit = unit;
+        this.complementarysign = complementarysign;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public Integer getDefaultvalue() {
@@ -76,4 +88,16 @@ public class IntegerAttributeType extends AbstractEnumAttributeType {
     public Unit getUnit() {
         return unit;
     }
+
+    public Boolean getComplementarysign() {
+        return complementarysign;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerEnumAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerEnumAttributeType.java
new file mode 100644
index 0000000..c38acd4
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerEnumAttributeType.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.util.Set;
+
+public class IntegerEnumAttributeType extends AbstractEnumAttributeType<IntegerEnumValue> {
+    private final Integer defaultvalue;
+    private final Integer minValue;
+    private final Integer maxValue;
+    private final Integer absMinValue;
+    private final Integer absMaxValue;
+    private final Integer fieldLength;
+    private final Unit unit;
+    private final Boolean complementarysign;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
+
+    public IntegerEnumAttributeType(AttributeCommonProperties props,
+                                    Integer defaultvalue,
+                                    Integer minValue,
+                                    Integer maxValue,
+                                    Integer absMinValue,
+                                    Integer absMaxValue,
+                                    Integer fieldLength,
+                                    Unit unit,
+                                    Set<IntegerEnumValue> values,
+                                    Boolean complementarysign, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props, values);
+        this.defaultvalue = defaultvalue;
+        this.minValue = minValue;
+        this.maxValue = maxValue;
+        this.absMinValue = absMinValue;
+        this.absMaxValue = absMaxValue;
+        this.fieldLength = fieldLength;
+        this.unit = unit;
+        this.complementarysign = complementarysign;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
+    }
+
+    public Integer getDefaultvalue() {
+        return defaultvalue;
+    }
+
+    public Integer getMinValue() {
+        return minValue;
+    }
+
+    public Integer getMaxValue() {
+        return maxValue;
+    }
+
+    public Integer getAbsMinValue() {
+        return absMinValue;
+    }
+
+    public Integer getAbsMaxValue() {
+        return absMaxValue;
+    }
+
+    public Integer getFieldLength() {
+        return fieldLength;
+    }
+
+    public Unit getUnit() {
+        return unit;
+    }
+
+    public Boolean getComplementarysign() {
+        return complementarysign;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerEnumValue.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerEnumValue.java
new file mode 100644
index 0000000..0a7d0e7
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/IntegerEnumValue.java
@@ -0,0 +1,19 @@
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.time.LocalDate;
+
+public class IntegerEnumValue extends EnumValue<Integer> {
+    public IntegerEnumValue(Integer id,
+                            Integer sortNumber,
+                            Integer value,
+                            String shortName,
+                            String description,
+                            LocalDate objectListDate,
+                            boolean isDefault,
+                            boolean isShortValueUsable,
+                            Integer shortValueLength,
+                            Integer complimentaryId) {
+        super(id, sortNumber, value, shortName, description, objectListDate, isDefault,
+                isShortValueUsable, shortValueLength, complimentaryId);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/JavaType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/JavaType.java
index 94adf60..2af2a46 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/JavaType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/JavaType.java
@@ -33,8 +33,10 @@ public enum JavaType {
     LOCAL_DATE,
     LOCAL_TIME,
     SHORT_DATE,
-    SPATIAL,
+    GEOMETRY,
     BINARY,
     STRUCTURE,
+    LIST,
+    ASSOCIATION,
     UNKNOWN
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/ListAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/ListAttributeType.java
new file mode 100644
index 0000000..9bff8b3
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/ListAttributeType.java
@@ -0,0 +1,26 @@
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+public class ListAttributeType extends AttributeType {
+
+    private final Integer max;
+    private final Integer min;
+    private final AttributeType content;
+
+    public ListAttributeType(AttributeCommonProperties props,
+                             AttributeType content,
+                             Integer min, Integer max) {
+        super(props);
+        this.min = min;
+        this.max = max;
+        this.content = content;
+    }
+
+    public AttributeType getContent() {
+        return content;
+    }
+
+    public Integer getMax() { return max; }
+
+    public Integer getMin() { return min; }
+
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/LocationalAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/LocationalAttributeType.java
new file mode 100644
index 0000000..18cd162
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/LocationalAttributeType.java
@@ -0,0 +1,71 @@
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import no.vegvesen.nvdbapi.client.model.LocationalType;
+
+public class LocationalAttributeType extends AttributeType {
+
+    private final LocationalType locationalType;
+    private final Boolean overlapp;
+    private final String laneRelevant;
+    private final String sideposRelevant;
+    private final String ajourholdi;
+    private final String ajourholdsplitt;
+    private final String overlappsautomatikk;
+    private final boolean insideparent;
+    private final Boolean directionRelevant;
+
+
+    public LocationalAttributeType(AttributeCommonProperties props,
+                                   LocationalType locationalType, Boolean overlapp, String laneRelevant,
+                                   String sideposRelevant,
+                                   String ajourholdi, String ajourholdsplitt,
+                                   boolean insideparent, String overlappsautomatikk,
+                                   Boolean directionRelevant) {
+        super(props);
+        this.locationalType = locationalType;
+        this.overlapp = overlapp;
+        this.laneRelevant = laneRelevant;
+        this.sideposRelevant = sideposRelevant;
+        this.ajourholdi = ajourholdi;
+        this.ajourholdsplitt = ajourholdsplitt;
+        this.insideparent = insideparent;
+        this.overlappsautomatikk = overlappsautomatikk;
+        this.directionRelevant = directionRelevant;
+    }
+
+    public LocationalType getLocationalType() {
+        return locationalType;
+    }
+
+    public Boolean getOverlapp() {
+        return overlapp;
+    }
+
+    public String getLaneRelevant() {
+        return laneRelevant;
+    }
+
+    public String getSideposRelevant() {
+        return sideposRelevant;
+    }
+
+    public String getAjourholdi() {
+        return ajourholdi;
+    }
+
+    public String getAjourholdsplitt() {
+        return ajourholdsplitt;
+    }
+
+    public boolean isInsideparent() {
+        return insideparent;
+    }
+
+    public String getOverlappsautomatikk() {
+        return overlappsautomatikk;
+    }
+
+    public Boolean isDirectionRelevant() {
+        return directionRelevant;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/ShortDateAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/ShortDateAttributeType.java
index 9affcd8..13e67e7 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/ShortDateAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/ShortDateAttributeType.java
@@ -29,14 +29,20 @@ public class ShortDateAttributeType extends AttributeType {
     private final Integer defaultvalue;
     private final Integer minValue;
     private final Integer maxValue;
+    private final String format;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
     public ShortDateAttributeType(AttributeCommonProperties props,
-                                  AttributeTypeParameters parameters,
-                                  Integer defaultvalue, Integer minValue, Integer maxValue) {
-        super(props, parameters);
+                                  Integer defaultvalue, Integer minValue, Integer maxValue,
+                                  String format, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props);
         this.defaultvalue = defaultvalue;
         this.minValue = minValue;
         this.maxValue = maxValue;
+        this.format = format;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public Integer getDefaultvalue() {
@@ -50,4 +56,16 @@ public class ShortDateAttributeType extends AttributeType {
     public Integer getMaxValue() {
         return maxValue;
     }
+
+    public String getFormat() {
+        return format;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/SpatialAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/SpatialAttributeType.java
index 1c3ba31..ceaa2e8 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/SpatialAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/SpatialAttributeType.java
@@ -30,13 +30,28 @@ import no.vegvesen.nvdbapi.client.model.SpatialType;
 public class SpatialAttributeType extends AttributeType {
 
     private final SpatialType spatialType;
+    private final int dimensions;
+    private final boolean insideparent;
 
-    public SpatialAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters, SpatialType spatialType) {
-        super(props, parameters);
+    public SpatialAttributeType(AttributeCommonProperties props,
+                                SpatialType spatialType,
+                                int dimensions,
+                                boolean insideparent) {
+        super(props);
         this.spatialType = spatialType;
+        this.dimensions = dimensions;
+        this.insideparent = insideparent;
     }
 
     public SpatialType getSpatialType() {
         return spatialType;
     }
+
+    public int getDimensions() {
+        return dimensions;
+    }
+
+    public boolean isInsideparent() {
+        return insideparent;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringAttributeType.java
index 194518d..e127755 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringAttributeType.java
@@ -25,18 +25,26 @@
 
 package no.vegvesen.nvdbapi.client.model.datakatalog;
 
-import java.util.Set;
-
-public class StringAttributeType extends AbstractEnumAttributeType {
+public class StringAttributeType extends AttributeType {
 
     private final Integer fieldLength;
     private final String defaultValue;
+    private final String format;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
-    public StringAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters,
-                               String defaultValue, Integer fieldLength, Set<EnumValue> values) {
-        super(props, parameters, values);
+    public StringAttributeType(AttributeCommonProperties props,
+                               String defaultValue,
+                               Integer fieldLength,
+                               String format,
+                               boolean isdirectionsensitive,
+                               boolean isextentsensitive) {
+        super(props);
         this.defaultValue = defaultValue;
         this.fieldLength = fieldLength;
+        this.format = format;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public String getDefaultValue() {
@@ -46,4 +54,16 @@ public class StringAttributeType extends AbstractEnumAttributeType {
     public Integer getFieldLength() {
         return fieldLength;
     }
+
+    public String getFormat() {
+        return format;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringEnumAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringEnumAttributeType.java
new file mode 100644
index 0000000..270680b
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringEnumAttributeType.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.util.Set;
+
+public class StringEnumAttributeType extends AbstractEnumAttributeType<StringEnumValue> {
+
+    private final Integer fieldLength;
+    private final String defaultValue;
+    private final String format;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
+
+    public StringEnumAttributeType(AttributeCommonProperties props,
+                                   String defaultValue,
+                                   Integer fieldLength,
+                                   Set<StringEnumValue> values,
+                                   String format, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props, values);
+        this.defaultValue = defaultValue;
+        this.fieldLength = fieldLength;
+        this.format = format;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
+    }
+
+    public String getDefaultValue() {
+        return defaultValue;
+    }
+
+    public Integer getFieldLength() {
+        return fieldLength;
+    }
+
+    public String getFormat() {
+        return format;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringEnumValue.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringEnumValue.java
new file mode 100644
index 0000000..288ab31
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StringEnumValue.java
@@ -0,0 +1,19 @@
+package no.vegvesen.nvdbapi.client.model.datakatalog;
+
+import java.time.LocalDate;
+
+public class StringEnumValue extends EnumValue<String> {
+    public StringEnumValue(Integer id,
+                           Integer sortNumber,
+                           String value,
+                           String shortName,
+                           String description,
+                           LocalDate objectListDate,
+                           boolean isDefault,
+                           boolean isShortValueUsable,
+                           Integer shortValueLength,
+                           Integer complimentaryId) {
+        super(id, sortNumber, value, shortName, description, objectListDate, isDefault,
+                isShortValueUsable, shortValueLength, complimentaryId);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StructureAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StructureAttributeType.java
index 1ea61ef..ff9117e 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StructureAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/StructureAttributeType.java
@@ -27,8 +27,8 @@ package no.vegvesen.nvdbapi.client.model.datakatalog;
 
 public class StructureAttributeType extends AttributeType {
 
-    public StructureAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters) {
-        super(props, parameters);
+    public StructureAttributeType(AttributeCommonProperties props) {
+        super(props);
     }
 }
 
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/TimeAttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/TimeAttributeType.java
index cd21be8..dfa6ce0 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/TimeAttributeType.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/TimeAttributeType.java
@@ -32,13 +32,20 @@ public class TimeAttributeType extends AttributeType {
     private final LocalTime defaultvalue;
     private final LocalTime minValue;
     private final LocalTime maxValue;
+    private final String format;
+    private final boolean isdirectionsensitive;
+    private final boolean isextentsensitive;
 
-    public TimeAttributeType(AttributeCommonProperties props, AttributeTypeParameters parameters,
-                             LocalTime defaultvalue, LocalTime minValue, LocalTime maxValue) {
-        super(props, parameters);
+    public TimeAttributeType(AttributeCommonProperties props,
+                             LocalTime defaultvalue, LocalTime minValue, LocalTime maxValue,
+                             String format, boolean isdirectionsensitive, boolean isextentsensitive) {
+        super(props);
         this.defaultvalue = defaultvalue;
         this.minValue = minValue;
         this.maxValue = maxValue;
+        this.format = format;
+        this.isdirectionsensitive = isdirectionsensitive;
+        this.isextentsensitive = isextentsensitive;
     }
 
     public LocalTime getDefaultvalue() {
@@ -52,4 +59,16 @@ public class TimeAttributeType extends AttributeType {
     public LocalTime getMaxValue() {
         return maxValue;
     }
+
+    public String getFormat() {
+        return format;
+    }
+
+    public boolean isIsdirectionsensitive() {
+        return isdirectionsensitive;
+    }
+
+    public boolean isIsextentsensitive() {
+        return isextentsensitive;
+    }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Unit.java b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Unit.java
index 0dfe10e..94415fa 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Unit.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/datakatalog/Unit.java
@@ -26,6 +26,7 @@
 package no.vegvesen.nvdbapi.client.model.datakatalog;
 
 import java.io.Serializable;
+import java.util.Objects;
 
 public final class Unit implements Serializable {
 
@@ -55,21 +56,15 @@ public final class Unit implements Serializable {
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-
         Unit unit = (Unit) o;
-
-        if (id != unit.id) return false;
-        if (name != null ? !name.equals(unit.name) : unit.name != null) return false;
-        return !(shortName != null ? !shortName.equals(unit.shortName) : unit.shortName != null);
-
+        return id == unit.id &&
+            Objects.equals(name, unit.name) &&
+            Objects.equals(shortName, unit.shortName);
     }
 
     @Override
     public int hashCode() {
-        int result = id;
-        result = 31 * result + (name != null ? name.hashCode() : 0);
-        result = 31 * result + (shortName != null ? shortName.hashCode() : 0);
-        return result;
+        return Objects.hash(id, name, shortName);
     }
 
     @Override
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/DetailLevel.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/DetailLevel.java
new file mode 100644
index 0000000..837f3e0
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/DetailLevel.java
@@ -0,0 +1,41 @@
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static java.util.Objects.isNull;
+
+public enum DetailLevel {
+
+    VEGTRASE("VT", "Vegtrase"),
+    KJOREBANE("KB", "Kjørebane"),
+    KJOREFELT("KF", "Kjørefelt"),
+    VEGTRASE_OG_KJOREBANE("VTKB", "Vegtrase og kjørebane"),
+    UKJENT("UKJENT", "Ukjent");
+
+    private final String detailLevelShort;
+    private final String detailLevelText;
+
+    DetailLevel(String detailLevelShort, String detailLevelText) {
+        this.detailLevelShort = detailLevelShort;
+        this.detailLevelText = detailLevelText;
+    }
+
+    private static Map<String, DetailLevel> mapping =
+            Stream.of(values()).collect(Collectors.toMap(k -> k.detailLevelText.toLowerCase(), Function.identity()));
+
+    public static DetailLevel fromTextValue(String detailLevel) {
+        if (isNull(detailLevel)) return UKJENT;
+        return mapping.getOrDefault(detailLevel.toLowerCase(), UKJENT);
+    }
+
+    public String getSosi() {
+        return detailLevelShort;
+    }
+
+    public String getDetailLevelText() {
+        return detailLevelText;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Link.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Link.java
index 23b5bd4..1f0fa26 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Link.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Link.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2017, Statens vegvesen
+ * Copyright (c) 2015-2018, Statens vegvesen
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,130 +26,146 @@
 package no.vegvesen.nvdbapi.client.model.roadnet;
 
 import no.vegvesen.nvdbapi.client.model.Geometry;
-import no.vegvesen.nvdbapi.client.model.roadobjects.RoadRef;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RefLinkExtentPlacement;
 
-import java.io.Serializable;
 import java.time.LocalDate;
+import java.util.List;
 import java.util.Objects;
-import java.util.Optional;
 
-public final class Link implements Serializable {
+public class Link {
 
-    private final Geometry geometry;
-    private final long id;
-    private final Long superLinkId;
-    private final double start;
-    private final double end;
-    private final SosiMedium medium;
-    private final Ltema ltema;
+    private final Integer partId;
+    private final LinkType linkType;
     private final TopologyLevel topologyLevel;
-    private final Integer county;
+    private final Integer startPort;
+    private final Integer endPort;
+    private final Double startPos;
+    private final Double endPos;
     private final Integer municipality;
-    private final Integer region;
-    private final Integer roadDepartment;
-    private final RoadRef roadRef;
-    private final boolean isConnectionLink;
-    private final LocalDate fromDate;
-    private final LocalDate toDate;
-    private final String startNode;
-    private final String endNode;
-
-    public Link(long id, Long superLinkId, double start, double end,
-                String startNode, String endNode,
-                LocalDate fromDate, LocalDate toDate,
-                SosiMedium medium, Ltema ltema, TopologyLevel level, Integer region, Integer county,
-                Integer municipality, Integer roadDepartment,
-                Geometry geometry, RoadRef roadRef, boolean isConnectionLink) {
-        this.id = id;
-        this.superLinkId = superLinkId;
-        this.start = start;
-        this.end = end;
-        this.medium = medium;
-        this.ltema = ltema;
-        this.topologyLevel = level;
-        this.county = county;
+    private final Integer municipalityGeometry;
+    private final Double length;
+    private final String measureMethod;
+    private final LocalDate measureDate;
+    private final SosiMedium sosiMedium;
+    private final Ltema ltema;
+    private final RefLinkExtentPlacement centerLineProjection;
+    private final TypeOfRoad typeRoad;
+    private final String detailLevel;
+    private final Geometry geometry;
+    private final List<String> fields;
+    private final LocalDate startDate;
+    private final LocalDate endDate;
+
+    public Link(Integer partId, LinkType linkType, TopologyLevel topologyLevel,
+                Integer startPort, Integer endPort, Double startPos, Double endPos, Integer municipality,
+                Integer municipalityGeometry, Double length, String measureMethod, LocalDate measureDate,
+                SosiMedium sosiMedium, Ltema ltema, RefLinkExtentPlacement centerLineProjection, TypeOfRoad typeRoad,
+                String detailLevel, Geometry geometry, List<String> fields, LocalDate startDate, LocalDate endDate) {
+        this.partId = partId;
+        this.linkType = linkType;
+        this.topologyLevel = topologyLevel;
+        this.startPort = startPort;
+        this.endPort = endPort;
+        this.startPos = startPos;
+        this.endPos = endPos;
         this.municipality = municipality;
-        this.region = region;
-        this.fromDate = fromDate;
-        this.toDate = toDate;
-        this.roadDepartment = roadDepartment;
-        this.startNode = startNode;
-        this.endNode = endNode;
-        this.roadRef = roadRef;
-        this.isConnectionLink = isConnectionLink;
+        this.municipalityGeometry = municipalityGeometry;
+        this.length = length;
+        this.measureMethod = measureMethod;
+        this.measureDate = measureDate;
+        this.sosiMedium = sosiMedium;
+        this.ltema = ltema;
+        this.centerLineProjection = centerLineProjection;
+        this.typeRoad = typeRoad;
+        this.detailLevel = detailLevel;
         this.geometry = geometry;
+        this.fields = fields;
+        this.startDate = startDate;
+        this.endDate = endDate;
     }
 
-    public long getId() {
-        return id;
+    public Integer getPartId() {
+        return partId;
     }
 
-    public Optional<Long> getSuperLinkId() {
-        return Optional.ofNullable(superLinkId);
+    public LinkType getLinkType() {
+        return linkType;
     }
 
-    public boolean isConnectionLink() {
-        return isConnectionLink;
+    public TopologyLevel getTopologyLevel() {
+        return topologyLevel;
     }
 
-    public double getStart() {
-        return start;
+    public Integer getStartPort() {
+        return startPort;
     }
 
-    public double getEnd() {
-        return end;
+    public Integer getEndPort() {
+        return endPort;
     }
 
-    public SosiMedium getMedium() {
-        return medium;
+    public Double getStartPos() {
+        return startPos;
     }
 
-    public Ltema getLtema() {
-        return ltema;
+    public Double getEndPos() {
+        return endPos;
     }
 
-    public TopologyLevel getTopologyLevel() {
-        return topologyLevel;
+    public Integer getMunicipality() {
+        return municipality;
     }
 
-    public RoadRef getRoadRef() {
-        return roadRef;
+    public Double getLength() {
+        return length;
     }
 
-    public Integer getCounty() {
-        return county;
+    public SosiMedium getSosiMedium() {
+        return sosiMedium;
     }
 
-    public Integer getMunicipality() {
-        return municipality;
+    public Ltema getLtema() {
+        return ltema;
+    }
+
+    public RefLinkExtentPlacement getCenterLineProjection() {
+        return centerLineProjection;
+    }
+
+    public TypeOfRoad getTypeRoad() {
+        return typeRoad;
+    }
+
+    public Geometry getGeometry() {
+        return geometry;
     }
 
-    public Integer getRegion() {
-        return region;
+    public List<String> getFields() {
+        return fields;
     }
 
-    public Integer getRoadDepartment() {
-        return roadDepartment;
+    public LocalDate getStartDate() {
+        return startDate;
     }
 
-    public LocalDate getFromDate() {
-        return fromDate;
+    public LocalDate getEndDate() {
+        return endDate;
     }
 
-    public LocalDate getToDate() {
-        return toDate;
+    public Integer getMunicipalityGeometry() {
+        return municipalityGeometry;
     }
 
-    public String getEndNode() {
-        return endNode;
+    public String getMeasureMethod() {
+        return measureMethod;
     }
 
-    public String getStartNode() {
-        return startNode;
+    public LocalDate getMeasureDate() {
+        return measureDate;
     }
 
-    public Optional<Geometry> getGeometry() {
-        return Optional.ofNullable(geometry);
+    public String getDetailLevel() {
+        return detailLevel;
     }
 
     @Override
@@ -157,29 +173,59 @@ public final class Link implements Serializable {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Link link = (Link) o;
-        return id == link.id &&
-                Double.compare(link.start, start) == 0 &&
-                Double.compare(link.end, end) == 0 &&
-                isConnectionLink == link.isConnectionLink &&
-                Objects.equals(geometry, link.geometry) &&
-                Objects.equals(superLinkId, link.superLinkId) &&
-                medium == link.medium &&
-                ltema == link.ltema &&
+        return Objects.equals(partId, link.partId) &&
+                linkType == link.linkType &&
                 topologyLevel == link.topologyLevel &&
-                Objects.equals(county, link.county) &&
+                Objects.equals(startPort, link.startPort) &&
+                Objects.equals(endPort, link.endPort) &&
+                Objects.equals(startPos, link.startPos) &&
+                Objects.equals(endPos, link.endPos) &&
                 Objects.equals(municipality, link.municipality) &&
-                Objects.equals(region, link.region) &&
-                Objects.equals(roadDepartment, link.roadDepartment) &&
-                Objects.equals(roadRef, link.roadRef) &&
-                Objects.equals(fromDate, link.fromDate) &&
-                Objects.equals(toDate, link.toDate) &&
-                Objects.equals(startNode, link.startNode) &&
-                Objects.equals(endNode, link.endNode);
+                Objects.equals(municipalityGeometry, link.municipalityGeometry) &&
+                Objects.equals(length, link.length) &&
+                Objects.equals(measureMethod, link.measureMethod) &&
+                Objects.equals(measureDate, link.measureDate) &&
+                sosiMedium == link.sosiMedium &&
+                ltema == link.ltema &&
+                Objects.equals(centerLineProjection, link.centerLineProjection) &&
+                Objects.equals(typeRoad, link.typeRoad) &&
+                Objects.equals(detailLevel, link.detailLevel) &&
+                Objects.equals(geometry, link.geometry) &&
+                Objects.equals(fields, link.fields) &&
+                Objects.equals(startDate, link.startDate) &&
+                Objects.equals(endDate, link.endDate);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(geometry, id, superLinkId, start, end, medium, ltema, topologyLevel, county, municipality,
-                region, roadDepartment, roadRef, isConnectionLink, fromDate, toDate, startNode, endNode);
+        return Objects.hash(partId, linkType, topologyLevel, startPort, endPort, municipality,
+                municipalityGeometry, length, measureMethod, measureDate, sosiMedium, ltema, centerLineProjection,
+                typeRoad, detailLevel, geometry, fields, startDate, endDate, startPos, endPos);
+    }
+
+    @Override
+    public String toString() {
+        return "Link{" +
+            "partId=" + partId +
+            ", linkType=" + linkType +
+            ", topologyLevel=" + topologyLevel +
+            ", startPort=" + startPort +
+            ", endPort=" + endPort +
+            ", startPos=" + startPos +
+            ", endPos=" + endPos +
+            ", municipality=" + municipality +
+            ", municipalityGeometry=" + municipalityGeometry +
+            ", length=" + length +
+            ", measureMethod=" + measureMethod +
+            ", measureDate=" + measureDate +
+            ", sosiMedium=" + sosiMedium +
+            ", ltema=" + ltema +
+            ", centerLineProjection=" + centerLineProjection +
+            ", typeRoad=" + typeRoad +
+            ", geometry=" + geometry +
+            ", fields=" + fields +
+            ", startDate=" + startDate +
+            ", endDate=" + endDate +
+            '}';
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/LinkSequence.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/LinkSequence.java
new file mode 100644
index 0000000..78b2186
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/LinkSequence.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import java.util.List;
+import java.util.Objects;
+
+public class LinkSequence {
+
+    private final long id;
+    private final List<Port> ports;
+    private final List<Link> links;
+    private final double length;
+    private final boolean fixedLength;
+
+    public LinkSequence(long id,
+                        List<Port> ports,
+                        List<Link> links,
+                        double length,
+                        boolean fixedLength) {
+        this.id = id;
+        this.ports = ports;
+        this.links = links;
+        this.length = length;
+        this.fixedLength = fixedLength;
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public List<Port> getPorts() {
+        return ports;
+    }
+
+    public List<Link> getLinks() {
+        return links;
+    }
+
+    public double getLength() {
+        return length;
+    }
+
+    public boolean getFixedLength() {
+        return fixedLength;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        LinkSequence linkSequence = (LinkSequence) o;
+        return Double.compare(linkSequence.length, length) == 0 &&
+                fixedLength == linkSequence.fixedLength &&
+                Objects.equals(id, linkSequence.id) &&
+                Objects.equals(ports, linkSequence.ports) &&
+                Objects.equals(links, linkSequence.links);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, ports, links, length, fixedLength);
+    }
+
+    @Override
+    public String toString() {
+        return "LinkSequence{" +
+                "id=" + id +
+                ", ports=" + ports +
+                ", links=" + links +
+                ", length=" + length +
+                ", fixedLength=" + fixedLength +
+                '}';
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/LinkType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/LinkType.java
new file mode 100644
index 0000000..235fde0
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/LinkType.java
@@ -0,0 +1,24 @@
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+public enum LinkType {
+    HOVED(false, false),
+    DETALJERT(false, true),
+    KONNEKTERING(true, false),
+    DETALJERT_KONNEKTERING(true, true);
+
+    private final boolean isDetailed;
+    private final boolean isConnection;
+
+    LinkType(boolean isConnection, boolean isDetailed) {
+        this.isConnection = isConnection;
+        this.isDetailed = isDetailed;
+    }
+
+    public boolean isDetailed() {
+        return isDetailed;
+    }
+
+    public boolean isConnection() {
+        return isConnection;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Ltema.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Ltema.java
index 5affbdd..8ffec16 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Ltema.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Ltema.java
@@ -1,9 +1,38 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 package no.vegvesen.nvdbapi.client.model.roadnet;
 
-import java.util.Arrays;
+import java.util.Map;
+import java.util.stream.Stream;
+
+import static java.util.function.Function.identity;
+import static java.util.stream.Collectors.toMap;
 
 public enum Ltema {
-    
+
     VEGSENTERLINJE(7001, "VegSenterlinje"),
     KJOREFELT(7010, "Kjørefelt"),
     KJOREBANE(7011, "Kjørebane"),
@@ -17,7 +46,9 @@ public enum Ltema {
 
     private final int code;
     private final String description;
-    
+
+    private static final Map<Integer, Ltema> mapping = Stream.of(Ltema.values()).collect(toMap(Ltema::code, identity()));
+
     Ltema(int code, String description) {
         this.code = code;
         this.description = description;
@@ -31,7 +62,7 @@ public enum Ltema {
         return this.description;
     }
 
-    public static Ltema from(int code) {
-        return Arrays.stream(Ltema.values()).filter(v -> v.code() == code).findAny().orElse(null);
+    public static Ltema from(Integer code) {
+        return mapping.get(code);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/NetElementType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/NetElementType.java
new file mode 100644
index 0000000..d511982
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/NetElementType.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import java.util.Arrays;
+
+public enum NetElementType {
+    NODE(50001, "Node"),
+    LENKE(50002, "Veglenkesekvens");
+
+    private final int value;
+    private final String description;
+
+    NetElementType(int value, String description) {
+        this.value = value;
+        this.description = description;
+    }
+
+    public int getValue() {
+        return value;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public static NetElementType from(int val) {
+        return Arrays.stream(NetElementType.values()).filter(v -> v.getValue() == val).findAny().orElse(null);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Node.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Node.java
new file mode 100644
index 0000000..3f6838b
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Node.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import no.vegvesen.nvdbapi.client.model.Geometry;
+
+import java.time.LocalDate;
+import java.util.List;
+import java.util.Objects;
+
+public class Node {
+
+    private final Long id;
+    private final Geometry geometry;
+    private final LocalDate startDate;
+    private final LocalDate endDate;
+    private final List<Port> ports;
+
+    public Node(Long id, Geometry geometry, LocalDate startDate, LocalDate endDate, List<Port> ports) {
+        this.id = id;
+        this.geometry = geometry;
+        this.startDate = startDate;
+        this.endDate = endDate;
+        this.ports = ports;
+    }
+
+    public Long getId() {
+        return id;
+    }
+
+    public Geometry getGeometry() {
+        return geometry;
+    }
+
+    public LocalDate getStartDate() {
+        return startDate;
+    }
+
+    public LocalDate getEndDate() {
+        return endDate;
+    }
+
+    public List<Port> getPorts() {
+        return ports;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Node node = (Node) o;
+        return Objects.equals(getId(), node.getId()) &&
+            Objects.equals(getGeometry(), node.getGeometry()) &&
+            Objects.equals(getStartDate(), node.getStartDate()) &&
+            Objects.equals(getEndDate(), node.getEndDate()) &&
+            Objects.equals(getPorts(), node.getPorts());
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(getId(), getGeometry(), getStartDate(), getEndDate(), getPorts());
+    }
+
+    @Override
+    public String toString() {
+        return "Node{" +
+            "id=" + id +
+            ", geometry=" + geometry +
+            ", startDate=" + startDate +
+            ", endDate=" + endDate +
+            ", ports=" + ports +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Port.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Port.java
new file mode 100644
index 0000000..47ff25a
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/Port.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import java.util.Objects;
+
+public class Port {
+
+    private final Integer id;
+
+    private final Double linkPosition;
+
+    private final PortConnection portConnection;
+    public Port(Integer id, Double linkPosition, PortConnection portConnection) {
+        this.id = id;
+        this.linkPosition = linkPosition;
+        this.portConnection = portConnection;
+    }
+
+    public Integer getId() {
+        return id;
+    }
+
+    public Double getLinkPosition() {
+        return linkPosition;
+    }
+
+    public PortConnection getPortConnection() {
+        return portConnection;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Port port = (Port) o;
+        return Objects.equals(getId(), port.getId()) &&
+            Objects.equals(getLinkPosition(), port.getLinkPosition()) &&
+            Objects.equals(getPortConnection(), port.getPortConnection());
+    }
+
+    @Override
+    public int hashCode() {
+
+        return Objects.hash(getId(), getLinkPosition(), getPortConnection());
+    }
+
+    @Override
+    public String toString() {
+        return "Port{" +
+            "id=" + id +
+            ", linkPosition=" + linkPosition +
+            ", portConnection=" + portConnection +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/PortConnection.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/PortConnection.java
new file mode 100644
index 0000000..b83d764
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/PortConnection.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import java.util.Objects;
+
+public class PortConnection {
+
+    private final Integer portId;
+    private final Long netelementId;
+    private final NetElementType netElementType;
+
+    public PortConnection(Integer portId,
+                          Long netelementId,
+                          NetElementType netElementType) {
+        this.portId = portId;
+        this.netelementId = netelementId;
+        this.netElementType = netElementType;
+    }
+
+    public Integer getPortId() {
+        return portId;
+    }
+
+    public Long getNetelementId() {
+        return netelementId;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        PortConnection that = (PortConnection) o;
+        return Objects.equals(getPortId(), that.getPortId()) &&
+                Objects.equals(getNetelementId(), that.getNetelementId()) &&
+                getNetElementType() == that.getNetElementType();
+    }
+
+    public NetElementType getNetElementType() {
+        return netElementType;
+    }
+
+    @Override
+    public int hashCode() {
+
+        return Objects.hash(getPortId(), getNetelementId(), getNetElementType());
+    }
+
+    @Override
+    public String toString() {
+        return "PortConnection{" +
+                "portId=" + portId +
+                ", netElementId=" + netelementId +
+                ", netElementType=" + netElementType +
+                '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/RefLinkPartType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/RefLinkPartType.java
new file mode 100644
index 0000000..5f589fe
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/RefLinkPartType.java
@@ -0,0 +1,35 @@
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import static java.util.Objects.isNull;
+import static java.util.stream.Collectors.toMap;
+
+public enum RefLinkPartType {
+    MAIN("Hoved"),
+    CONNECTION("Konnektering"),
+    DETAILED("Detaljert"),
+    DETAILED_CONNECTION("Detaljert_konnektering"),
+    UNKNOWN("Ukjent");
+
+
+    private final String refLinkPartType;
+
+    RefLinkPartType(String refLinkPartTYpe) {
+        this.refLinkPartType = refLinkPartTYpe;
+    }
+
+    private static final Map<String, RefLinkPartType> mapping =
+            Stream.of(values()).collect(toMap(k -> k.refLinkPartType.toLowerCase(), Function.identity()));
+
+    public static RefLinkPartType fromValue(String refLinkPartType) {
+        if (isNull(refLinkPartType)) return null;
+        return mapping.getOrDefault(refLinkPartType.toLowerCase(), UNKNOWN);
+    }
+
+    public String getRefLinkPartType() {
+        return refLinkPartType;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/RoadUserGroup.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/RoadUserGroup.java
new file mode 100644
index 0000000..675ab2b
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/RoadUserGroup.java
@@ -0,0 +1,27 @@
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import static java.util.Objects.isNull;
+
+public enum RoadUserGroup {
+    KJORENDE("K"),
+    GAENDE("G");
+
+    private final String textValue;
+
+    RoadUserGroup(String text) {
+        this.textValue = text;
+    }
+
+    public static RoadUserGroup fromValue(String textValue) {
+        if (isNull(textValue)) return null;
+        switch (textValue.toUpperCase()) {
+            case "G": return GAENDE;
+            case "K": return KJORENDE;
+            default: return null;
+        }
+    }
+
+    public String getTextValue() {
+        return textValue;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/SegmentedLink.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/SegmentedLink.java
new file mode 100644
index 0000000..802ad64
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/SegmentedLink.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.RoadPlacement;
+import no.vegvesen.nvdbapi.client.model.areas.ContractArea;
+import no.vegvesen.nvdbapi.client.model.areas.Route;
+import no.vegvesen.nvdbapi.client.model.areas.Street;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RefLinkExtentPlacement;
+
+import java.io.Serializable;
+import java.time.LocalDate;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+
+public final class SegmentedLink implements Serializable {
+
+    private final long id;
+    private final double start;
+    private final double end;
+    private final Geometry geometry;
+    private final double length;
+    private final int linkNumber;
+    private final int segmentNumber;
+    private final RefLinkPartType linkType;
+    private final List<ContractArea> contractAreas;
+    private final List<Route> routes;
+    private final Street street;
+    private final DetailLevel detailLevel;
+    private final TopologyLevel topologyLevel;
+    private final TypeOfRoad roadType;
+
+
+    private final RefLinkExtentPlacement superLinkExtent;
+    private final Integer county;
+    private final Integer municipality;
+    private final RoadSysRef roadRef;
+    private final LocalDate fromDate;
+    private final LocalDate toDate;
+    private final String startNode;
+    private final String endNode;
+
+    public SegmentedLink(long id, double start, double end,
+                         int linkNumber, int segmentNumber, DetailLevel detailLevel,
+                         TopologyLevel topologyLevel, TypeOfRoad roadType,
+                         String startNode, String endNode,
+                         RefLinkExtentPlacement superLinkExtent,
+                         LocalDate fromDate, LocalDate toDate,
+                         Integer county,
+                         Integer municipality,
+                         Geometry geometry, double length, RoadSysRef roadRef,
+                         RefLinkPartType linkType,
+                         List<ContractArea> contractAreas,
+                         List<Route> routes,
+                         Street street) {
+        this.id = id;
+        this.start = start;
+        this.end = end;
+        this.linkNumber = linkNumber;
+        this.segmentNumber = segmentNumber;
+        this.detailLevel = detailLevel;
+        this.roadType = roadType;
+        this.county = county;
+        this.municipality = municipality;
+        this.fromDate = fromDate;
+        this.toDate = toDate;
+        this.startNode = startNode;
+        this.endNode = endNode;
+        this.superLinkExtent = superLinkExtent;
+        this.length = length;
+        this.roadRef = roadRef;
+        this.geometry = geometry;
+        this.linkType = linkType;
+        this.contractAreas = contractAreas;
+        this.routes = routes;
+        this.street = street;
+        this.topologyLevel = topologyLevel;
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public Optional<RefLinkExtentPlacement> getSuperLinkExtent() {
+        return Optional.ofNullable(superLinkExtent);
+    }
+
+    public double getStart() {
+        return start;
+    }
+
+    public double getEnd() {
+        return end;
+    }
+
+    public int getLinkNumber() {
+        return linkNumber;
+    }
+
+    public int getSegmentNumber() {
+        return segmentNumber;
+    }
+
+    public RefLinkPartType getLinkType() {
+        return linkType;
+    }
+
+    public TopologyLevel getTopologyLevel() {
+        return topologyLevel;
+    }
+
+    public DetailLevel getDetailLevel() {
+        return detailLevel;
+    }
+
+    public TypeOfRoad getRoadType() {
+        return roadType;
+    }
+
+    public RoadSysRef getRoadRef() {
+        return roadRef;
+    }
+
+    public Integer getCounty() {
+        return county;
+    }
+
+    public Integer getMunicipality() {
+        return municipality;
+    }
+
+    public LocalDate getFromDate() {
+        return fromDate;
+    }
+
+    public LocalDate getToDate() {
+        return toDate;
+    }
+
+    public String getEndNode() {
+        return endNode;
+    }
+
+    public String getStartNode() {
+        return startNode;
+    }
+
+    public Optional<Geometry> getGeometry() {
+        return Optional.ofNullable(geometry);
+    }
+
+    public double getLength() {
+        return length;
+    }
+
+    public List<ContractArea> getContractAreas() {
+        return contractAreas;
+    }
+
+    public List<Route> getRoutes() {
+        return routes;
+    }
+
+    public Street getStreet() {
+        return street;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        SegmentedLink that = (SegmentedLink) o;
+        return id == that.id &&
+                Double.compare(that.start, start) == 0 &&
+                Double.compare(that.end, end) == 0 &&
+                Double.compare(that.length, length) == 0 &&
+                linkNumber == that.linkNumber &&
+                segmentNumber == that.segmentNumber &&
+                Objects.equals(geometry, that.geometry) &&
+                Objects.equals(linkType, that.linkType) &&
+                Objects.equals(contractAreas, that.contractAreas) &&
+                Objects.equals(routes, that.routes) &&
+                Objects.equals(street, that.street) &&
+                Objects.equals(detailLevel, that.detailLevel) &&
+                Objects.equals(roadType, that.roadType) &&
+                Objects.equals(superLinkExtent, that.superLinkExtent) &&
+                Objects.equals(county, that.county) &&
+                Objects.equals(municipality, that.municipality) &&
+                Objects.equals(roadRef, that.roadRef) &&
+                Objects.equals(fromDate, that.fromDate) &&
+                Objects.equals(toDate, that.toDate) &&
+                Objects.equals(startNode, that.startNode) &&
+                Objects.equals(endNode, that.endNode);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, start, end, geometry, length, linkNumber, segmentNumber, linkType, contractAreas, routes, street, detailLevel, roadType, superLinkExtent, county, municipality, roadRef, fromDate, toDate, startNode, endNode);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/SeparatePassages.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/SeparatePassages.java
new file mode 100644
index 0000000..d636ad2
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/SeparatePassages.java
@@ -0,0 +1,26 @@
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+public enum SeparatePassages {
+    MED("Med"),
+    NEI("Nei"),
+    MOT("Mot");
+
+    private final String textValue;
+
+    SeparatePassages(String text) {
+        this.textValue = text;
+    }
+
+    public static SeparatePassages fromValue(String textValue) {
+        switch(textValue.toUpperCase()) {
+            case "MED" : return MED;
+            case "NEI" : return NEI;
+            case "MOT" : return MOT;
+            default: return null;
+        }
+    }
+
+    public String getTextValue() {
+        return textValue;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/TopologyLevel.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/TopologyLevel.java
index 7c35c59..dddee5b 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/TopologyLevel.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/TopologyLevel.java
@@ -25,22 +25,20 @@
 
 package no.vegvesen.nvdbapi.client.model.roadnet;
 
-import java.util.Arrays;
-
 public enum TopologyLevel {
-    VEGTRASE(0, "Vegtrase"),
-    KJOREBANE(1, "Kjørebane"),
-    KJOREFELT(2, "Kjørefelt");
+    VEGTRASE("vegtrase", "Vegtrasé"),
+    KJOREBANE("kjørebane", "Kjørebane"),
+    KJOREFELT("kjørefelt", "Kjørefelt");
 
-    private final int apiValue;
+    private final String apiValue;
     private final String description;
 
-    TopologyLevel(int apiValue, String description) {
+    TopologyLevel(String apiValue, String description) {
         this.apiValue = apiValue;
         this.description = description;
     }
 
-    public int getApiValue() {
+    public String getApiValue() {
         return apiValue;
     }
 
@@ -48,7 +46,16 @@ public enum TopologyLevel {
         return description;
     }
 
-    public static TopologyLevel from(int val) {
-       return Arrays.stream(TopologyLevel.values()).filter(v -> v.apiValue == val).findAny().orElse(null);
+    public static TopologyLevel fromValue(String val) {
+        if(val == null) return null;
+        switch (val.toLowerCase()) {
+            case "vegtrase":
+            case "vegtrasé": return VEGTRASE;
+            case "kjorebane":
+            case "kjørebane": return KJOREBANE;
+            case "kjorefelt":
+            case "kjørefelt": return KJOREFELT;
+            default: return null;
+        }
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/TypeOfRoad.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/TypeOfRoad.java
new file mode 100644
index 0000000..db7a8c5
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/TypeOfRoad.java
@@ -0,0 +1,47 @@
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import static java.util.Objects.isNull;
+import static java.util.stream.Collectors.toMap;
+
+public enum TypeOfRoad {
+
+    KANALISERT_VEG("kanalisertVeg", "Kanalisert veg"),
+    ENKEL_BILVEG("enkelBilveg", "Enkel bilveg"),
+    RAMPE("rampe", "Rampe"),
+    RUNDKJORING("rundkjøring", "Rundkjøring"),
+    BILFERJE("bilferje", "Bilferje"),
+    PASSASJERFERJE("passasjerferje", "Passasjerferje"),
+    GANG_OG_SYKKELVEG("gangOgSykkelveg", "Gang- og sykkelveg"),
+    SYKKELVEG("sykkelveg", "Sykkelveg"),
+    GANGVEG("gangveg", "Gangveg"),
+    GAGATE("gågate", "Gågate"),
+    FORTAU("fortau", "Fortau"),
+    TRAPP("trapp", "Trapp"),
+    GANGFELT("gangfelt", "Gangfelt"),
+    GATETUN("gatetun", "Gatetun"),
+    UKJENT("ukjent", "Ukjent");
+
+    private final String typeOfRoadText;
+    private final String typeOfRoadSosi;
+
+    TypeOfRoad(String typeOfRoadSosi, String typeOfRoadText) {
+        this.typeOfRoadText = typeOfRoadText;
+        this.typeOfRoadSosi = typeOfRoadSosi;
+    }
+
+    private static final Map<String,TypeOfRoad> mapping =
+            Stream.of(values()).collect(toMap(k -> k.typeOfRoadText.toLowerCase(), Function.identity()));
+
+    public static TypeOfRoad fromTextValue(String typeOfRoad) {
+        if (isNull(typeOfRoad)) return UKJENT;
+        return mapping.getOrDefault(typeOfRoad.toLowerCase(), UKJENT);
+    }
+
+    public String getTypeOfRoadSosi() {
+        return typeOfRoadSosi;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Intersection.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Intersection.java
new file mode 100644
index 0000000..3f11889
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Intersection.java
@@ -0,0 +1,66 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.roadsysref;
+
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.roadnet.RoadUserGroup;
+
+import java.util.Objects;
+
+public class Intersection {
+    public final Long id;
+    public final Integer version;
+    public final int number;
+    public final int part;
+    public final double startMeter;
+    public final Double endMeter;
+    public final Direction direction;
+    public final RoadUserGroup trafficType;
+
+    public Intersection(Long id,
+                        Integer version,
+                        int number,
+                        int part,
+                        double startMeter,
+                        Double endMeter,
+                        Direction direction, RoadUserGroup trafficType) {
+        this.number = number;
+        this.part = part;
+        this.id = id;
+        this.version = version;
+        this.startMeter = startMeter;
+        this.endMeter = endMeter;
+        this.direction = direction;
+        this.trafficType = trafficType;
+    }
+
+    @Override
+    public String toString() {
+        return "Intersection{" +
+                "id=" + id +
+                ", version=" + version +
+                ", number=" + number +
+                ", part=" + part +
+                ", startMeter='" + startMeter + '\'' +
+                ", endMeter='" + endMeter + '\'' +
+                ", direction='" + direction + '\'' +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Intersection that = (Intersection) o;
+        return number == that.number &&
+                part == that.part &&
+                Double.compare(that.startMeter, startMeter) == 0 &&
+                Objects.equals(id, that.id) &&
+                Objects.equals(direction, that.direction) &&
+                Objects.equals(version, that.version) &&
+                Objects.equals(endMeter, that.endMeter);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, version, number, part, startMeter, endMeter, direction);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Phase.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Phase.java
new file mode 100644
index 0000000..a11d4d0
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Phase.java
@@ -0,0 +1,17 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.roadsysref;
+
+/**
+ * See definition of road object type 915, attribute 11278, «Fase»
+ */
+public enum Phase {
+    P("Planlagt"),
+    A("Under bygging"),
+    V("Eksisterende"),
+    F("Fiktiv");
+
+    public final String name;
+
+    Phase(String name) {
+        this.name = name;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadCategory.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadCategory.java
new file mode 100644
index 0000000..fa0af38
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadCategory.java
@@ -0,0 +1,19 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.roadsysref;
+
+/**
+ * See definition of road object type 915, attribute 11276, «Vegkategori»
+ */
+public enum RoadCategory {
+    E( "Europaveg"),
+    R( "Riksveg"),
+    F( "Fylkesveg"),
+    K( "Kommunal veg"),
+    P( "Privat veg"),
+    S("Skogsveg");
+
+    public final String name;
+
+    RoadCategory(String name) {
+        this.name = name;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadSysRef.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadSysRef.java
new file mode 100644
index 0000000..3259512
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadSysRef.java
@@ -0,0 +1,69 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.roadsysref;
+
+import java.util.Objects;
+
+public class RoadSysRef {
+
+    public final Section section;
+    public final SideArea sideArea;
+    public final Intersection intersection;
+    public final RoadSystem roadSystem;
+
+    /**
+     *  Shortform of the roadsysref
+     */
+    public final String shortForm;
+
+    public RoadSysRef(RoadSystem roadSystem,
+                      Section section,
+                      Intersection interSection,
+                      SideArea sideArea,
+                      String shortForm) {
+        this.roadSystem = roadSystem;
+        this.section = section;
+        this.intersection = interSection;
+        this.sideArea = sideArea;
+        this.shortForm = shortForm;
+    }
+
+    public Section getSection() {
+        return section;
+    }
+    public Intersection getInterSection() {
+        return intersection;
+    }
+    public SideArea getSideArea() {
+        return sideArea;
+    }
+    public RoadSystem getRoadSystem() {
+        return roadSystem;
+    }
+
+    @Override
+    public String toString() {
+        return "RoadSysRef{" +
+                "section=" + section +
+                ", sideArea=" + sideArea +
+                ", intersection=" + intersection +
+                ", roadSystem=" + roadSystem +
+                ", shortForm='" + shortForm + '\'' +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RoadSysRef that = (RoadSysRef) o;
+        return Objects.equals(section, that.section) &&
+                Objects.equals(sideArea, that.sideArea) &&
+                Objects.equals(intersection, that.intersection) &&
+                Objects.equals(roadSystem, that.roadSystem) &&
+                Objects.equals(shortForm, that.shortForm);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(section, sideArea, intersection, roadSystem, shortForm);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadSystem.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadSystem.java
new file mode 100644
index 0000000..1217af3
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/RoadSystem.java
@@ -0,0 +1,55 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.roadsysref;
+
+import java.util.Objects;
+
+public class RoadSystem {
+    public final Long id;
+    public final Integer version;
+    public final Integer roadNumber;
+    public final RoadCategory roadCategory;
+    public final Phase phase;
+
+    public RoadSystem(Long id,
+                      Integer version,
+                      Integer roadNumber,
+                      RoadCategory roadCategory,
+                      Phase phase) {
+        this.id = id;
+        this.version = version;
+        this.roadNumber = roadNumber;
+        this.roadCategory = roadCategory;
+        this.phase = phase;
+    }
+
+    public String getCategoryPhaseNumberAsString(){
+        return roadCategory.toString() + phase.toString() + (roadNumber == null ? "" : roadNumber);
+    }
+
+    @Override
+    public String toString() {
+        return "RoadSystem{" +
+                "id=" + id +
+                ", version=" + version +
+                ", roadNumber=" + roadNumber +
+                ", roadCategory='" + roadCategory + '\'' +
+                ", phase='" + phase + '\'' +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RoadSystem that = (RoadSystem) o;
+        return Objects.equals(roadNumber, that.roadNumber) &&
+                Objects.equals(id, that.id) &&
+                Objects.equals(version, that.version) &&
+                Objects.equals(roadCategory, that.roadCategory) &&
+                Objects.equals(phase, that.phase);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, version, roadNumber, roadCategory, phase);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Section.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Section.java
new file mode 100644
index 0000000..8c2d3ad
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/Section.java
@@ -0,0 +1,89 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.roadsysref;
+
+import java.util.Objects;
+
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.roadnet.RoadUserGroup;
+import no.vegvesen.nvdbapi.client.model.roadnet.SeparatePassages;
+
+public class Section {
+
+    public final Long id;
+    public final Integer version;
+    public final Integer sectionNumber;
+    public final Integer sectionPartNumber;
+    public final Boolean arm;
+    public final SeparatePassages sepratePassages;
+    public final RoadUserGroup trafficType;
+    public final double startMeter;
+    public final Double endMeter;
+    public final Direction direction;
+
+    public Section(Long id,
+                   Integer version,
+                   Integer sectionNumber,
+                   Integer sectionPartNumber,
+                   Boolean arm,
+                   SeparatePassages sepratePassages,
+                   RoadUserGroup trafficType,
+                   double startMeter,
+                   Double endMeter,
+                   Direction direction) {
+        this.id = id;
+        this.version = version;
+        this.sectionNumber = sectionNumber;
+        this.sectionPartNumber = sectionPartNumber;
+        this.arm = arm;
+        this.sepratePassages = sepratePassages;
+        this.trafficType = trafficType;
+        this.startMeter = startMeter;
+        this.endMeter = endMeter;
+        this.direction = direction;
+    }
+
+    @Override
+    public String toString() {
+        return "Section{" +
+                "id=" + id +
+                ", version=" + version +
+                ", sectionNumber=" + sectionNumber +
+                ", sectionPartNumber=" + sectionPartNumber +
+                ", arm='" + arm + '\'' +
+                ", sepratePassages='" + sepratePassages + '\'' +
+                ", trafficType='" + trafficType + '\'' +
+                ", startMeter='" + startMeter + '\'' +
+                ", endMeter='" + endMeter + '\'' +
+                ", direction'" + direction + '\'' +
+                '}';
+    }
+
+    public String getSectionAndPartAsString() {
+        return "S" +
+                sectionNumber +
+                "D" +
+                sectionPartNumber;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Section section = (Section) o;
+        return sectionNumber.equals(section.sectionNumber) &&
+                sectionPartNumber.equals(section.sectionPartNumber) &&
+                Double.compare(section.startMeter, startMeter) == 0 &&
+                Objects.equals(id, section.id) &&
+                Objects.equals(version, section.version) &&
+                Objects.equals(arm, section.arm) &&
+                Objects.equals(sepratePassages, section.sepratePassages) &&
+                Objects.equals(trafficType, section.trafficType) &&
+                Objects.equals(endMeter, section.endMeter) &&
+                Objects.equals(direction, section.direction);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, version, sectionNumber, sectionPartNumber, arm, sepratePassages, trafficType,
+                startMeter, endMeter, direction);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/SideArea.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/SideArea.java
new file mode 100644
index 0000000..a8f79a5
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/roadsysref/SideArea.java
@@ -0,0 +1,60 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.roadsysref;
+
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.roadnet.RoadUserGroup;
+
+import java.util.Objects;
+
+public class SideArea {
+    public final Long id;
+    public final Integer version;
+    public final int number;
+    public final int part;
+    public final double startMeter;
+    public final Double endMeter;
+    public final Direction direction;
+    public final RoadUserGroup trafficType;
+
+    public SideArea(Long id, Integer version, int number, int part, double startMeter, Double endMeter, Direction direction, RoadUserGroup trafficType) {
+        this.id = id;
+        this.version = version;
+        this.number = number;
+        this.part = part;
+        this.startMeter = startMeter;
+        this.endMeter = endMeter;
+        this.direction = direction;
+        this.trafficType = trafficType;
+    }
+
+    @Override
+    public String toString() {
+        return "SideArea{" +
+                "id=" + id +
+                ", version=" + version +
+                ", number=" + number +
+                ", part=" + part +
+                ", startMeter='" + startMeter + '\'' +
+                ", endMeter='" + endMeter + '\'' +
+                ", direction='" + direction + '\'' +
+                '}';
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        SideArea sideArea = (SideArea) o;
+        return number == sideArea.number &&
+                part == sideArea.part &&
+                Double.compare(sideArea.startMeter, startMeter) == 0 &&
+                Objects.equals(id, sideArea.id) &&
+                Objects.equals(version, sideArea.version) &&
+                Objects.equals(direction, sideArea.direction) &&
+                Objects.equals(endMeter, sideArea.endMeter);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, version, number, part, startMeter, endMeter, direction);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/BriefRouteSegment.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/BriefRouteSegment.java
new file mode 100644
index 0000000..9f4fa12
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/BriefRouteSegment.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet.route;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+public final class BriefRouteSegment implements RouteSegment, Serializable {
+
+    private final long id;
+    private final double start;
+    private final double end;
+    private final String shortForm;
+    private final String type;
+
+    public BriefRouteSegment(long id,
+                             double start,
+                             double end,
+                             String shortForm,
+                             String type) {
+        this.id = id;
+        this.start = start;
+        this.end = end;
+        this.shortForm = shortForm;
+        this.type = type;
+
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public double getStart() {
+        return start;
+    }
+
+    public double getEnd() {
+        return end;
+    }
+
+    public String getShortForm() {
+        return shortForm;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        BriefRouteSegment that = (BriefRouteSegment) o;
+        return id == that.id &&
+                Double.compare(that.start, start) == 0 &&
+                Double.compare(that.end, end) == 0 &&
+                Objects.equals(shortForm, that.shortForm) &&
+                Objects.equals(type, that.type);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, start, end, shortForm, type);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/DetailedRouteSegment.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/DetailedRouteSegment.java
new file mode 100644
index 0000000..251052d
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/DetailedRouteSegment.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadnet.route;
+
+import java.io.Serializable;
+import java.time.LocalDate;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+
+import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.areas.ContractArea;
+import no.vegvesen.nvdbapi.client.model.areas.Route;
+import no.vegvesen.nvdbapi.client.model.roadnet.DetailLevel;
+import no.vegvesen.nvdbapi.client.model.roadnet.RefLinkPartType;
+import no.vegvesen.nvdbapi.client.model.roadnet.TypeOfRoad;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
+
+public final class DetailedRouteSegment implements Serializable, RouteSegment {
+
+    private final long id;
+    private final double start;
+    private final double end;
+    private final Geometry geometry;
+    private final Double length;
+    private final Integer linkNumber;
+    private final RefLinkPartType linkType;
+    private final List<ContractArea> contractAreas;
+    private final List<Route> routes;
+    private final DetailLevel detailLevel;
+    private final TypeOfRoad roadType;
+
+
+    private final Long superLinkId;
+    private final Integer county;
+    private final Integer municipality;
+    private final RoadSysRef roadRef;
+    private final LocalDate fromDate;
+    private final LocalDate toDate;
+    private final String startNode;
+    private final String endNode;
+
+    public DetailedRouteSegment(long id,
+                                Long superLinkId,
+                                double start,
+                                double end,
+                                Integer linkNumber,
+                                DetailLevel detailLevel,
+                                TypeOfRoad roadType,
+                                String startNode,
+                                String endNode,
+                                LocalDate fromDate,
+                                LocalDate toDate,
+                                Integer county,
+                                Integer municipality,
+                                Geometry geometry,
+                                Double length,
+                                RoadSysRef roadRef,
+                                RefLinkPartType linkType,
+                                List<ContractArea> contractAreas,
+                                List<Route> routes) {
+        this.id = id;
+        this.superLinkId = superLinkId;
+        this.start = start;
+        this.end = end;
+        this.linkNumber = linkNumber;
+        this.detailLevel = detailLevel;
+        this.roadType = roadType;
+        this.county = county;
+        this.municipality = municipality;
+        this.fromDate = fromDate;
+        this.toDate = toDate;
+        this.startNode = startNode;
+        this.endNode = endNode;
+        this.length = length;
+        this.roadRef = roadRef;
+        this.geometry = geometry;
+        this.linkType = linkType;
+        this.contractAreas = contractAreas;
+        this.routes = routes;
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public Optional<Long> getSuperLinkId() {
+        return Optional.ofNullable(superLinkId);
+    }
+
+    public double getStart() {
+        return start;
+    }
+
+    public double getEnd() {
+        return end;
+    }
+
+    public int getLinkNumber() {
+        return linkNumber;
+    }
+
+    public RefLinkPartType getLinkType() {
+        return linkType;
+    }
+
+    public DetailLevel getDetailLevel() {
+        return detailLevel;
+    }
+
+    public TypeOfRoad getRoadType() {
+        return roadType;
+    }
+
+    public RoadSysRef getRoadRef() {
+        return roadRef;
+    }
+
+    public Integer getCounty() {
+        return county;
+    }
+
+    public Integer getMunicipality() {
+        return municipality;
+    }
+
+    public LocalDate getFromDate() {
+        return fromDate;
+    }
+
+    public LocalDate getToDate() {
+        return toDate;
+    }
+
+    public String getEndNode() {
+        return endNode;
+    }
+
+    public String getStartNode() {
+        return startNode;
+    }
+
+    public Optional<Geometry> getGeometry() {
+        return Optional.ofNullable(geometry);
+    }
+
+    public double getLength() {
+        return length;
+    }
+
+    public List<ContractArea> getContractAreas() {
+        return contractAreas;
+    }
+
+    public List<Route> getRoutes() {
+        return routes;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        DetailedRouteSegment that = (DetailedRouteSegment) o;
+        return id == that.id &&
+                Double.compare(that.start, start) == 0 &&
+                Double.compare(that.end, end) == 0 &&
+                Double.compare(that.length, length) == 0 &&
+                linkNumber.equals(that.linkNumber) &&
+                Objects.equals(geometry, that.geometry) &&
+                Objects.equals(linkType, that.linkType) &&
+                Objects.equals(contractAreas, that.contractAreas) &&
+                Objects.equals(routes, that.routes) &&
+                Objects.equals(detailLevel, that.detailLevel) &&
+                Objects.equals(roadType, that.roadType) &&
+                Objects.equals(superLinkId, that.superLinkId) &&
+                Objects.equals(county, that.county) &&
+                Objects.equals(municipality, that.municipality) &&
+                Objects.equals(roadRef, that.roadRef) &&
+                Objects.equals(fromDate, that.fromDate) &&
+                Objects.equals(toDate, that.toDate) &&
+                Objects.equals(startNode, that.startNode) &&
+                Objects.equals(endNode, that.endNode);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id, start, end, geometry, length, linkNumber, linkType, contractAreas, routes, detailLevel, roadType, superLinkId, county, municipality, roadRef, fromDate, toDate, startNode, endNode);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteOnRoadNet.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteOnRoadNet.java
new file mode 100644
index 0000000..03f7cbf
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteOnRoadNet.java
@@ -0,0 +1,42 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.route;
+
+import java.util.List;
+import java.util.Objects;
+
+
+public class RouteOnRoadNet {
+    private final List<RouteSegment> segments;
+    public final double length;
+    public final RouteStatus status;
+
+    public RouteOnRoadNet(List<RouteSegment> segments, double length, RouteStatus status) {
+        this.segments = segments;
+        this.length = length;
+        this.status = status;
+    }
+
+    public List<RouteSegment> getSegments() {
+        return segments;
+    }
+
+    public double getLength() {
+        return length;
+    }
+
+    public RouteStatus getStatus() {
+        return status;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RouteOnRoadNet that = (RouteOnRoadNet) o;
+        return Objects.equals(segments, that.segments);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(segments);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteSegment.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteSegment.java
new file mode 100644
index 0000000..791d2d8
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteSegment.java
@@ -0,0 +1,4 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.route;
+
+public interface RouteSegment {
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteStatus.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteStatus.java
new file mode 100644
index 0000000..2277dd1
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadnet/route/RouteStatus.java
@@ -0,0 +1,30 @@
+package no.vegvesen.nvdbapi.client.model.roadnet.route;
+
+public enum RouteStatus {
+    KOMPLETT(2000),
+    LENGSTE_SAMMENHENGENDE(2060),
+    MED_GYLDIGHETSHULL(2061),
+    IKKE_FUNNET_RUTE(4040),
+    IKKE_FUNNET_STARTPUNKT(4041),
+    IKKE_FUNNET_SLUTTPUNKT(4042),
+    IKKE_FUNNET_SEGMENTER_I_UTSNITT(4043);
+
+    private final int statusCode;
+
+    RouteStatus(int statusCode) {
+        this.statusCode = statusCode;
+    }
+
+    public static RouteStatus valueOfCode(int code) {
+        for (RouteStatus status: values()) {
+            if (status.statusCode == code) {
+                return status;
+            }
+        }
+        return null;
+    }
+
+    public int getStatusCode() {
+        return this.statusCode;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Attribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Attribute.java
deleted file mode 100644
index 0578fc8..0000000
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Attribute.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.vegvesen.nvdbapi.client.model.roadobjects;
-
-import no.vegvesen.nvdbapi.client.model.Quality;
-import no.vegvesen.nvdbapi.client.model.datakatalog.DataType;
-
-import java.util.Objects;
-import java.util.Optional;
-
-public class Attribute {
-    private final int typeId;
-    private final String typeName;
-    private final DataType datatype;
-    private final Object value;
-    private final Optional<Integer> enumId;
-    private final Optional<Quality> quality;
-
-    public Attribute(int typeId, String typeName, DataType datatype, Object value, Optional<Integer> enumId, Optional<Quality> quality) {
-        this.typeId = typeId;
-        this.typeName = typeName;
-        this.datatype = datatype;
-        this.value = value;
-        this.enumId = enumId;
-        this.quality = quality;
-    }
-
-    public int getTypeId() {
-        return typeId;
-    }
-
-    public DataType getDatatype() {
-        return datatype;
-    }
-
-    public String getTypeName() {
-        return typeName;
-    }
-
-    public Object getValue() {
-        return value;
-    }
-
-    public int intValue() {
-        if (!(value instanceof Number)) {
-            throw new IllegalStateException("Not a number!");
-        }
-        return ((Number) value).intValue();
-    }
-
-    public double doubleValue() {
-        if (!(value instanceof Number)) {
-            throw new IllegalStateException("Not a number!");
-        }
-        return ((Number) value).doubleValue();
-    }
-
-    public String stringValue() {
-        return (String) value;
-    }
-
-    public boolean booleanValue() {
-        return (boolean) value;
-    }
-
-    public Optional<Integer> getEnumId() {
-        return enumId;
-    }
-
-    public Optional<Quality> getQuality() { return quality; }
-
-    public boolean isEnum() {
-        return enumId.isPresent();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        Attribute attribute = (Attribute) o;
-        return typeId == attribute.typeId &&
-                Objects.equals(typeName, attribute.typeName) &&
-                Objects.equals(datatype, attribute.datatype) &&
-                Objects.equals(value, attribute.value) &&
-                Objects.equals(enumId, attribute.enumId);
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(typeId, typeName, datatype, value, enumId);
-    }
-}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Location.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Location.java
index 7575b5f..dce6c94 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Location.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Location.java
@@ -28,6 +28,8 @@ package no.vegvesen.nvdbapi.client.model.roadobjects;
 import no.vegvesen.nvdbapi.client.model.Geometry;
 import no.vegvesen.nvdbapi.client.model.areas.ContractArea;
 import no.vegvesen.nvdbapi.client.model.areas.Route;
+import no.vegvesen.nvdbapi.client.model.areas.Street;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
 
 import java.util.List;
 import java.util.Objects;
@@ -37,29 +39,27 @@ import static java.util.Objects.requireNonNull;
 public class Location {
     private final List<Integer> municipalities;
     private final List<Integer> counties;
-    private final List<Integer> regions;
-    private final List<Integer> departments;
     private final List<ContractArea> contractAreas;
     private final List<Route> nationalRoutes;
-    private final List<RoadRef> roadRefs;
+    private final List<RoadSysRef> roadSysRefs;
     private final List<Placement> placements;
+    private final List<Street> streets;
     private final Geometry geometry;
 
     private final Double length;
 
-    public Location(List<Integer> municipalities, List<Integer> counties, List<Integer> regions,
-                    List<Integer> departments, Double length, List<Placement> placements, List<RoadRef> roadRefs,
-                    List<ContractArea> contractAreas, List<Route> nationalRoutes, Geometry geometry) {
+    public Location(List<Integer> municipalities, List<Integer> counties,
+                    Double length, List<Placement> placements, List<RoadSysRef> RoadSysRefs,
+                    List<ContractArea> contractAreas, List<Route> nationalRoutes, List<Street> streets, Geometry geometry) {
         this.placements = placements;
         this.contractAreas = contractAreas;
         this.nationalRoutes = nationalRoutes;
+        this.streets = streets;
         this.geometry = geometry;
         this.municipalities = requireNonNull(municipalities);
         this.counties = requireNonNull(counties);
-        this.regions = requireNonNull(regions);
-        this.departments = requireNonNull(departments);
         this.length = length;
-        this.roadRefs = requireNonNull(roadRefs);
+        this.roadSysRefs = requireNonNull(RoadSysRefs);
     }
 
     public List<Integer> getMunicipalities() {
@@ -70,14 +70,6 @@ public class Location {
         return counties;
     }
 
-    public List<Integer> getRegions() {
-        return regions;
-    }
-
-    public List<Integer> getDepartments() {
-        return departments;
-    }
-
     public List<ContractArea> getContractAreas() {
         return contractAreas;
     }
@@ -86,8 +78,12 @@ public class Location {
         return nationalRoutes;
     }
 
-    public List<RoadRef> getRoadRefs() {
-        return roadRefs;
+    public List<Street> getStreets() {
+        return streets;
+    }
+
+    public List<RoadSysRef> getRoadSysRefs() {
+        return roadSysRefs;
     }
 
     public List<Placement> getPlacements() {
@@ -109,11 +105,10 @@ public class Location {
         Location location = (Location) o;
         return Objects.equals(municipalities, location.municipalities) &&
                 Objects.equals(counties, location.counties) &&
-                Objects.equals(regions, location.regions) &&
-                Objects.equals(departments, location.departments) &&
                 Objects.equals(contractAreas, location.contractAreas) &&
                 Objects.equals(nationalRoutes, location.nationalRoutes) &&
-                Objects.equals(roadRefs, location.roadRefs) &&
+                Objects.equals(streets, location.streets) &&
+                Objects.equals(roadSysRefs, location.roadSysRefs) &&
                 Objects.equals(placements, location.placements) &&
                 Objects.equals(geometry, location.geometry) &&
                 Objects.equals(length, location.length);
@@ -121,7 +116,7 @@ public class Location {
 
     @Override
     public int hashCode() {
-        return Objects.hash(municipalities, counties, regions, departments, contractAreas, nationalRoutes, roadRefs,
-                placements, geometry, length);
+        return Objects.hash(municipalities, counties, contractAreas, nationalRoutes, roadSysRefs,
+                streets, placements, geometry, length);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Placement.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Placement.java
index b9e470a..7861d4c 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Placement.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Placement.java
@@ -1,107 +1,12 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
 package no.vegvesen.nvdbapi.client.model.roadobjects;
 
-import no.vegvesen.nvdbapi.client.model.Direction;
-import no.vegvesen.nvdbapi.client.model.SidePosition;
-
-import java.util.Objects;
-
-public class Placement {
-    private final int netElementId;
-    private final double startPosition;
-    private final double endPosition;
-    private final Direction direction;
-    private final SidePosition sidePos;
-    private final String lane;
-
-    public Placement(int netElementId, double startPosition, double endPosition, Direction direction, SidePosition sidePos, String lane) {
-        this.netElementId = netElementId;
-        this.startPosition = startPosition;
-        this.endPosition = endPosition;
-        this.direction = direction;
-        this.sidePos = sidePos;
-        this.lane = lane;
-    }
-
-    public int getNetElementId() {
-        return netElementId;
-    }
-
-    public double getStartPosition() {
-        return startPosition;
-    }
-
-    public double getEndPosition() {
-        return endPosition;
-    }
-
-    public Direction getDirection() {
-        return direction;
-    }
-
-    public SidePosition getSidePos() {
-        return sidePos;
-    }
-
-    public boolean isPoint() {
-        return startPosition == endPosition;
-    }
-
-    public String getLane() {
-        return lane;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        Placement placement = (Placement) o;
-        return netElementId == placement.netElementId &&
-                Double.compare(placement.startPosition, startPosition) == 0 &&
-                Double.compare(placement.endPosition, endPosition) == 0 &&
-                direction == placement.direction &&
-                sidePos == placement.sidePos &&
-                Objects.equals(lane, placement.lane);
-    }
+public interface Placement {
 
-    @Override
-    public int hashCode() {
-        return Objects.hash(netElementId, startPosition, endPosition, direction, sidePos, lane);
+    default boolean isPointOrLine(){
+        return this instanceof RefLinkExtentPlacement;
     }
 
-    @Override
-    public String toString() {
-        return "Placement{" +
-                "netElementId=" + netElementId +
-                ", startPosition=" + startPosition +
-                ", endPosition=" + endPosition +
-                ", direction=" + direction +
-                ", sidePos=" + sidePos +
-                ", lane='" + lane + '\'' +
-                '}';
+    default boolean isTurn(){
+        return this instanceof TurnExtentPlacement;
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RefLinkExtentPlacement.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RefLinkExtentPlacement.java
new file mode 100644
index 0000000..95db01b
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RefLinkExtentPlacement.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2015-2017, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadobjects;
+
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.SidePosition;
+
+import java.util.List;
+import java.util.Objects;
+
+public class RefLinkExtentPlacement implements Placement {
+    private final long netElementId;
+    private final double startPosition;
+    private final double endPosition;
+    private final Direction direction;
+    private final SidePosition sidePos;
+    private final List<String> lane;
+
+    public RefLinkExtentPlacement(long netElementId,
+                                  double startPosition,
+                                  double endPosition,
+                                  Direction direction,
+                                  SidePosition sidePos,
+                                  List<String> lane) {
+        this.netElementId = netElementId;
+        this.startPosition = startPosition;
+        this.endPosition = endPosition;
+        this.direction = direction;
+        this.sidePos = sidePos;
+        this.lane = lane;
+    }
+
+    public long getNetElementId() {
+        return netElementId;
+    }
+
+    public double getStartPosition() {
+        return startPosition;
+    }
+
+    public double getEndPosition() {
+        return endPosition;
+    }
+
+    public Direction getDirection() {
+        return direction;
+    }
+
+    public SidePosition getSidePos() {
+        return sidePos;
+    }
+
+    public boolean isPoint() {
+        return startPosition == endPosition;
+    }
+
+    public List<String> getLane() {
+        return lane;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RefLinkExtentPlacement refLinkExtentPlacement = (RefLinkExtentPlacement) o;
+        return netElementId == refLinkExtentPlacement.netElementId &&
+                Double.compare(refLinkExtentPlacement.startPosition, startPosition) == 0 &&
+                Double.compare(refLinkExtentPlacement.endPosition, endPosition) == 0 &&
+                direction == refLinkExtentPlacement.direction &&
+                sidePos == refLinkExtentPlacement.sidePos &&
+                Objects.equals(lane, refLinkExtentPlacement.lane);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(netElementId, startPosition, endPosition, direction, sidePos, lane);
+    }
+
+    @Override
+    public String toString() {
+        return "Placement{" +
+                "netElementId=" + netElementId +
+                ", startPosition=" + startPosition +
+                ", endPosition=" + endPosition +
+                ", direction=" + direction +
+                ", sidePos=" + sidePos +
+                ", lane=" + lane +
+                '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObject.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObject.java
index 9636595..8b5cd7c 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObject.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObject.java
@@ -26,6 +26,7 @@
 package no.vegvesen.nvdbapi.client.model.roadobjects;
 
 import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.Attribute;
 
 import java.time.LocalDate;
 import java.time.LocalDateTime;
@@ -41,7 +42,6 @@ public class RoadObject {
     private final LocalDate endDate;
     private final Location location;
     private final Geometry geometry;
-    private final SegmentationFilter segmentationFilter;
     private final List<Segment> segments;
     private final List<Attribute> attributes;
     private final List<Association> children;
@@ -49,7 +49,7 @@ public class RoadObject {
     private final LocalDateTime lastModified;
 
     public RoadObject(long id, Integer typeId, Integer version, LocalDate startDate, LocalDate endDate,
-                      SegmentationFilter segmentationFilter, List<Segment> segments,
+                      List<Segment> segments,
                       Location location, Geometry geometry, LocalDateTime lastModified,
                       List<Attribute> attributes, List<Association> children, List<Association> parents) {
         this.id = id;
@@ -57,7 +57,6 @@ public class RoadObject {
         this.version = version;
         this.startDate = startDate;
         this.endDate = endDate;
-        this.segmentationFilter = segmentationFilter;
         this.segments = segments;
         this.location = location;
         this.geometry = geometry;
@@ -104,7 +103,19 @@ public class RoadObject {
     }
 
     public Attribute getAttribute(int attributeTypeId) {
-        return attributes.stream().filter(a -> a.getTypeId() == attributeTypeId).findAny().orElse(null);
+        return attributes.stream()
+            .filter(a -> a.getId() == attributeTypeId)
+            .findAny()
+            .orElse(null);
+    }
+
+    public <T extends Attribute> T getAttribute(int attributeTypeId, Class<T> attributeType) {
+        return attributes.stream()
+            .filter(a -> a.getId() == attributeTypeId)
+            .filter(a -> attributeType.isAssignableFrom(a.getClass()))
+            .map(attributeType::cast)
+            .findAny()
+            .orElse(null);
     }
 
     public Stream<Attribute> attributes() {
@@ -139,14 +150,6 @@ public class RoadObject {
         return location;
     }
 
-    public boolean isSegmented() {
-        return segmentationFilter != null;
-    }
-
-    public SegmentationFilter getSegmentationFilter() {
-        return segmentationFilter;
-    }
-
     public List<Segment> getSegments() {
         return segments;
     }
@@ -172,7 +175,6 @@ public class RoadObject {
                 Objects.equals(endDate, that.endDate) &&
                 Objects.equals(location, that.location) &&
                 Objects.equals(geometry, that.geometry) &&
-                Objects.equals(segmentationFilter, that.segmentationFilter) &&
                 Objects.equals(segments, that.segments) &&
                 Objects.equals(attributes, that.attributes) &&
                 Objects.equals(children, that.children) &&
@@ -183,7 +185,7 @@ public class RoadObject {
     @Override
     public int hashCode() {
 
-        return Objects.hash(id, typeId, version, startDate, endDate, location, geometry, segmentationFilter, segments,
+        return Objects.hash(id, typeId, version, startDate, endDate, location, geometry, segments,
                 attributes, children, parents, lastModified);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectAttribute.java
new file mode 100644
index 0000000..f9c0994
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectAttribute.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.roadobjects;
+
+import java.io.InputStream;
+import java.util.List;
+import java.util.Objects;
+
+public class RoadObjectAttribute {
+
+    private final List<String> contentType;
+    private final InputStream in;
+
+    public RoadObjectAttribute(List<String> contentType, InputStream in) {
+        this.contentType = contentType;
+        this.in = in;
+    }
+
+    public List<String> getContentType() {
+        return contentType;
+    }
+
+    public InputStream getIn() {
+        return in;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RoadObjectAttribute that = (RoadObjectAttribute) o;
+        return Objects.equals(getContentType(), that.getContentType()) &&
+            Objects.equals(getIn(), that.getIn());
+    }
+
+    @Override
+    public int hashCode() {
+
+        return Objects.hash(getContentType(), getIn());
+    }
+
+    @Override
+    public String toString() {
+        return "RoadObjectAttribute{" +
+            "contentType=" + contentType +
+            ", in=" + in +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Region.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectType.java
similarity index 55%
rename from src/main/java/no/vegvesen/nvdbapi/client/model/areas/Region.java
rename to src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectType.java
index 2e61550..8a6a644 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/Region.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2017, Statens vegvesen
+ * Copyright (c) 2015-2018, Statens vegvesen
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -23,64 +23,55 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.vegvesen.nvdbapi.client.model.areas;
+package no.vegvesen.nvdbapi.client.model.roadobjects;
 
-import no.vegvesen.nvdbapi.client.model.Geometry;
-
-import java.io.Serializable;
 import java.util.Objects;
-import java.util.Optional;
-
-public final class Region implements Serializable {
 
-    private final Optional<RoadObjectId> id;
-    private final int number;
+public class RoadObjectType {
+    private final Integer id;
     private final String name;
-    private final Optional<Geometry> boundingBox;
-    private final Optional<Geometry> centerPoint;
+    private final Statistics statistics;
 
-    public Region(RoadObjectId id, int number, String name, Geometry boundingBox, Geometry centerPoint) {
-        this.id = Optional.ofNullable(id);
-        this.number = number;
+    public RoadObjectType(Integer id, String name, Statistics statistics) {
+        this.id = id;
         this.name = name;
-        this.boundingBox = Optional.ofNullable(boundingBox);
-        this.centerPoint = Optional.ofNullable(centerPoint);
+        this.statistics = statistics;
     }
 
-    public Optional<RoadObjectId> getId() {
+    public Integer getId() {
         return id;
     }
 
-    public int getNumber() {
-        return number;
-    }
-
     public String getName() {
         return name;
     }
 
-    public Optional<Geometry> getBoundingBox() {
-        return boundingBox;
-    }
-
-    public Optional<Geometry> getCenterPoint() {
-        return centerPoint;
+    public Statistics getStatistics() {
+        return statistics;
     }
 
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-        Region region = (Region) o;
-        return number == region.number &&
-                Objects.equals(id, region.id) &&
-                Objects.equals(name, region.name) &&
-                Objects.equals(boundingBox, region.boundingBox) &&
-                Objects.equals(centerPoint, region.centerPoint);
+        RoadObjectType that = (RoadObjectType) o;
+        return Objects.equals(getId(), that.getId()) &&
+            Objects.equals(getName(), that.getName()) &&
+            Objects.equals(getStatistics(), that.getStatistics());
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(id, number, name, boundingBox, centerPoint);
+
+        return Objects.hash(getId(), getName(), getStatistics());
+    }
+
+    @Override
+    public String toString() {
+        return "RoadObjectType{" +
+            "id=" + id +
+            ", name='" + name + '\'' +
+            ", statistics=" + statistics +
+            '}';
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectTypeWithStats.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectTypeWithStats.java
new file mode 100644
index 0000000..09842b6
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadObjectTypeWithStats.java
@@ -0,0 +1,50 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects;
+
+import java.util.Objects;
+
+public class RoadObjectTypeWithStats {
+    private final int typeId;
+    private final String typeName;
+    private final Statistics statistics;
+
+    public RoadObjectTypeWithStats(int typeId, String typeName, Statistics statistics) {
+        this.typeId = typeId;
+        this.typeName = typeName;
+        this.statistics = statistics;
+    }
+
+    public int getTypeId() {
+        return typeId;
+    }
+
+    public String getTypeName() {
+        return typeName;
+    }
+
+    public Statistics getStatistics() {
+        return statistics;
+    }
+
+    @Override
+    public String toString() {
+        return "" +
+            "typeId=" + typeId +
+            ", name='" + typeName + '\'' +
+            ", statistics=" + statistics ;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RoadObjectTypeWithStats that = (RoadObjectTypeWithStats) o;
+        return typeId == that.typeId &&
+            Objects.equals(typeName, that.typeName) &&
+            Objects.equals(statistics, that.statistics);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(typeId, typeName, statistics);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadRef.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadRef.java
index d09abe6..c38021c 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadRef.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/RoadRef.java
@@ -28,90 +28,10 @@ package no.vegvesen.nvdbapi.client.model.roadobjects;
 import java.util.Objects;
 
 public class RoadRef {
-    private final Integer county;
-    private final Integer municipality;
+    private final Integer stretch;
 
-    private final String category;
-    private final String status;
-    private final int number;
-    private final int fromHp;
-    private final Integer toHp;
-    private final int fromMeter;
-    private final Integer toMeter;
-    private final String shortName;
-
-    private RoadRef(Integer county, Integer municipality, String category, String status, int number, int fromHp, Integer toHp, int fromMeter, Integer toMeter, String shortName) {
-        this.county = county;
-        this.municipality = municipality;
-        this.category = category;
-        this.status = status;
-        this.number = number;
-        this.fromHp = fromHp;
-        this.toHp = toHp;
-        this.fromMeter = fromMeter;
-        this.toMeter = toMeter;
-        this.shortName = shortName;
-    }
-
-    public static RoadRef merged(Integer county, Integer municipality, String category, String status, int number, int fromHp, Integer toHp, int fromMeter, Integer toMeter, String shortName) {
-        return new RoadRef(county, municipality, category, status, number, fromHp, toHp, fromMeter, toMeter, shortName);
-    }
-
-    public static RoadRef stretch(Integer county, Integer municipality, String category, String status, int number, int hp, int fromMeter, Integer toMeter, String shortName) {
-        return new RoadRef(county, municipality, category, status, number, hp, hp, fromMeter, toMeter, shortName);
-    }
-
-    public static RoadRef point(int county, int municipality, String roadCategory, String roadStatus, int roadNumber, int hp, int meter, String shortName) {
-        return new RoadRef(county, municipality, roadCategory, roadStatus, roadNumber, hp, null, meter, null, shortName);
-    }
-
-    public boolean isPoint() {
-        return toHp == null && toMeter == null;
-    }
-
-    public Integer getCounty() {
-        return county;
-    }
-
-    public Integer getMunicipality() {
-        return municipality;
-    }
-
-    public String getCategory() {
-        return category;
-    }
-
-    public String getStatus() {
-        return status;
-    }
-
-    public int getNumber() {
-        return number;
-    }
-
-    public int getFromHp() {
-        return fromHp;
-    }
-
-    public Integer getToHp() {
-        return toHp;
-    }
-
-    public int getFromMeter() {
-        return fromMeter;
-    }
-
-    public Integer getToMeter() {
-        return toMeter;
-    }
-
-    public String getShortName() {
-        return shortName;
-    }
-
-    @Override
-    public String toString() {
-        return getShortName();
+    public RoadRef(Integer stretch) {
+        this.stretch = stretch;
     }
 
     @Override
@@ -119,20 +39,11 @@ public class RoadRef {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         RoadRef roadRef = (RoadRef) o;
-        return number == roadRef.number &&
-                fromHp == roadRef.fromHp &&
-                fromMeter == roadRef.fromMeter &&
-                Objects.equals(county, roadRef.county) &&
-                Objects.equals(municipality, roadRef.municipality) &&
-                Objects.equals(category, roadRef.category) &&
-                Objects.equals(status, roadRef.status) &&
-                Objects.equals(toHp, roadRef.toHp) &&
-                Objects.equals(toMeter, roadRef.toMeter) &&
-                Objects.equals(shortName, roadRef.shortName);
+        return Objects.equals(stretch, roadRef.stretch);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(county, municipality, category, status, number, fromHp, toHp, fromMeter, toMeter, shortName);
+        return Objects.hash(stretch);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Segment.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Segment.java
index 0393ac3..ae40ed5 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Segment.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Segment.java
@@ -25,31 +25,61 @@
 
 package no.vegvesen.nvdbapi.client.model.roadobjects;
 
+import no.vegvesen.nvdbapi.client.model.Direction;
 import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.roadnet.DetailLevel;
+import no.vegvesen.nvdbapi.client.model.roadnet.RefLinkPartType;
+import no.vegvesen.nvdbapi.client.model.roadnet.TypeOfRoad;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
 
+import java.time.LocalDate;
 import java.util.Objects;
 
 public class Segment {
 
+    private final long netElementId;
+    private final double startPosition;
+    private final double endPosition;
+    private final Direction direction;
     private final Geometry geometry;
     private final int municipality;
     private final int county;
-    private final int region;
-    private final int roadDepartment;
-    private final Placement placement;
-    private final RoadRef roadRef;
+    private final RoadSysRef roadSysRef;
     private final Integer length;
-
-    public Segment(Geometry geometry, int municipality, int county, int region, int roadDepartment,
-                   Placement placement, RoadRef roadRef, Integer length) {
+    private final LocalDate startDate;
+    private final LocalDate endDate;
+    private final RefLinkPartType refLinkPartType;
+    private final DetailLevel detailLevel;
+    private final TypeOfRoad typeOfRoad;
+
+    public Segment(long netElementId,
+                   double startPosition,
+                   double endPosition,
+                   Direction direction,
+                   Geometry geometry,
+                   int municipality,
+                   int county,
+                   RoadSysRef roadSysRef,
+                   Integer length,
+                   LocalDate startDate,
+                   LocalDate endDate,
+                   RefLinkPartType refLinkPartType,
+                   DetailLevel detailLevel,
+                   TypeOfRoad typeOfRoad) {
+        this.netElementId = netElementId;
+        this.startPosition = startPosition;
+        this.endPosition = endPosition;
+        this.direction = direction;
         this.geometry = geometry;
         this.municipality = municipality;
         this.county = county;
-        this.region = region;
-        this.roadDepartment = roadDepartment;
-        this.placement = placement;
-        this.roadRef = roadRef;
+        this.roadSysRef = roadSysRef;
         this.length = length;
+        this.startDate = startDate;
+        this.endDate = endDate;
+        this.refLinkPartType = refLinkPartType;
+        this.detailLevel = detailLevel;
+        this.typeOfRoad = typeOfRoad;
     }
 
     public Geometry getGeometry() {
@@ -64,43 +94,74 @@ public class Segment {
         return county;
     }
 
-    public int getRegion() {
-        return region;
+    public long getNetElementId() {
+        return netElementId;
+    }
+
+    public double getStartPosition() {
+        return startPosition;
     }
 
-    public int getRoadDepartment() {
-        return roadDepartment;
+    public double getEndPosition() {
+        return endPosition;
     }
 
-    public Placement getPlacement() {
-        return placement;
+    public Direction getDirection() {
+        return direction;
     }
 
-    public RoadRef getRoadRef() {
-        return roadRef;
+    public RoadSysRef getRoadSysRef() {
+        return roadSysRef;
     }
 
     public Integer getLength() {
         return length;
     }
 
+    public LocalDate getStartDate() {
+        return startDate;
+    }
+
+    public LocalDate getEndDate() {
+        return endDate;
+    }
+
+    public DetailLevel getDetailLevel() {
+        return detailLevel;
+    }
+
+    public TypeOfRoad getTypeOfRoad() {
+        return typeOfRoad;
+    }
+
+    public RefLinkPartType getRefLinkPartType() {
+        return refLinkPartType;
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Segment segment = (Segment) o;
-        return municipality == segment.municipality &&
+        return netElementId == segment.netElementId &&
+                Double.compare(segment.startPosition, startPosition) == 0 &&
+                Double.compare(segment.endPosition, endPosition) == 0 &&
+                segment.direction == this.direction &&
+                municipality == segment.municipality &&
                 county == segment.county &&
-                region == segment.region &&
-                roadDepartment == segment.roadDepartment &&
                 Objects.equals(geometry, segment.geometry) &&
-                Objects.equals(placement, segment.placement) &&
-                Objects.equals(roadRef, segment.roadRef) &&
-                Objects.equals(length, segment.length);
+                Objects.equals(roadSysRef, segment.roadSysRef) &&
+                Objects.equals(length, segment.length) &&
+                Objects.equals(refLinkPartType, segment.refLinkPartType) &&
+                Objects.equals(detailLevel, segment.detailLevel) &&
+                Objects.equals(typeOfRoad, segment.typeOfRoad) &&
+                Objects.equals(startDate, segment.startDate) &&
+                Objects.equals(endDate, segment.endDate);
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(geometry, municipality, county, region, roadDepartment, placement, roadRef, length);
+        return Objects.hash(netElementId, startPosition, endPosition, direction, geometry, municipality, county,
+                roadSysRef, length, startDate, endDate, typeOfRoad, detailLevel, refLinkPartType);
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/SegmentationFilter.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/SegmentationFilter.java
deleted file mode 100644
index cbebbab..0000000
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/SegmentationFilter.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2015-2017, Statens vegvesen
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.vegvesen.nvdbapi.client.model.roadobjects;
-
-import java.util.Collections;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-
-public class SegmentationFilter {
-    private final List<Integer> municipalities;
-    private final List<Integer> counties;
-    private final List<Integer> regions;
-    private final List<Integer> roadDepartments;
-    private final List<RoadRefFilter> roadRefFilters;
-
-    public SegmentationFilter(List<Integer> municipalities, List<Integer> counties,
-                              List<Integer> regions, List<Integer> roadDepartments,
-                              List<RoadRefFilter> roadRefFilters) {
-        this.roadRefFilters = Optional.ofNullable(roadRefFilters).orElse(Collections.emptyList());
-        this.municipalities = Optional.ofNullable(municipalities).orElse(Collections.emptyList());
-        this.counties = Optional.ofNullable(counties).orElse(Collections.emptyList());
-        this.regions = Optional.ofNullable(regions).orElse(Collections.emptyList());
-        this.roadDepartments = Optional.ofNullable(roadDepartments).orElse(Collections.emptyList());
-    }
-
-    public List<RoadRefFilter> getRoadRefFilters() {
-        return roadRefFilters;
-    }
-
-    public List<Integer> getMunicipalities() {
-        return municipalities;
-    }
-
-    public List<Integer> getCounties() {
-        return counties;
-    }
-
-    public List<Integer> getRegions() {
-        return regions;
-    }
-
-    public List<Integer> getRoadDepartments() {
-        return roadDepartments;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-        SegmentationFilter that = (SegmentationFilter) o;
-        return Objects.equals(municipalities, that.municipalities) &&
-                Objects.equals(counties, that.counties) &&
-                Objects.equals(regions, that.regions) &&
-                Objects.equals(roadDepartments, that.roadDepartments) &&
-                Objects.equals(roadRefFilters, that.roadRefFilters);
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(municipalities, counties, regions, roadDepartments, roadRefFilters);
-    }
-}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Statistics.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Statistics.java
index 7bf10f2..9dc3954 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Statistics.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/Statistics.java
@@ -30,9 +30,9 @@ import java.util.Objects;
 public class Statistics {
 
     private final int numFound;
-    private final long length;
+    private final double length;
 
-    public Statistics(int numFound, long length) {
+    public Statistics(int numFound, double length) {
         this.numFound = numFound;
         this.length = length;
     }
@@ -41,10 +41,18 @@ public class Statistics {
         return numFound;
     }
 
-    public long getLength() {
+    public double getLength() {
         return length;
     }
 
+    @Override
+    public String toString() {
+        return "Statistics{" +
+                "numFound=" + numFound +
+                ", length=" + length +
+                '}';
+    }
+
     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/TurnExtentPlacement.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/TurnExtentPlacement.java
new file mode 100644
index 0000000..4e1b0cb
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/TurnExtentPlacement.java
@@ -0,0 +1,26 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects;
+
+public class TurnExtentPlacement implements Placement{
+
+    private final long nodeId;
+    private final RefLinkExtentPlacement startPosition;
+    private final RefLinkExtentPlacement endPosition;
+
+    public TurnExtentPlacement(long nodeId, RefLinkExtentPlacement startPosition, RefLinkExtentPlacement endPosition) {
+        this.nodeId = nodeId;
+        this.startPosition = startPosition;
+        this.endPosition = endPosition;
+    }
+
+    public long getNodeId() {
+        return nodeId;
+    }
+
+    public RefLinkExtentPlacement getStartPosition() {
+        return startPosition;
+    }
+
+    public RefLinkExtentPlacement getEndPosition() {
+        return endPosition;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/AssociationAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/AssociationAttribute.java
new file mode 100644
index 0000000..dedcc20
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/AssociationAttribute.java
@@ -0,0 +1,25 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+public class AssociationAttribute extends Attribute {
+
+    private final long featureId;
+
+    public AssociationAttribute(int id, long featureId) {
+        super(id);
+        this.featureId = featureId;
+    }
+
+    public long getFeatureId() {
+        return featureId;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return String.valueOf(featureId);
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.ASSOCIATION;
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/Attribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/Attribute.java
new file mode 100644
index 0000000..a23dec3
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/Attribute.java
@@ -0,0 +1,37 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.util.Objects;
+
+public abstract class Attribute {
+    private final int id;
+
+    public Attribute(int id) {
+        this.id = id;
+    }
+
+    public abstract AttributeType getAttributeType();
+
+    public int getId() {
+        return id;
+    }
+
+    public abstract String getValueAsString();
+
+    @Override
+    public String toString() {
+        return getClass().getSimpleName() + " " + id;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Attribute attribute = (Attribute) o;
+        return id == attribute.id;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(id);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/AttributeType.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/AttributeType.java
new file mode 100644
index 0000000..e0ecf1a
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/AttributeType.java
@@ -0,0 +1,19 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+public enum AttributeType {
+    ASSOCIATION,
+    BLOB,
+    BOOLEAN,
+    DATE,
+    ENUM,
+    INTEGER,
+    LIST,
+    REAL,
+    REFLINK_EXTENT,
+    SHORTDATE,
+    SPATIAL,
+    STRING,
+    STRUCT,
+    TIME,
+    TURN_EXTENT
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/BlobAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/BlobAttribute.java
new file mode 100644
index 0000000..fcdea9a
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/BlobAttribute.java
@@ -0,0 +1,58 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.util.Objects;
+
+public class BlobAttribute extends Attribute {
+
+    private final Integer blobId;
+    private final String blobFormat;
+    private final String href;
+
+    public BlobAttribute(int id,
+                         Integer blobId,
+                         String blobFormat,
+                         String href) {
+        super(id);
+        this.blobId = blobId;
+        this.blobFormat = blobFormat;
+        this.href = href;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.BLOB;
+    }
+
+    public String getBlobFormat() {
+        return blobFormat;
+    }
+
+    public Integer getBlobId() {
+        return blobId;
+    }
+
+    public String getHref() {
+        return href;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return href;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        BlobAttribute that = (BlobAttribute) o;
+        return Objects.equals(blobId, that.blobId) &&
+            Objects.equals(blobFormat, that.blobFormat) &&
+            Objects.equals(href, that.href);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), blobId, blobFormat, href);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/BooleanAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/BooleanAttribute.java
new file mode 100644
index 0000000..5784858
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/BooleanAttribute.java
@@ -0,0 +1,40 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.util.Objects;
+
+public class BooleanAttribute extends Attribute {
+    private final Boolean value;
+
+    public BooleanAttribute(int id, Boolean value) {
+        super(id);
+        this.value = value;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.BOOLEAN;
+    }
+
+    public Boolean getValue() {
+        return value;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return String.valueOf(value);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        BooleanAttribute that = (BooleanAttribute) o;
+        return Objects.equals(value, that.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/DateAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/DateAttribute.java
new file mode 100644
index 0000000..13602ea
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/DateAttribute.java
@@ -0,0 +1,43 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.time.LocalDate;
+import java.time.format.DateTimeFormatter;
+import java.util.Objects;
+
+public class DateAttribute extends Attribute {
+
+    private final LocalDate value;
+
+    public DateAttribute(int id, LocalDate value) {
+        super(id);
+        this.value = value;
+    }
+
+    public LocalDate getValue() {
+        return value;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.DATE;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return value.format(DateTimeFormatter.ISO_LOCAL_DATE);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        DateAttribute that = (DateAttribute) o;
+        return Objects.equals(value, that.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/EnumAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/EnumAttribute.java
new file mode 100644
index 0000000..75b4d23
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/EnumAttribute.java
@@ -0,0 +1,46 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.util.Objects;
+
+public abstract class EnumAttribute<T> extends Attribute {
+    private final Integer enumId;
+    private final T value;
+
+    public EnumAttribute(int id, Integer enumId, T value) {
+        super(id);
+        this.enumId = enumId;
+        this.value = value;
+    }
+
+    public Integer getEnumId() {
+        return enumId;
+    }
+
+    public T getValue() {
+        return value;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return enumId.toString();
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.ENUM;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        EnumAttribute that = (EnumAttribute) o;
+        return Objects.equals(enumId, that.enumId);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), enumId);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/IntegerAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/IntegerAttribute.java
new file mode 100644
index 0000000..542b5d8
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/IntegerAttribute.java
@@ -0,0 +1,53 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import no.vegvesen.nvdbapi.client.model.datakatalog.Unit;
+
+import java.util.Objects;
+
+public class IntegerAttribute extends Attribute {
+    private final Integer value;
+    private final Unit unit;
+
+    public IntegerAttribute(int id, Integer value) {
+        this(id, value, null);
+    }
+
+    public IntegerAttribute(int id, Integer value, Unit unit) {
+        super(id);
+        this.value = value;
+        this.unit = unit;
+    }
+
+    public Integer getValue() {
+        return value;
+    }
+
+    public Unit getUnit() {
+        return unit;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return String.valueOf(value);
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.INTEGER;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        IntegerAttribute that = (IntegerAttribute) o;
+        return Objects.equals(value, that.value) &&
+            Objects.equals(unit, that.unit);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), value, unit);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/IntegerEnumAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/IntegerEnumAttribute.java
new file mode 100644
index 0000000..9dc0272
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/IntegerEnumAttribute.java
@@ -0,0 +1,7 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+public class IntegerEnumAttribute extends EnumAttribute<Integer> {
+    public IntegerEnumAttribute(int id, Integer enumId, Integer value) {
+        super(id, enumId, value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ListAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ListAttribute.java
new file mode 100644
index 0000000..4bdf5db
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ListAttribute.java
@@ -0,0 +1,44 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+
+public class ListAttribute extends Attribute {
+    private final List<Attribute> attributes;
+
+    public ListAttribute(int id, List<Attribute> attributes) {
+        super(id);
+        this.attributes = attributes;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.LIST;
+    }
+
+    public List<Attribute> getAttributes() {
+        return attributes;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return attributes.stream()
+            .map(Attribute::getValueAsString)
+            .collect(Collectors.joining());
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        ListAttribute that = (ListAttribute) o;
+        return Objects.equals(attributes, that.attributes);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), attributes);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/LocationalAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/LocationalAttribute.java
new file mode 100644
index 0000000..2658af6
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/LocationalAttribute.java
@@ -0,0 +1,39 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import no.vegvesen.nvdbapi.client.model.roadnet.NetElementType;
+
+import java.util.Objects;
+
+public abstract class LocationalAttribute extends Attribute {
+
+    private final long netelementId;
+    private final NetElementType netelementType;
+
+    public LocationalAttribute(int id, long netelementId, NetElementType netelementType) {
+        super(id);
+        this.netelementId = netelementId;
+        this.netelementType = netelementType;
+    }
+
+    public long getNetelementId() {
+        return netelementId;
+    }
+
+    public NetElementType getNetelementType() {
+        return netelementType;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        LocationalAttribute that = (LocationalAttribute) o;
+        return netelementId == that.netelementId &&
+            netelementType == that.netelementType;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(netelementId, netelementType);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/RealAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/RealAttribute.java
new file mode 100644
index 0000000..a5c86e1
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/RealAttribute.java
@@ -0,0 +1,53 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import no.vegvesen.nvdbapi.client.model.datakatalog.Unit;
+
+import java.util.Objects;
+
+public class RealAttribute extends Attribute {
+
+    private final Double value;
+    private final Unit unit;
+
+    public RealAttribute(int id, Double value) {
+        this(id, value, null);
+    }
+
+    public RealAttribute(int id, Double value, Unit unit) {
+        super(id);
+        this.value = value;
+        this.unit = unit;
+    }
+
+    public Double getValue() {
+        return value;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.REAL;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return String.valueOf(value);
+    }
+
+    public Unit getUnit() {
+        return unit;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        RealAttribute that = (RealAttribute) o;
+        return Objects.equals(value, that.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/RealEnumAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/RealEnumAttribute.java
new file mode 100644
index 0000000..bf8a0aa
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/RealEnumAttribute.java
@@ -0,0 +1,7 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+public class RealEnumAttribute extends EnumAttribute<Double> {
+    public RealEnumAttribute(int id, Integer enumId, Double value) {
+        super(id, enumId, value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ReflinkExtentAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ReflinkExtentAttribute.java
new file mode 100644
index 0000000..28fce22
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ReflinkExtentAttribute.java
@@ -0,0 +1,75 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.SidePosition;
+import no.vegvesen.nvdbapi.client.model.roadnet.NetElementType;
+
+import java.util.List;
+import java.util.Objects;
+
+public class ReflinkExtentAttribute extends LocationalAttribute {
+
+    private final Direction direction;
+    private final SidePosition sidePosition;
+    private final List<String> lanes;
+    private final Double startLoc;
+    private final Double endLoc;
+
+    public ReflinkExtentAttribute(int id, long netelementId, Direction direction, SidePosition sidePosition,
+                                  List<String> lanes, Double startLoc, Double endLoc) {
+        super(id, netelementId, NetElementType.LENKE);
+        this.direction = direction;
+        this.sidePosition = sidePosition;
+        this.lanes = lanes;
+        this.startLoc = startLoc;
+        this.endLoc = endLoc;
+    }
+
+    public Double getStartLoc() {
+        return startLoc;
+    }
+
+    public Double getEndLoc() {
+        return endLoc;
+    }
+
+    public Direction getDirection() {
+        return direction;
+    }
+
+    public SidePosition getSidePosition() {
+        return sidePosition;
+    }
+
+    public List<String> getLanes() {
+        return lanes;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.REFLINK_EXTENT;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return startLoc + "-" + endLoc + "@" + getNetelementId();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        ReflinkExtentAttribute that = (ReflinkExtentAttribute) o;
+        return direction == that.direction &&
+            sidePosition == that.sidePosition &&
+            Objects.equals(lanes, that.lanes) &&
+            Objects.equals(startLoc, that.startLoc) &&
+            Objects.equals(endLoc, that.endLoc);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), direction, sidePosition, lanes, startLoc, endLoc);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ShortDateAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ShortDateAttribute.java
new file mode 100644
index 0000000..03d4c23
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/ShortDateAttribute.java
@@ -0,0 +1,42 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.time.MonthDay;
+import java.time.format.DateTimeFormatter;
+import java.util.Objects;
+
+public class ShortDateAttribute extends Attribute {
+    private final MonthDay value;
+
+    public ShortDateAttribute(int id, MonthDay value) {
+        super(id);
+        this.value = value;
+    }
+
+    public MonthDay getValue() {
+        return value;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.SHORTDATE;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return value.format(DateTimeFormatter.ofPattern("--MM-dd"));
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        ShortDateAttribute that = (ShortDateAttribute) o;
+        return Objects.equals(value, that.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/SpatialAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/SpatialAttribute.java
new file mode 100644
index 0000000..baa0397
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/SpatialAttribute.java
@@ -0,0 +1,42 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import no.vegvesen.nvdbapi.client.model.Geometry;
+
+import java.util.Objects;
+
+public class SpatialAttribute extends Attribute {
+    private final Geometry geometry;
+
+    public SpatialAttribute(int id, Geometry geometry) {
+        super(id);
+        this.geometry = geometry;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.SPATIAL;
+    }
+
+    public Geometry getGeometry() {
+        return geometry;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return geometry.getWkt();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        SpatialAttribute that = (SpatialAttribute) o;
+        return Objects.equals(geometry, that.geometry);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), geometry);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StringAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StringAttribute.java
new file mode 100644
index 0000000..e20d34e
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StringAttribute.java
@@ -0,0 +1,41 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.util.Objects;
+
+public class StringAttribute extends Attribute {
+
+    private final String value;
+
+    public StringAttribute(int id, String value) {
+        super(id);
+        this.value = value;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.STRING;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return value;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        StringAttribute that = (StringAttribute) o;
+        return Objects.equals(value, that.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StringEnumAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StringEnumAttribute.java
new file mode 100644
index 0000000..973e469
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StringEnumAttribute.java
@@ -0,0 +1,7 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+public class StringEnumAttribute extends EnumAttribute<String> {
+    public StringEnumAttribute(int id, Integer enumId, String value) {
+        super(id, enumId, value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StructAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StructAttribute.java
new file mode 100644
index 0000000..267b716
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/StructAttribute.java
@@ -0,0 +1,44 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
+
+public class StructAttribute extends Attribute {
+    private final List<Attribute> attributes;
+
+    public StructAttribute(int id, List<Attribute> attributes) {
+        super(id);
+        this.attributes = attributes;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.STRUCT;
+    }
+
+    public List<Attribute> getAttributes() {
+        return attributes;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return attributes.stream()
+            .map(Attribute::getValueAsString)
+            .collect(Collectors.joining());
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        StructAttribute that = (StructAttribute) o;
+        return Objects.equals(attributes, that.attributes);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), attributes);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/TimeAttribute.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/TimeAttribute.java
new file mode 100644
index 0000000..d7d0e36
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/TimeAttribute.java
@@ -0,0 +1,43 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import java.time.LocalTime;
+import java.time.format.DateTimeFormatter;
+import java.util.Objects;
+
+public class TimeAttribute extends Attribute {
+
+    private final LocalTime value;
+
+    public TimeAttribute(int id, LocalTime value) {
+        super(id);
+        this.value = value;
+    }
+
+    public LocalTime getValue() {
+        return value;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.TIME;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return value.format(DateTimeFormatter.ISO_LOCAL_TIME);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        TimeAttribute that = (TimeAttribute) o;
+        return Objects.equals(value, that.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), value);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/TurnExtent.java b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/TurnExtent.java
new file mode 100644
index 0000000..8e1a160
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/roadobjects/attribute/TurnExtent.java
@@ -0,0 +1,52 @@
+package no.vegvesen.nvdbapi.client.model.roadobjects.attribute;
+
+import no.vegvesen.nvdbapi.client.model.roadnet.NetElementType;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RefLinkExtentPlacement;
+
+import java.util.Objects;
+
+public class TurnExtent extends LocationalAttribute {
+
+    private final RefLinkExtentPlacement startPoint;
+    private final RefLinkExtentPlacement endPoint;
+
+    public TurnExtent(int id, long netelementId,
+                      RefLinkExtentPlacement startPoint, RefLinkExtentPlacement endPoint) {
+        super(id, netelementId, NetElementType.NODE);
+        this.startPoint = startPoint;
+        this.endPoint = endPoint;
+    }
+
+    public RefLinkExtentPlacement getStartPoint() {
+        return startPoint;
+    }
+
+    public RefLinkExtentPlacement getEndPoint() {
+        return endPoint;
+    }
+
+    @Override
+    public AttributeType getAttributeType() {
+        return AttributeType.TURN_EXTENT;
+    }
+
+    @Override
+    public String getValueAsString() {
+        return null;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        if (!super.equals(o)) return false;
+        TurnExtent that = (TurnExtent) o;
+        return Objects.equals(startPoint, that.startPoint) &&
+            Objects.equals(endPoint, that.endPoint);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(super.hashCode(), startPoint, endPoint);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObject.java b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObject.java
new file mode 100644
index 0000000..63114f5
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObject.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.transaction;
+
+import java.util.Objects;
+
+public class RoadObject {
+
+    private final int id;
+    private final RoadObjectMetadata roadObjectMetadata;
+    private final Type type;
+
+    public RoadObject(int id, RoadObjectMetadata roadObjectMetadata, Type type) {
+        this.id = id;
+        this.roadObjectMetadata = roadObjectMetadata;
+        this.type = type;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public RoadObjectMetadata getRoadObjectMetadata() {
+        return roadObjectMetadata;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RoadObject that = (RoadObject) o;
+        return getId() == that.getId() &&
+            Objects.equals(getRoadObjectMetadata(), that.getRoadObjectMetadata()) &&
+            getType() == that.getType();
+    }
+
+    @Override
+    public int hashCode() {
+
+        return Objects.hash(getId(), getRoadObjectMetadata(), getType());
+    }
+
+    @Override
+    public String toString() {
+        return "RoadObject{" +
+            "id=" + id +
+            ", roadObjectMetadata=" + roadObjectMetadata +
+            ", type=" + type +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObjectMetadata.java b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObjectMetadata.java
new file mode 100644
index 0000000..b203c54
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObjectMetadata.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.transaction;
+
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.util.Objects;
+
+public class RoadObjectMetadata {
+
+    private final RoadObjectType roadObjectType;
+    private final Integer version;
+    private final LocalDate startDate;
+    private final LocalDate endDate;
+    private final LocalDateTime lastModified;
+
+    public RoadObjectMetadata(RoadObjectType roadObjectType, Integer version, LocalDate startDate, LocalDate endDate, LocalDateTime lastModified) {
+        this.roadObjectType = roadObjectType;
+        this.version = version;
+        this.startDate = startDate;
+        this.endDate = endDate;
+        this.lastModified = lastModified;
+    }
+
+    public RoadObjectType getRoadObjectType() {
+        return roadObjectType;
+    }
+
+    public Integer getVersion() {
+        return version;
+    }
+
+    public LocalDate getStartDate() {
+        return startDate;
+    }
+
+    public LocalDate getEndDate() {
+        return endDate;
+    }
+
+    public LocalDateTime getLastModified() {
+        return lastModified;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        RoadObjectMetadata that = (RoadObjectMetadata) o;
+        return getVersion().equals(that.getVersion()) &&
+            Objects.equals(getRoadObjectType(), that.getRoadObjectType()) &&
+            Objects.equals(getStartDate(), that.getStartDate()) &&
+            Objects.equals(getEndDate(), that.getEndDate()) &&
+            Objects.equals(getLastModified(), that.getLastModified());
+    }
+
+    @Override
+    public int hashCode() {
+
+        return Objects.hash(getRoadObjectType(), getVersion(), getStartDate(), getEndDate(), getLastModified());
+    }
+
+    @Override
+    public String toString() {
+        return "RoadObjectMetadata{" +
+            "roadObjectType=" + roadObjectType +
+            ", version=" + version +
+            ", startDate=" + startDate +
+            ", endDate=" + endDate +
+            ", lastModified=" + lastModified +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/RoadDepartment.java b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObjectType.java
similarity index 69%
rename from src/main/java/no/vegvesen/nvdbapi/client/model/areas/RoadDepartment.java
rename to src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObjectType.java
index 48c4371..c92b3a7 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/model/areas/RoadDepartment.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/RoadObjectType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2015-2017, Statens vegvesen
+ * Copyright (c) 2015-2018, Statens vegvesen
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -23,32 +23,24 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-package no.vegvesen.nvdbapi.client.model.areas;
+package no.vegvesen.nvdbapi.client.model.transaction;
 
-import java.io.Serializable;
 import java.util.Objects;
-import java.util.Optional;
 
-public final class RoadDepartment implements Serializable {
+public class RoadObjectType {
 
-    private final Optional<RoadObjectId> id;
-    private final int number;
+    private final int id;
     private final String name;
 
-    public RoadDepartment(RoadObjectId id, int number, String name) {
-        this.id = Optional.ofNullable(id);
-        this.number = number;
+    public RoadObjectType(int id, String name) {
+        this.id = id;
         this.name = name;
     }
 
-    public Optional<RoadObjectId> getId() {
+    public int getId() {
         return id;
     }
 
-    public int getNumber() {
-        return number;
-    }
-
     public String getName() {
         return name;
     }
@@ -57,14 +49,22 @@ public final class RoadDepartment implements Serializable {
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-        RoadDepartment that = (RoadDepartment) o;
-        return number == that.number &&
-                Objects.equals(id, that.id) &&
-                Objects.equals(name, that.name);
+        RoadObjectType that = (RoadObjectType) o;
+        return getId() == that.getId() &&
+            Objects.equals(getName(), that.getName());
     }
 
     @Override
     public int hashCode() {
-        return Objects.hash(id, number, name);
+
+        return Objects.hash(getId(), getName());
+    }
+
+    @Override
+    public String toString() {
+        return "RoadObjectType{" +
+            "id=" + id +
+            ", name='" + name + '\'' +
+            '}';
     }
 }
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/Transaction.java b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/Transaction.java
new file mode 100644
index 0000000..0ec61b7
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/Transaction.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.transaction;
+
+import java.util.List;
+import java.util.Objects;
+
+public class Transaction {
+
+    private final TransactionId transactionId;
+    private final Integer taskTypeId;
+    private final String userId;
+    private final List<RoadObject> roadObjects;
+
+    public Transaction(TransactionId transactionId, Integer taskTypeId, String userId, List<RoadObject> roadObjects) {
+        this.transactionId = transactionId;
+        this.taskTypeId = taskTypeId;
+        this.userId = userId;
+        this.roadObjects = roadObjects;
+    }
+
+    public TransactionId getTransactionId() {
+        return transactionId;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public List<RoadObject> getRoadObjects() {
+        return roadObjects;
+    }
+
+    public Integer getTaskTypeId() {
+        return taskTypeId;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Transaction that = (Transaction) o;
+        return Objects.equals(getTransactionId(), that.getTransactionId()) &&
+            Objects.equals(getTaskTypeId(), that.getTaskTypeId()) &&
+            Objects.equals(getUserId(), that.getUserId()) &&
+            Objects.equals(getRoadObjects(), that.getRoadObjects());
+    }
+
+    @Override
+    public int hashCode() {
+
+        return Objects.hash(getTransactionId(), getTaskTypeId(), getUserId(), getRoadObjects());
+    }
+
+    @Override
+    public String toString() {
+        return "Transaction{" +
+            "transactionId=" + transactionId +
+            ", taskTypeId=" + taskTypeId +
+            ", userId='" + userId + '\'' +
+            ", roadObjects=" + roadObjects +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/TransactionId.java b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/TransactionId.java
new file mode 100644
index 0000000..45b5121
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/TransactionId.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.transaction;
+
+import java.time.LocalDateTime;
+import java.util.Objects;
+
+public class TransactionId {
+
+    private final Integer taskId;
+    private final LocalDateTime dateTime;
+
+    public TransactionId(Integer taskId, LocalDateTime dateTime) {
+        this.taskId = taskId;
+        this.dateTime = dateTime;
+    }
+
+    public Integer getTaskId() {
+        return taskId;
+    }
+
+
+
+    public LocalDateTime getDateTime() {
+        return dateTime;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        TransactionId that = (TransactionId) o;
+        return Objects.equals(getTaskId(), that.getTaskId()) &&
+            Objects.equals(getDateTime(), that.getDateTime());
+    }
+
+    @Override
+    public int hashCode() {
+
+        return Objects.hash(getTaskId(), getDateTime());
+    }
+
+    @Override
+    public String toString() {
+        return "TransactionId{" +
+            "taskId=" + taskId +
+            ", dateTime=" + dateTime +
+            '}';
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/Type.java b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/Type.java
new file mode 100644
index 0000000..92eb292
--- /dev/null
+++ b/src/main/java/no/vegvesen/nvdbapi/client/model/transaction/Type.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015-2018, Statens vegvesen
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ *    list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package no.vegvesen.nvdbapi.client.model.transaction;
+
+import java.util.Arrays;
+
+public enum Type {
+    CHANGED("ENDRET"),
+    CREATED("OPPRETTET"),
+    DELETED("SLETTET");
+
+    private final String apiValue;
+
+    Type(String apiValue) {
+        this.apiValue = apiValue;
+    }
+
+    public static Type from(String apiValue){
+        return Arrays.stream(values()).filter(t -> t.apiValue.equalsIgnoreCase(apiValue)).findAny().orElse(null);
+    }
+}
diff --git a/src/main/java/no/vegvesen/nvdbapi/client/util/LoggingFilter.java b/src/main/java/no/vegvesen/nvdbapi/client/util/LoggingFilter.java
index dae0eb1..acc7c2c 100644
--- a/src/main/java/no/vegvesen/nvdbapi/client/util/LoggingFilter.java
+++ b/src/main/java/no/vegvesen/nvdbapi/client/util/LoggingFilter.java
@@ -107,7 +107,7 @@ public class LoggingFilter implements ClientRequestFilter, ClientResponseFilter,
     }
 
     private StringBuilder prefixId(StringBuilder b, long id) {
-        b.append(Long.toString(id)).append(" ");
+        b.append(id).append(" ");
         return b;
     }
 
@@ -121,7 +121,7 @@ public class LoggingFilter implements ClientRequestFilter, ClientResponseFilter,
         prefixId(b, id).append(NOTIFICATION_PREFIX).
                 append("LoggingFilter - Response received on thread ").append(Thread.currentThread().getName()).append("\n");
         prefixId(b, id).append(RESPONSE_PREFIX).
-                append(Integer.toString(status)).
+                append(status).
                 append("\n");
     }
 
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/clients/ClientConfigurationTest.java b/src/test/java/no/vegvesen/nvdbapi/client/clients/ClientConfigurationTest.java
new file mode 100644
index 0000000..7927853
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/clients/ClientConfigurationTest.java
@@ -0,0 +1,56 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import javax.ws.rs.ProcessingException;
+
+import com.github.tomakehurst.wiremock.WireMockServer;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+import no.vegvesen.nvdbapi.client.ClientConfiguration.ClientConfigurationBuilder;
+
+import java.util.Random;
+
+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
+import static com.github.tomakehurst.wiremock.client.WireMock.configureFor;
+import static com.github.tomakehurst.wiremock.client.WireMock.get;
+import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;
+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
+import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.options;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+public class ClientConfigurationTest {
+
+    private static WireMockServer wireMockServer;
+
+    @BeforeAll
+    public static void setUp() {
+        wireMockServer = new WireMockServer(options().port(1024 + new Random().nextInt(20000)));
+        wireMockServer.start();
+    }
+
+    @AfterAll
+    public static void cleanUp() {
+        wireMockServer.stop();
+    }
+
+    @Test
+    public void shouldHonorReadTimeout() {
+        configureFor("localhost", wireMockServer.port());
+        int delayInMillis = 200;
+        stubFor(get(urlEqualTo("/vegobjekttyper/versjon")).willReturn(
+                aResponse()
+                        .withStatus(200)
+                        .withFixedDelay(delayInMillis)));
+
+        ClientFactory clientFactory = new ClientFactory(wireMockServer.baseUrl(),
+                "nvdbapi-client-test", ClientConfigurationBuilder.builder()
+                                                                 .withReadTimeout(delayInMillis - 100)
+                                                                 .withConnectTimeout(delayInMillis * 10)
+                                                                 .build());
+        Exception exception = Assertions.assertThrows(ProcessingException.class, clientFactory::getDatakatalog);
+        assertTrue(exception.getMessage()
+                            .contains("Timeout"));
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilderTest.java b/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilderTest.java
index 519c75f..c4ac6f2 100644
--- a/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilderTest.java
+++ b/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadObjectRequestBuilderTest.java
@@ -26,12 +26,14 @@
 
 package no.vegvesen.nvdbapi.client.clients;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 import javax.ws.rs.core.MultivaluedMap;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
+@SuppressWarnings("WeakerAccess")
 public class RoadObjectRequestBuilderTest {
 
     @Test
@@ -40,4 +42,12 @@ public class RoadObjectRequestBuilderTest {
         MultivaluedMap<String, String> actual = RoadObjectRequestBuilder.convert(req);
         assertEquals(0, actual.size());
     }
-}
\ No newline at end of file
+
+    // issue 105
+    @Test
+    public void testEmptyRoadObjReq() {
+        RoadObjectRequest req = RoadObjectRequest.DEFAULT;
+        RoadObjectRequest.Builder b = req.toMutable();
+        assertNotNull(b);
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadnetClientTest.java b/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadnetClientTest.java
new file mode 100644
index 0000000..36d1dd8
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadnetClientTest.java
@@ -0,0 +1,31 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import no.vegvesen.nvdbapi.client.util.Stopwatch;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+
+public class RoadnetClientTest {
+
+    @Test
+    @Disabled("manual test")
+    void downloadSegmentedRoadnet() {
+        Stopwatch started = Stopwatch.createStarted();
+
+        ClientFactory clientFactory = new ClientFactory("https://nvdbapiles-v3.atlas.vegvesen.no",
+             "nvdbapi-client-test");
+        SegmentedRoadNetClient segmentedRoadNetService = clientFactory.getSegmentedRoadNetService();
+
+        SegmentedRoadNetClient.AsyncSegmentedLinkResult result = segmentedRoadNetService.getLinksAsync(
+            RoadNetRequest
+                .newBuilder()
+                .withHistory(true)
+                .build());
+        result.get()
+            .toStream()
+            .forEach(element -> {
+                System.out.println(element.getId());
+            });
+        Stopwatch stop = started.stop();
+        System.out.println(stop.elapsedMillis());
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadobjectClientTest.java b/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadobjectClientTest.java
new file mode 100644
index 0000000..63dac5b
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/clients/RoadobjectClientTest.java
@@ -0,0 +1,33 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import no.vegvesen.nvdbapi.client.util.Stopwatch;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+
+@SuppressWarnings("WeakerAccess")
+public class RoadobjectClientTest {
+
+    @Test
+    @Disabled("manual test")
+    void downloadAll() {
+        Stopwatch started = Stopwatch.createStarted();
+        ClientFactory clientFactory = new ClientFactory("https://nvdbapiles-v3.atlas.vegvesen.no",
+                 "nvdbapi-client-test");
+        RoadObjectClient roadNetService = clientFactory.getRoadObjectClient();
+
+        RoadObjectClient.AsyncRoadObjectsResult result = roadNetService.getRoadObjectsAsync(
+                105,
+                RoadObjectRequest
+                        .newBuilder()
+                        .includeAll()
+                        .withAllVersions(Boolean.TRUE)
+                        .build());
+        result.get()
+                .toStream()
+                .forEach(element -> {
+                        System.out.println("Object: " + element.getId() + " " + element.getVersion());
+                });
+        Stopwatch stop = started.stop();
+        System.out.println(stop.elapsedMillis());
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/clients/TransactionsClientTest.java b/src/test/java/no/vegvesen/nvdbapi/client/clients/TransactionsClientTest.java
new file mode 100644
index 0000000..e3bcafb
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/clients/TransactionsClientTest.java
@@ -0,0 +1,27 @@
+package no.vegvesen.nvdbapi.client.clients;
+
+import no.vegvesen.nvdbapi.client.util.Stopwatch;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+
+public class TransactionsClientTest {
+
+    @Test
+    @Disabled("manual test")
+    void downloadTransacyions() {
+        Stopwatch started = Stopwatch.createStarted();
+        ClientFactory clientFactory = new ClientFactory("https://nvdbapiles-v3.atlas.vegvesen.no",
+                "nvdbapi-client-test");
+        TransactionsClient roadNetService = clientFactory.getTransactionsClient();
+
+        TransactionsClient.AsyncTransacionsResult result = roadNetService
+                .getTransactionsAsync(TransactionsRequest.DEFAULT);
+        result.get()
+                .toStream()
+                .forEach(element -> {
+                    System.out.println(element.getTransactionId());
+                });
+        Stopwatch stop = started.stop();
+        System.out.println(stop.elapsedMillis());
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/AreaParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/AreaParserTest.java
new file mode 100644
index 0000000..7664cb2
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/AreaParserTest.java
@@ -0,0 +1,48 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import com.google.gson.JsonObject;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.function.Function;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parsePlainList;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
+
+class AreaParserTest {
+    @Test
+    void parseFylker() throws IOException {
+        doParse("omrader/fylker.json", AreaParser::parseCounty);
+    }
+
+    @Test
+    void parseKommuner() throws IOException {
+        doParse("omrader/kommuner.json", AreaParser::parseMun);
+    }
+
+    @Test
+    void parseKontraktsomrader() throws IOException {
+        doParse("omrader/kontraktsomrader.json", AreaParser::parseContractArea);
+    }
+
+    @Test
+    void parseRiksvegruter() throws IOException {
+        doParse("omrader/riksvegruter.json", AreaParser::parseRoute);
+    }
+
+    @Test
+    void parseGater() throws IOException {
+        doParse("omrader/gater.json", AreaParser::parseStreet);
+    }
+
+    private <T> void doParse(String file, Function<JsonObject, T> mapper) throws IOException {
+        List<T> list = parsePlainList(file, mapper);
+        long count = list.size();
+        assertThat(count, is(not(0)));
+    }
+
+}
+
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/GsonUtilTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/GsonUtilTest.java
index afa5857..7e174e1 100644
--- a/src/test/java/no/vegvesen/nvdbapi/client/gson/GsonUtilTest.java
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/GsonUtilTest.java
@@ -27,36 +27,18 @@ package no.vegvesen.nvdbapi.client.gson;
 
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParser;
-import no.vegvesen.nvdbapi.client.model.Quality;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
-import static org.junit.Assert.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
 
 public class GsonUtilTest {
 
-    String jsonResponse = "{\"id\":615921663,\"href\":\"https://www.vegvesen.no/nvdb/api/v2/vegobjekter/83/615921663\",\"metadata\":{\"type\":{\"id\":83,\"navn\":\"Kum\"},\"versjon\":1,\"startdato\":\"2015-07-30\",\"sist_modifisert\":\"2018-01-01T01:11:53\"},\"egenskaper\":[{\"id\":1141,\"navn\":\"Type\",\"datatype\":30,\"datatype_tekst\":\"FlerverdiAttributt, Tekst\",\"verdi\":\"Standard kum m sandfang\",\"enum_id\":4146},{\"id\":1269,\"navn\":\"Bruksområde\",\"datatype\":30,\"datatype_tekst\":\"FlerverdiAttributt, Tekst\",\"verdi\":\"Drenering\",\"enum_id\":2936},{\"id\":1411,\"navn\":\"Materialtype\",\"datatype\":30,\"datatype_tekst\":\"FlerverdiAttributt, Tekst\",\"verdi\":\"Betong\",\"enum_id\":2211},{\"id\":1586,\"navn\":\"Dybde\",\"datatype\":2,\"datatype_tekst\":\"Tall\",\"verdi\":3.1,\"enhet\":{\"id\":1,\"navn\":\"Meter\",\"kortnavn\":\"m\"}},{\"id\":1727,\"navn\":\"Diameter\",\"datatype\":2,\"datatype_tekst\":\"Tall\",\"verdi\":1.0,\"enhet\":{\"id\":1,\"navn\":\"Meter\",\"kortnavn\":\"m\"}},{\"id\":2079,\"navn\":\"Dybde til utløp\",\"datatype\":2,\"datatype_tekst\":\"Tall\",\"verdi\":2.1,\"enhet\":{\"id\":1,\"navn\":\"Meter\",\"kortnavn\":\"m\"}},{\"id\":2122,\"navn\":\"Inngår i drenssystem\",\"datatype\":30,\"datatype_tekst\":\"FlerverdiAttributt, Tekst\",\"verdi\":\"Ja\",\"enum_id\":3547},{\"id\":2289,\"navn\":\"Diameter, åpning\",\"datatype\":2,\"datatype_tekst\":\"Tall\",\"verdi\":0.6,\"enhet\":{\"id\":1,\"navn\":\"Meter\",\"kortnavn\":\"m\"}},{\"id\":2290,\"navn\":\"Lokk/rist, type\",\"datatype\":30,\"datatype_tekst\":\"FlerverdiAttributt, Tekst\",\"verdi\":\"Tett lokk, støpjern\",\"enum_id\":4149},{\"id\":2388,\"navn\":\"Avstand fra vegkant\",\"datatype\":2,\"datatype_tekst\":\"Tall\",\"verdi\":0.4,\"enhet\":{\"id\":1,\"navn\":\"Meter\",\"kortnavn\":\"m\"}},{\"id\":4784,\"navn\":\"Geometri, punkt\",\"datatype\":17,\"datatype_tekst\":\"GeomPunkt\",\"verdi\":\"POINT (258127.12 7034288.74 106.66)\",\"kvalitet\":{\"målemetode\":11,\"nøyaktighet\":15,\"synbarhet\":0,\"målemetodeHøyde\":11,\"nøyaktighetHøyde\":15}},{\"id\":7065,\"navn\":\"Etableringsår\",\"datatype\":2,\"datatype_tekst\":\"Tall\",\"verdi\":2014}],\"geometri\":{\"wkt\":\"POINT Z (258127.12 7034288.74 106.66)\",\"srid\":32633,\"egengeometri\":true},\"lokasjon\":{\"kommuner\":[5001],\"fylker\":[50],\"regioner\":[4],\"vegavdelinger\":[50],\"kontraktsområder\":[{\"navn\":\"1609 TrondheimBydrift 2006-2010\"},{\"navn\":\"1606 TrondheimMalvik 2010-2015\"},{\"navn\":\"1609 Trondheim ytre 2015-2020\"},{\"navn\":\"1633 Fylkesveger i Trondheim Ytre 2016-2020\"}],\"vegreferanser\":[{\"fylke\":50,\"kommune\":0,\"kategori\":\"F\",\"status\":\"V\",\"nummer\":6652,\"hp\":1,\"meter\":13998,\"kortform\":\"5000 Fv6652 hp1 m13998\"}],\"stedfestinger\":[{\"veglenkeid\":42830,\"posisjon\":0.951965961208373,\"kortform\":\"0.951965961208373@42830\",\"retning\":\"MED\",\"sideposisjon\":\"H\"}],\"geometri\":{\"wkt\":\"POINT Z (258126.16992 7034291.08949 106.72683)\",\"srid\":32633}},\"relasjoner\":{}}";
-
     @Test
     public void testGetStringMember() {
-        JsonObject e = new JsonParser().parse("{\"id\":81456352,\"type\":{\"id\":105,\"navn\":\"Fartsgrense\"},\"versjon\":{\"id\":3,\"startdato\":\"2010-02-02\",\"segment\":{\"startdato\":\"2014-09-01\",\"enddato\":\"2019-09-01\"}},\"egenskaper\":[{\"id\":2021,\"navn\":\"Fartsgrense\",\"type\":\"heltall\",\"verdi\":80,\"enumId\":2738}],\"lokasjon\":{\"segmented\":true,\"kommuner\":[631],\"fylker\":[6],\"regioner\":[2],\"vegavdeling\":[6],\"politidistrikt\":[9],\"geometri\":\"MULTILINESTRING ((196389.1 6634998, 196385.1 6635005.4, 196377.1 6635017.7, 196370.4 6635028.8, 196363 6635040, 196357.6 6635048.2, 196343.6 6635073.1, 196331.3 6635091.5, 196320.2 6635107.4, 196307.6 6635127.4, 196297.2 6635143.3, 196292 6635151.1, 196286.3 6635161.2, 196274.4 6635187.8, 196264.7 6635214.4, 196255.9 6635238.6, 196250.5 6635264.7, 196245.4 6635291.7, 196243.3 6635309, 196242.5 6635315.2, 196241.9 6635316.8, 196241.3 6635318, 196242.6 6635350.4, 196244.3 6635382.9, 196246.7 6635418.6, 196249.3 6635453, 196253.1 6635479.6, 196254.9 6635495.9, 196256.2 6635514.9, 196258.4 6635563, 196260 6635604.1, 196260.1 6635611.4, 196260.4 6635640.3, 196260.3 6635669.9, 196259.4 6635697, 196259 6635712.9, 196255.9 6635743.5, 196251.5 6635769.2, 196245.7 6635797, 196241.8 6635828.4, 196238.1 6635847.7, 196232.8 6635873.2, 196230 6635897.5, 196227.7 6635916.4, 196227.7 6635917.3, 196227.6 6635926.5, 196226.6 6635944.4, 196226.3 6635953.5, 196227.5 6635980.5, 196230.5 6636010.9, 196236.6 6636042, 196243.4 6636069.9, 196250.2 6636098.8, 196257.2 6636127.6, 196263.2 6636155.4, 196269.7 6636183.7, 196276.8 6636212.7, 196282.5 6636241.8, 196289.5 6636271.2, 196292.6 6636283.9, 196296.6 6636299.9, 196303 6636325.6, 196309.8 6636353.1, 196316.3 6636377.3, 196323.9 6636406.2, 196330.6 6636440.6, 196337.6 6636472.2, 196344.5 6636505, 196349.2 6636539.4, 196353.5 6636573.6, 196358 6636609.2, 196364.1 6636647.5, 196370.6 6636683.5, 196379.3 6636718.9, 196390.6 6636753.6, 196402.8 6636785.5, 196413.3 6636815.6, 196425.8 6636841.1, 196436.6 6636863.7, 196438.1 6636866.7, 196447.6 6636884.5, 196454.3 6636898.3, 196465.3 6636924.8, 196475.3 6636953.1, 196485 6636981.1, 196495.2 6637009, 196499.3 6637029.4, 196503.5 6637058.7, 196505.2 6637087.6, 196505.3 6637105.6, 196506.2 6637126.5, 196506.6 6637140.2, 196506.8 6637169.7, 196504.7 6637199.1, 196502.9 6637228.2, 196501.3 6637243, 196500.3 6637272.9, 196500.2 6637289.7, 196499.4 6637312.7, 196496.9 6637339, 196490.2 6637367.4, 196482.2 6637395.6, 196481.3 6637396.6, 196479 6637403, 196466.5 6637428.2, 196452.5 6637453.4, 196446.9 6637461.3, 196445.9 6637462.7, 196444.9 6637464, 196436 6637476.6, 196420 6637496.9, 196409.4 6637509.3, 196394.8 6637529.1, 196383.8 6637547.2, 196383.3 6637548.1, 196374.5 6637567.2, 196368 6637586.3, 196362.6 6637604.4, 196357.6 6637620.7, 196354.5 6637634.7, 196351.6 6637653.6, 196349.1 6637670.4, 196348.9 6637683, 196349.9 6637704.1, 196352.8 6637729.8, 196357 6637754.5, 196365.9 6637784.4, 196372.2 6637801.6, 196377.5 6637818, 196383.3 6637838.5, 196389.4 6637858.2, 196391.2 6637872, 196392.7 6637883, 196394.5 6637906.6, 196393.8 6637929.2, 196392.8 6637952.2, 196390.2 6637973.8, 196387.9 6637988.7, 196384.8 6638008.4, 196382.7 6638028.3, 196382.6 6638048.1, 196381.5 6638065.8, 196382 6638086.1, 196384.4 6638107.9, 196388.4 6638132.1, 196393 6638155.6, 196398.9 6638173.3, 196406.5 6638194.3, 196414.9 6638214.1, 196422.5 6638233.7, 196428.7 6638252.1, 196433.7 6638272.4, 196437.9 6638292.1, 196442 6638305.9, 196443.8 6638321.1, 196445.4 6638342.9, 196446.5 6638363, 196447.4 6638381.3, 196448.5 6638397.6, 196447.2 6638409.8, 196445.5 6638420.8, 196444.1 6638429.9, 196430.1 6638452.8, 196420.6 6638465.4, 196410 6638478.9, 196393.7 6638496.7, 196381.3 6638515.8, 196375.5 6638524.4, 196368.3 6638544.9, 196362.5 6638567.9, 196358.1 6638591.9, 196353.2 6638618.3, 196348.1 6638644.5, 196343.7 6638670.3, 196339.4 6638696.1, 196333.5 6638722.5, 196333.3 6638723.7, 196328.3 6638748, 196322.1 6638773.9, 196321.4 6638776.5, 196319.1 6638787.4, 196316.7 6638798.2, 196316.1 6638801.3, 196314.8 6638807.8, 196311.400024414 6638826.60009766, 196306.900024414 6638852.39990234, 196304.099975586 6638870.39990234, 196300.199951172 6638893, 196296.900024414 6638910.29980469, 196291.800048828 6638927.20019531, 196287.400024414 6638935.60009766, 196281.5 6638949.89990234, 196273.099975586 6638962.70019531, 196265.099975586 6638972.60009766, 196253.800048828 6638984.79980469, 196242.400024414 6638995.20019531, 196233.699951172 6639001.79980469, 196222 6639007.10009766, 196206.300048828 6639013.79980469, 196190.599975586 6639020.79980469, 196178 6639026.70019531, 196167.199951172 6639031.20019531, 196155.699951172 6639037.60009766, 196147.599975586 6639041.79980469, 196144 6639043.39990235, 196138.75 6639047.72021484, 196131.400024414 6639053.89990234, 196126.800048828 6639058.70019531, 196119.199951172 6639071.20019531, 196113.800048828 6639081, 196108.300048828 6639096.79980469, 196104.800048828 6639108, 196102.400024414 6639116.79980469, 196099.599975586 6639133, 196098.400024414 6639147.79980469, 196097.900024414 6639154.70019531, 196095.5 6639175.20019531, 196093.400024414 6639190.20019531, 196092 6639209.90039063, 196091.099975586 6639225.29980469, 196091.640014648 6639236.84960938, 196094.400024414 6639255.20019531, 196098.599975586 6639275.59960938, 196104.900024414 6639291.70019531, 196119.300048828 6639319.70019531, 196133 6639346.09960938, 196146.199951172 6639364.90039062, 196161.800048828 6639384.09960938, 196180.199951172 6639402.40039063, 196198.699951172 6639420.79980469, 196207.699951172 6639428.5, 196217.5 6639443.59960938, 196224.900024414 6639460.59960938, 196232 6639472.59960938, 196244.800048828 6639485.5, 196256.300048828 6639498.5, 196268.5 6639513.90039063, 196281.699951172 6639528.59960938, 196292.800048828 6639540.59960938, 196303.699951172 6639553.29980469, 196312.599975586 6639563.5, 196320.400024414 6639574.09960938, 196326.300048828 6639583.5, 196335.800048828 6639599.40039063, 196342 6639611.90039063, 196349 6639627.29980469, 196355 6639645.59960938, 196357.7 6639657.1, 196360.3 6639671.1, 196362.7 6639684.8, 196365.6 6639703.6, 196367.6 6639719.5, 196369.1 6639732.5, 196370.3 6639749.8, 196370.3 6639752, 196371.6 6639779.8, 196369.5 6639797.7, 196362.5 6639820, 196354.7 6639840.8, 196347.3 6639862.3, 196341.9 6639880.4, 196334.4 6639899.3, 196327.2 6639921.7, 196321.2 6639943.3, 196317.5 6639959.2, 196314.4 6639982.6, 196311.5 6640003.6, 196307.6 6640023.9, 196302.7 6640043.6, 196297.1 6640060.6, 196290.4 6640075.5, 196283.5 6640089.6, 196277 6640101.4, 196272.8 6640110.6, 196268.6 6640120.5, 196267.7 6640125, 196266.2 6640135, 196266.2 6640143, 196267.2 6640156.1, 196268.8 6640168.1, 196270.9 6640180.5, 196272.6 6640192.1, 196272.7 6640202.3, 196272.4629380733 6640216.227388193), (196729.81008317033 6633009.4624330755, 196729.330078125 6633010.53881836, 196720.924804688 6633029.93554688, 196714.135986328 6633045.12963867, 196708.317016602 6633059.35400391, 196699.265136719 6633081.01367188, 196692.799560547 6633095.23779297, 196686.599975586 6633109.80004883, 196679.545166016 6633126.59594727, 196673.726074219 6633140.17358398, 196662.300048828 6633164.5, 196655.945800781 6633178.32055664, 196649.480224609 6633193.51464844, 196639.900024414 6633219, 196632.599975586 6633232.89990235, 196628.099975586 6633242.30004883, 196617.699951172 6633269.10009766, 196604.699951172 6633295.60009766, 196600.5 6633307.10009766, 196589.699951172 6633334.80004883, 196579.699951172 6633361.10009766, 196573.8 6633374.4, 196569.169433594 6633384.18432617, 196557.576904297 6633409.05175781, 196550.964477539 6633424.34301758, 196543.800048828 6633441.5, 196536.086669922 6633460.09106445, 196532.489990234 6633468.47998047, 196529 6633477.39990235, 196518.300048828 6633504.19995117, 196513.099975586 6633513.69995117, 196509.400024414 6633522.69995117, 196503.800048828 6633538.80004883, 196496 6633563.30004883, 196491.199951172 6633581.89990235, 196487.599975586 6633600, 196480.900024414 6633627.10009766, 196477.599975586 6633643.19995117, 196472.5 6633671.39990234, 196469.400024414 6633700.80004883, 196467.199951172 6633729.80004883, 196466.900024414 6633755.5, 196466.5 6633785.30004883, 196465.400024414 6633809.5, 196465.699951172 6633835.39990234, 196464.900024414 6633863.69995117, 196462.800048828 6633893.69995117, 196462.400024414 6633917.5, 196461.699951172 6633928.39990234, 196461 6633947.89990234, 196459.900024414 6633964, 196460.199951172 6633988.60009766, 196459.800048828 6634005, 196459.099975586 6634033.10009766, 196458.400024414 6634062.89990234, 196457.900024414 6634092.69995117, 196456 6634112.60009766, 196455.800048828 6634126.60009766, 196455.300048828 6634143.80004883, 196455.5 6634155.10009766, 196453.900024414 6634184.69995117, 196453.5 6634213.30004883, 196452.5 6634242.89990235, 196452.099975586 6634271.89990234, 196451.099975586 6634291.69995117, 196449.5 6634320.89990234, 196449.5 6634346.89990234, 196450.300048828 6634370.10009766, 196450 6634379.19995117, 196449.099975586 6634395.5, 196447.400024414 6634410.39990234, 196447.5 6634424.39990234, 196446.900024414 6634436.5, 196447.199951172 6634462.80004883, 196446.199951172 6634476.19995117, 196446.800048828 6634505.80004883, 196446.3 6634520, 196440.9 6634542.6, 196439.6 6634551.1, 196438.2 6634560.6, 196434.4 6634585.8, 196429.6 6634615, 196428.2 6634627.6, 196425.4 6634643.4, 196423.6 6634659.9, 196422.9 6634665.7, 196417.6 6634690.7, 196416.2 6634698.7, 196416.7 6634712.4, 196416.800048828 6634717.5, 196420.400024414 6634746.69995117, 196424.900024414 6634775.30004883, 196429 6634796.19995117, 196435.099975586 6634824.60009766, 196436.599975586 6634839.10009766, 196438.400024414 6634869, 196436.569946289 6634897.75, 196435 6634905, 196426.599975586 6634932.5, 196423 6634942, 196408.900024414 6634967, 196392.800048828 6634991, 196389.1 6634998))\",\"strekningslengde\":7617.0,\"segmenter\":[{\"seqno\":0,\"veglenke\":181344,\"start_posisjon\":0.781636848698101,\"slutt_posisjon\":1.0,\"retning\":\"med\",\"sideposisjon\":\"NULL\",\"geometri\":\"LINESTRING (196729.81008317033 6633009.4624330755, 196729.330078125 6633010.53881836, 196720.924804688 6633029.93554688, 196714.135986328 6633045.12963867, 196708.317016602 6633059.35400391, 196699.265136719 6633081.01367188, 196692.799560547 6633095.23779297, 196686.599975586 6633109.80004883, 196679.545166016 6633126.59594727, 196673.726074219 6633140.17358398, 196662.300048828 6633164.5, 196655.945800781 6633178.32055664, 196649.480224609 6633193.51464844, 196639.900024414 6633219, 196632.599975586 6633232.89990235, 196628.099975586 6633242.30004883, 196617.699951172 6633269.10009766, 196604.699951172 6633295.60009766, 196600.5 6633307.10009766, 196589.699951172 6633334.80004883, 196579.699951172 6633361.10009766, 196573.8 6633374.4, 196569.169433594 6633384.18432617, 196557.576904297 6633409.05175781, 196550.964477539 6633424.34301758, 196543.800048828 6633441.5, 196536.086669922 6633460.09106445, 196532.489990234 6633468.47998047, 196529 6633477.39990235, 196518.300048828 6633504.19995117, 196513.099975586 6633513.69995117, 196509.400024414 6633522.69995117, 196503.800048828 6633538.80004883, 196496 6633563.30004883, 196491.199951172 6633581.89990235, 196487.599975586 6633600, 196480.900024414 6633627.10009766, 196477.599975586 6633643.19995117, 196472.5 6633671.39990234, 196469.400024414 6633700.80004883, 196467.199951172 6633729.80004883, 196466.900024414 6633755.5, 196466.5 6633785.30004883, 196465.400024414 6633809.5, 196465.699951172 6633835.39990234, 196464.900024414 6633863.69995117, 196462.800048828 6633893.69995117, 196462.400024414 6633917.5, 196461.699951172 6633928.39990234, 196461 6633947.89990234, 196459.900024414 6633964, 196460.199951172 6633988.60009766, 196459.800048828 6634005, 196459.099975586 6634033.10009766, 196458.400024414 6634062.89990234, 196457.900024414 6634092.69995117, 196456 6634112.60009766, 196455.800048828 6634126.60009766, 196455.300048828 6634143.80004883, 196455.5 6634155.10009766, 196453.900024414 6634184.69995117, 196453.5 6634213.30004883, 196452.5 6634242.89990235, 196452.099975586 6634271.89990234, 196451.099975586 6634291.69995117, 196449.5 6634320.89990234, 196449.5 6634346.89990234, 196450.300048828 6634370.10009766, 196450 6634379.19995117, 196449.099975586 6634395.5, 196447.400024414 6634410.39990234, 196447.5 6634424.39990234, 196446.900024414 6634436.5, 196447.199951172 6634462.80004883, 196446.199951172 6634476.19995117, 196446.800048828 6634505.80004883, 196446.3 6634520, 196440.9 6634542.6, 196439.6 6634551.1, 196438.2 6634560.6, 196434.4 6634585.8, 196429.6 6634615, 196428.2 6634627.6, 196425.4 6634643.4, 196423.6 6634659.9, 196422.9 6634665.7, 196417.6 6634690.7, 196416.2 6634698.7, 196416.7 6634712.4, 196416.800048828 6634717.5, 196420.400024414 6634746.69995117, 196424.900024414 6634775.30004883, 196429 6634796.19995117, 196435.099975586 6634824.60009766, 196436.599975586 6634839.10009766, 196438.400024414 6634869, 196436.569946289 6634897.75, 196435 6634905, 196426.599975586 6634932.5, 196423 6634942, 196408.900024414 6634967, 196392.800048828 6634991, 196389.1 6634998)\",\"kommune\":631,\"fylke\":6,\"region\":2,\"vegavdeling\":6,\"politidistrikt\":9,\"vegreferanse\":{\"fylke\":6,\"kommune\":631,\"kategori\":\"F\",\"status\":\"V\",\"nummer\":88,\"hp\":2,\"fra_meter\":310,\"til_meter\":2363}},{\"seqno\":0,\"veglenke\":181111,\"start_posisjon\":0.0,\"slutt_posisjon\":0.880635240028163,\"retning\":\"med\",\"sideposisjon\":\"NULL\",\"geometri\":\"LINESTRING (196389.1 6634998, 196385.1 6635005.4, 196377.1 6635017.7, 196370.4 6635028.8, 196363 6635040, 196357.6 6635048.2, 196343.6 6635073.1, 196331.3 6635091.5, 196320.2 6635107.4, 196307.6 6635127.4, 196297.2 6635143.3, 196292 6635151.1, 196286.3 6635161.2, 196274.4 6635187.8, 196264.7 6635214.4, 196255.9 6635238.6, 196250.5 6635264.7, 196245.4 6635291.7, 196243.3 6635309, 196242.5 6635315.2, 196241.9 6635316.8, 196241.3 6635318, 196242.6 6635350.4, 196244.3 6635382.9, 196246.7 6635418.6, 196249.3 6635453, 196253.1 6635479.6, 196254.9 6635495.9, 196256.2 6635514.9, 196258.4 6635563, 196260 6635604.1, 196260.1 6635611.4, 196260.4 6635640.3, 196260.3 6635669.9, 196259.4 6635697, 196259 6635712.9, 196255.9 6635743.5, 196251.5 6635769.2, 196245.7 6635797, 196241.8 6635828.4, 196238.1 6635847.7, 196232.8 6635873.2, 196230 6635897.5, 196227.7 6635916.4, 196227.7 6635917.3, 196227.6 6635926.5, 196226.6 6635944.4, 196226.3 6635953.5, 196227.5 6635980.5, 196230.5 6636010.9, 196236.6 6636042, 196243.4 6636069.9, 196250.2 6636098.8, 196257.2 6636127.6, 196263.2 6636155.4, 196269.7 6636183.7, 196276.8 6636212.7, 196282.5 6636241.8, 196289.5 6636271.2, 196292.6 6636283.9, 196296.6 6636299.9, 196303 6636325.6, 196309.8 6636353.1, 196316.3 6636377.3, 196323.9 6636406.2, 196330.6 6636440.6, 196337.6 6636472.2, 196344.5 6636505, 196349.2 6636539.4, 196353.5 6636573.6, 196358 6636609.2, 196364.1 6636647.5, 196370.6 6636683.5, 196379.3 6636718.9, 196390.6 6636753.6, 196402.8 6636785.5, 196413.3 6636815.6, 196425.8 6636841.1, 196436.6 6636863.7, 196438.1 6636866.7, 196447.6 6636884.5, 196454.3 6636898.3, 196465.3 6636924.8, 196475.3 6636953.1, 196485 6636981.1, 196495.2 6637009, 196499.3 6637029.4, 196503.5 6637058.7, 196505.2 6637087.6, 196505.3 6637105.6, 196506.2 6637126.5, 196506.6 6637140.2, 196506.8 6637169.7, 196504.7 6637199.1, 196502.9 6637228.2, 196501.3 6637243, 196500.3 6637272.9, 196500.2 6637289.7, 196499.4 6637312.7, 196496.9 6637339, 196490.2 6637367.4, 196482.2 6637395.6, 196481.3 6637396.6, 196479 6637403, 196466.5 6637428.2, 196452.5 6637453.4, 196446.9 6637461.3, 196445.9 6637462.7, 196444.9 6637464, 196436 6637476.6, 196420 6637496.9, 196409.4 6637509.3, 196394.8 6637529.1, 196383.8 6637547.2, 196383.3 6637548.1, 196374.5 6637567.2, 196368 6637586.3, 196362.6 6637604.4, 196357.6 6637620.7, 196354.5 6637634.7, 196351.6 6637653.6, 196349.1 6637670.4, 196348.9 6637683, 196349.9 6637704.1, 196352.8 6637729.8, 196357 6637754.5, 196365.9 6637784.4, 196372.2 6637801.6, 196377.5 6637818, 196383.3 6637838.5, 196389.4 6637858.2, 196391.2 6637872, 196392.7 6637883, 196394.5 6637906.6, 196393.8 6637929.2, 196392.8 6637952.2, 196390.2 6637973.8, 196387.9 6637988.7, 196384.8 6638008.4, 196382.7 6638028.3, 196382.6 6638048.1, 196381.5 6638065.8, 196382 6638086.1, 196384.4 6638107.9, 196388.4 6638132.1, 196393 6638155.6, 196398.9 6638173.3, 196406.5 6638194.3, 196414.9 6638214.1, 196422.5 6638233.7, 196428.7 6638252.1, 196433.7 6638272.4, 196437.9 6638292.1, 196442 6638305.9, 196443.8 6638321.1, 196445.4 6638342.9, 196446.5 6638363, 196447.4 6638381.3, 196448.5 6638397.6, 196447.2 6638409.8, 196445.5 6638420.8, 196444.1 6638429.9, 196430.1 6638452.8, 196420.6 6638465.4, 196410 6638478.9, 196393.7 6638496.7, 196381.3 6638515.8, 196375.5 6638524.4, 196368.3 6638544.9, 196362.5 6638567.9, 196358.1 6638591.9, 196353.2 6638618.3, 196348.1 6638644.5, 196343.7 6638670.3, 196339.4 6638696.1, 196333.5 6638722.5, 196333.3 6638723.7, 196328.3 6638748, 196322.1 6638773.9, 196321.4 6638776.5, 196319.1 6638787.4, 196316.7 6638798.2, 196316.1 6638801.3, 196314.8 6638807.8, 196311.400024414 6638826.60009766, 196306.900024414 6638852.39990234, 196304.099975586 6638870.39990234, 196300.199951172 6638893, 196296.900024414 6638910.29980469, 196291.800048828 6638927.20019531, 196287.400024414 6638935.60009766, 196281.5 6638949.89990234, 196273.099975586 6638962.70019531, 196265.099975586 6638972.60009766, 196253.800048828 6638984.79980469, 196242.400024414 6638995.20019531, 196233.699951172 6639001.79980469, 196222 6639007.10009766, 196206.300048828 6639013.79980469, 196190.599975586 6639020.79980469, 196178 6639026.70019531, 196167.199951172 6639031.20019531, 196155.699951172 6639037.60009766, 196147.599975586 6639041.79980469, 196144 6639043.39990235, 196138.75 6639047.72021484, 196131.400024414 6639053.89990234, 196126.800048828 6639058.70019531, 196119.199951172 6639071.20019531, 196113.800048828 6639081, 196108.300048828 6639096.79980469, 196104.800048828 6639108, 196102.400024414 6639116.79980469, 196099.599975586 6639133, 196098.400024414 6639147.79980469, 196097.900024414 6639154.70019531, 196095.5 6639175.20019531, 196093.400024414 6639190.20019531, 196092 6639209.90039063, 196091.099975586 6639225.29980469, 196091.640014648 6639236.84960938, 196094.400024414 6639255.20019531, 196098.599975586 6639275.59960938, 196104.900024414 6639291.70019531, 196119.300048828 6639319.70019531, 196133 6639346.09960938, 196146.199951172 6639364.90039062, 196161.800048828 6639384.09960938, 196180.199951172 6639402.40039063, 196198.699951172 6639420.79980469, 196207.699951172 6639428.5, 196217.5 6639443.59960938, 196224.900024414 6639460.59960938, 196232 6639472.59960938, 196244.800048828 6639485.5, 196256.300048828 6639498.5, 196268.5 6639513.90039063, 196281.699951172 6639528.59960938, 196292.800048828 6639540.59960938, 196303.699951172 6639553.29980469, 196312.599975586 6639563.5, 196320.400024414 6639574.09960938, 196326.300048828 6639583.5, 196335.800048828 6639599.40039063, 196342 6639611.90039063, 196349 6639627.29980469, 196355 6639645.59960938, 196357.7 6639657.1, 196360.3 6639671.1, 196362.7 6639684.8, 196365.6 6639703.6, 196367.6 6639719.5, 196369.1 6639732.5, 196370.3 6639749.8, 196370.3 6639752, 196371.6 6639779.8, 196369.5 6639797.7, 196362.5 6639820, 196354.7 6639840.8, 196347.3 6639862.3, 196341.9 6639880.4, 196334.4 6639899.3, 196327.2 6639921.7, 196321.2 6639943.3, 196317.5 6639959.2, 196314.4 6639982.6, 196311.5 6640003.6, 196307.6 6640023.9, 196302.7 6640043.6, 196297.1 6640060.6, 196290.4 6640075.5, 196283.5 6640089.6, 196277 6640101.4, 196272.8 6640110.6, 196268.6 6640120.5, 196267.7 6640125, 196266.2 6640135, 196266.2 6640143, 196267.2 6640156.1, 196268.8 6640168.1, 196270.9 6640180.5, 196272.6 6640192.1, 196272.7 6640202.3, 196272.4629380733 6640216.227388193)\",\"kommune\":631,\"fylke\":6,\"region\":2,\"vegavdeling\":6,\"politidistrikt\":9,\"vegreferanse\":{\"fylke\":6,\"kommune\":631,\"kategori\":\"F\",\"status\":\"V\",\"nummer\":88,\"hp\":2,\"fra_meter\":2363,\"til_meter\":7927}}]}}").getAsJsonObject();
+        JsonObject e = JsonParser.parseString("{\"id\":81456352,\"type\":{\"id\":105,\"navn\":\"Fartsgrense\"},\"versjon\":{\"id\":3,\"startdato\":\"2010-02-02\",\"segment\":{\"startdato\":\"2014-09-01\",\"enddato\":\"2019-09-01\"}},\"egenskaper\":[{\"id\":2021,\"navn\":\"Fartsgrense\",\"type\":\"heltall\",\"verdi\":80,\"enumId\":2738}],\"lokasjon\":{\"segmented\":true,\"kommuner\":[631],\"fylker\":[6],\"regioner\":[2],\"vegavdeling\":[6],\"politidistrikt\":[9],\"geometri\":\"MULTILINESTRING ((196389.1 6634998, 196385.1 6635005.4, 196377.1 6635017.7, 196370.4 6635028.8, 196363 6635040, 196357.6 6635048.2, 196343.6 6635073.1, 196331.3 6635091.5, 196320.2 6635107.4, 196307.6 6635127.4, 196297.2 6635143.3, 196292 6635151.1, 196286.3 6635161.2, 196274.4 6635187.8, 196264.7 6635214.4, 196255.9 6635238.6, 196250.5 6635264.7, 196245.4 6635291.7, 196243.3 6635309, 196242.5 6635315.2, 196241.9 6635316.8, 196241.3 6635318, 196242.6 6635350.4, 196244.3 6635382.9, 196246.7 6635418.6, 196249.3 6635453, 196253.1 6635479.6, 196254.9 6635495.9, 196256.2 6635514.9, 196258.4 6635563, 196260 6635604.1, 196260.1 6635611.4, 196260.4 6635640.3, 196260.3 6635669.9, 196259.4 6635697, 196259 6635712.9, 196255.9 6635743.5, 196251.5 6635769.2, 196245.7 6635797, 196241.8 6635828.4, 196238.1 6635847.7, 196232.8 6635873.2, 196230 6635897.5, 196227.7 6635916.4, 196227.7 6635917.3, 196227.6 6635926.5, 196226.6 6635944.4, 196226.3 6635953.5, 196227.5 6635980.5, 196230.5 6636010.9, 196236.6 6636042, 196243.4 6636069.9, 196250.2 6636098.8, 196257.2 6636127.6, 196263.2 6636155.4, 196269.7 6636183.7, 196276.8 6636212.7, 196282.5 6636241.8, 196289.5 6636271.2, 196292.6 6636283.9, 196296.6 6636299.9, 196303 6636325.6, 196309.8 6636353.1, 196316.3 6636377.3, 196323.9 6636406.2, 196330.6 6636440.6, 196337.6 6636472.2, 196344.5 6636505, 196349.2 6636539.4, 196353.5 6636573.6, 196358 6636609.2, 196364.1 6636647.5, 196370.6 6636683.5, 196379.3 6636718.9, 196390.6 6636753.6, 196402.8 6636785.5, 196413.3 6636815.6, 196425.8 6636841.1, 196436.6 6636863.7, 196438.1 6636866.7, 196447.6 6636884.5, 196454.3 6636898.3, 196465.3 6636924.8, 196475.3 6636953.1, 196485 6636981.1, 196495.2 6637009, 196499.3 6637029.4, 196503.5 6637058.7, 196505.2 6637087.6, 196505.3 6637105.6, 196506.2 6637126.5, 196506.6 6637140.2, 196506.8 6637169.7, 196504.7 6637199.1, 196502.9 6637228.2, 196501.3 6637243, 196500.3 6637272.9, 196500.2 6637289.7, 196499.4 6637312.7, 196496.9 6637339, 196490.2 6637367.4, 196482.2 6637395.6, 196481.3 6637396.6, 196479 6637403, 196466.5 6637428.2, 196452.5 6637453.4, 196446.9 6637461.3, 196445.9 6637462.7, 196444.9 6637464, 196436 6637476.6, 196420 6637496.9, 196409.4 6637509.3, 196394.8 6637529.1, 196383.8 6637547.2, 196383.3 6637548.1, 196374.5 6637567.2, 196368 6637586.3, 196362.6 6637604.4, 196357.6 6637620.7, 196354.5 6637634.7, 196351.6 6637653.6, 196349.1 6637670.4, 196348.9 6637683, 196349.9 6637704.1, 196352.8 6637729.8, 196357 6637754.5, 196365.9 6637784.4, 196372.2 6637801.6, 196377.5 6637818, 196383.3 6637838.5, 196389.4 6637858.2, 196391.2 6637872, 196392.7 6637883, 196394.5 6637906.6, 196393.8 6637929.2, 196392.8 6637952.2, 196390.2 6637973.8, 196387.9 6637988.7, 196384.8 6638008.4, 196382.7 6638028.3, 196382.6 6638048.1, 196381.5 6638065.8, 196382 6638086.1, 196384.4 6638107.9, 196388.4 6638132.1, 196393 6638155.6, 196398.9 6638173.3, 196406.5 6638194.3, 196414.9 6638214.1, 196422.5 6638233.7, 196428.7 6638252.1, 196433.7 6638272.4, 196437.9 6638292.1, 196442 6638305.9, 196443.8 6638321.1, 196445.4 6638342.9, 196446.5 6638363, 196447.4 6638381.3, 196448.5 6638397.6, 196447.2 6638409.8, 196445.5 6638420.8, 196444.1 6638429.9, 196430.1 6638452.8, 196420.6 6638465.4, 196410 6638478.9, 196393.7 6638496.7, 196381.3 6638515.8, 196375.5 6638524.4, 196368.3 6638544.9, 196362.5 6638567.9, 196358.1 6638591.9, 196353.2 6638618.3, 196348.1 6638644.5, 196343.7 6638670.3, 196339.4 6638696.1, 196333.5 6638722.5, 196333.3 6638723.7, 196328.3 6638748, 196322.1 6638773.9, 196321.4 6638776.5, 196319.1 6638787.4, 196316.7 6638798.2, 196316.1 6638801.3, 196314.8 6638807.8, 196311.400024414 6638826.60009766, 196306.900024414 6638852.39990234, 196304.099975586 6638870.39990234, 196300.199951172 6638893, 196296.900024414 6638910.29980469, 196291.800048828 6638927.20019531, 196287.400024414 6638935.60009766, 196281.5 6638949.89990234, 196273.099975586 6638962.70019531, 196265.099975586 6638972.60009766, 196253.800048828 6638984.79980469, 196242.400024414 6638995.20019531, 196233.699951172 6639001.79980469, 196222 6639007.10009766, 196206.300048828 6639013.79980469, 196190.599975586 6639020.79980469, 196178 6639026.70019531, 196167.199951172 6639031.20019531, 196155.699951172 6639037.60009766, 196147.599975586 6639041.79980469, 196144 6639043.39990235, 196138.75 6639047.72021484, 196131.400024414 6639053.89990234, 196126.800048828 6639058.70019531, 196119.199951172 6639071.20019531, 196113.800048828 6639081, 196108.300048828 6639096.79980469, 196104.800048828 6639108, 196102.400024414 6639116.79980469, 196099.599975586 6639133, 196098.400024414 6639147.79980469, 196097.900024414 6639154.70019531, 196095.5 6639175.20019531, 196093.400024414 6639190.20019531, 196092 6639209.90039063, 196091.099975586 6639225.29980469, 196091.640014648 6639236.84960938, 196094.400024414 6639255.20019531, 196098.599975586 6639275.59960938, 196104.900024414 6639291.70019531, 196119.300048828 6639319.70019531, 196133 6639346.09960938, 196146.199951172 6639364.90039062, 196161.800048828 6639384.09960938, 196180.199951172 6639402.40039063, 196198.699951172 6639420.79980469, 196207.699951172 6639428.5, 196217.5 6639443.59960938, 196224.900024414 6639460.59960938, 196232 6639472.59960938, 196244.800048828 6639485.5, 196256.300048828 6639498.5, 196268.5 6639513.90039063, 196281.699951172 6639528.59960938, 196292.800048828 6639540.59960938, 196303.699951172 6639553.29980469, 196312.599975586 6639563.5, 196320.400024414 6639574.09960938, 196326.300048828 6639583.5, 196335.800048828 6639599.40039063, 196342 6639611.90039063, 196349 6639627.29980469, 196355 6639645.59960938, 196357.7 6639657.1, 196360.3 6639671.1, 196362.7 6639684.8, 196365.6 6639703.6, 196367.6 6639719.5, 196369.1 6639732.5, 196370.3 6639749.8, 196370.3 6639752, 196371.6 6639779.8, 196369.5 6639797.7, 196362.5 6639820, 196354.7 6639840.8, 196347.3 6639862.3, 196341.9 6639880.4, 196334.4 6639899.3, 196327.2 6639921.7, 196321.2 6639943.3, 196317.5 6639959.2, 196314.4 6639982.6, 196311.5 6640003.6, 196307.6 6640023.9, 196302.7 6640043.6, 196297.1 6640060.6, 196290.4 6640075.5, 196283.5 6640089.6, 196277 6640101.4, 196272.8 6640110.6, 196268.6 6640120.5, 196267.7 6640125, 196266.2 6640135, 196266.2 6640143, 196267.2 6640156.1, 196268.8 6640168.1, 196270.9 6640180.5, 196272.6 6640192.1, 196272.7 6640202.3, 196272.4629380733 6640216.227388193), (196729.81008317033 6633009.4624330755, 196729.330078125 6633010.53881836, 196720.924804688 6633029.93554688, 196714.135986328 6633045.12963867, 196708.317016602 6633059.35400391, 196699.265136719 6633081.01367188, 196692.799560547 6633095.23779297, 196686.599975586 6633109.80004883, 196679.545166016 6633126.59594727, 196673.726074219 6633140.17358398, 196662.300048828 6633164.5, 196655.945800781 6633178.32055664, 196649.480224609 6633193.51464844, 196639.900024414 6633219, 196632.599975586 6633232.89990235, 196628.099975586 6633242.30004883, 196617.699951172 6633269.10009766, 196604.699951172 6633295.60009766, 196600.5 6633307.10009766, 196589.699951172 6633334.80004883, 196579.699951172 6633361.10009766, 196573.8 6633374.4, 196569.169433594 6633384.18432617, 196557.576904297 6633409.05175781, 196550.964477539 6633424.34301758, 196543.800048828 6633441.5, 196536.086669922 6633460.09106445, 196532.489990234 6633468.47998047, 196529 6633477.39990235, 196518.300048828 6633504.19995117, 196513.099975586 6633513.69995117, 196509.400024414 6633522.69995117, 196503.800048828 6633538.80004883, 196496 6633563.30004883, 196491.199951172 6633581.89990235, 196487.599975586 6633600, 196480.900024414 6633627.10009766, 196477.599975586 6633643.19995117, 196472.5 6633671.39990234, 196469.400024414 6633700.80004883, 196467.199951172 6633729.80004883, 196466.900024414 6633755.5, 196466.5 6633785.30004883, 196465.400024414 6633809.5, 196465.699951172 6633835.39990234, 196464.900024414 6633863.69995117, 196462.800048828 6633893.69995117, 196462.400024414 6633917.5, 196461.699951172 6633928.39990234, 196461 6633947.89990234, 196459.900024414 6633964, 196460.199951172 6633988.60009766, 196459.800048828 6634005, 196459.099975586 6634033.10009766, 196458.400024414 6634062.89990234, 196457.900024414 6634092.69995117, 196456 6634112.60009766, 196455.800048828 6634126.60009766, 196455.300048828 6634143.80004883, 196455.5 6634155.10009766, 196453.900024414 6634184.69995117, 196453.5 6634213.30004883, 196452.5 6634242.89990235, 196452.099975586 6634271.89990234, 196451.099975586 6634291.69995117, 196449.5 6634320.89990234, 196449.5 6634346.89990234, 196450.300048828 6634370.10009766, 196450 6634379.19995117, 196449.099975586 6634395.5, 196447.400024414 6634410.39990234, 196447.5 6634424.39990234, 196446.900024414 6634436.5, 196447.199951172 6634462.80004883, 196446.199951172 6634476.19995117, 196446.800048828 6634505.80004883, 196446.3 6634520, 196440.9 6634542.6, 196439.6 6634551.1, 196438.2 6634560.6, 196434.4 6634585.8, 196429.6 6634615, 196428.2 6634627.6, 196425.4 6634643.4, 196423.6 6634659.9, 196422.9 6634665.7, 196417.6 6634690.7, 196416.2 6634698.7, 196416.7 6634712.4, 196416.800048828 6634717.5, 196420.400024414 6634746.69995117, 196424.900024414 6634775.30004883, 196429 6634796.19995117, 196435.099975586 6634824.60009766, 196436.599975586 6634839.10009766, 196438.400024414 6634869, 196436.569946289 6634897.75, 196435 6634905, 196426.599975586 6634932.5, 196423 6634942, 196408.900024414 6634967, 196392.800048828 6634991, 196389.1 6634998))\",\"lengde\":7617.0,\"segmenter\":[{\"seqno\":0,\"veglenke\":181344,\"start_posisjon\":0.781636848698101,\"slutt_posisjon\":1.0,\"retning\":\"med\",\"sideposisjon\":\"NULL\",\"geometri\":\"LINESTRING (196729.81008317033 6633009.4624330755, 196729.330078125 6633010.53881836, 196720.924804688 6633029.93554688, 196714.135986328 6633045.12963867, 196708.317016602 6633059.35400391, 196699.265136719 6633081.01367188, 196692.799560547 6633095.23779297, 196686.599975586 6633109.80004883, 196679.545166016 6633126.59594727, 196673.726074219 6633140.17358398, 196662.300048828 6633164.5, 196655.945800781 6633178.32055664, 196649.480224609 6633193.51464844, 196639.900024414 6633219, 196632.599975586 6633232.89990235, 196628.099975586 6633242.30004883, 196617.699951172 6633269.10009766, 196604.699951172 6633295.60009766, 196600.5 6633307.10009766, 196589.699951172 6633334.80004883, 196579.699951172 6633361.10009766, 196573.8 6633374.4, 196569.169433594 6633384.18432617, 196557.576904297 6633409.05175781, 196550.964477539 6633424.34301758, 196543.800048828 6633441.5, 196536.086669922 6633460.09106445, 196532.489990234 6633468.47998047, 196529 6633477.39990235, 196518.300048828 6633504.19995117, 196513.099975586 6633513.69995117, 196509.400024414 6633522.69995117, 196503.800048828 6633538.80004883, 196496 6633563.30004883, 196491.199951172 6633581.89990235, 196487.599975586 6633600, 196480.900024414 6633627.10009766, 196477.599975586 6633643.19995117, 196472.5 6633671.39990234, 196469.400024414 6633700.80004883, 196467.199951172 6633729.80004883, 196466.900024414 6633755.5, 196466.5 6633785.30004883, 196465.400024414 6633809.5, 196465.699951172 6633835.39990234, 196464.900024414 6633863.69995117, 196462.800048828 6633893.69995117, 196462.400024414 6633917.5, 196461.699951172 6633928.39990234, 196461 6633947.89990234, 196459.900024414 6633964, 196460.199951172 6633988.60009766, 196459.800048828 6634005, 196459.099975586 6634033.10009766, 196458.400024414 6634062.89990234, 196457.900024414 6634092.69995117, 196456 6634112.60009766, 196455.800048828 6634126.60009766, 196455.300048828 6634143.80004883, 196455.5 6634155.10009766, 196453.900024414 6634184.69995117, 196453.5 6634213.30004883, 196452.5 6634242.89990235, 196452.099975586 6634271.89990234, 196451.099975586 6634291.69995117, 196449.5 6634320.89990234, 196449.5 6634346.89990234, 196450.300048828 6634370.10009766, 196450 6634379.19995117, 196449.099975586 6634395.5, 196447.400024414 6634410.39990234, 196447.5 6634424.39990234, 196446.900024414 6634436.5, 196447.199951172 6634462.80004883, 196446.199951172 6634476.19995117, 196446.800048828 6634505.80004883, 196446.3 6634520, 196440.9 6634542.6, 196439.6 6634551.1, 196438.2 6634560.6, 196434.4 6634585.8, 196429.6 6634615, 196428.2 6634627.6, 196425.4 6634643.4, 196423.6 6634659.9, 196422.9 6634665.7, 196417.6 6634690.7, 196416.2 6634698.7, 196416.7 6634712.4, 196416.800048828 6634717.5, 196420.400024414 6634746.69995117, 196424.900024414 6634775.30004883, 196429 6634796.19995117, 196435.099975586 6634824.60009766, 196436.599975586 6634839.10009766, 196438.400024414 6634869, 196436.569946289 6634897.75, 196435 6634905, 196426.599975586 6634932.5, 196423 6634942, 196408.900024414 6634967, 196392.800048828 6634991, 196389.1 6634998)\",\"kommune\":631,\"fylke\":6,\"region\":2,\"vegavdeling\":6,\"politidistrikt\":9,\"vegreferanse\":{\"fylke\":6,\"kommune\":631,\"kategori\":\"F\",\"status\":\"V\",\"nummer\":88,\"hp\":2,\"fra_meter\":310,\"til_meter\":2363}},{\"seqno\":0,\"veglenke\":181111,\"start_posisjon\":0.0,\"slutt_posisjon\":0.880635240028163,\"retning\":\"med\",\"sideposisjon\":\"NULL\",\"geometri\":\"LINESTRING (196389.1 6634998, 196385.1 6635005.4, 196377.1 6635017.7, 196370.4 6635028.8, 196363 6635040, 196357.6 6635048.2, 196343.6 6635073.1, 196331.3 6635091.5, 196320.2 6635107.4, 196307.6 6635127.4, 196297.2 6635143.3, 196292 6635151.1, 196286.3 6635161.2, 196274.4 6635187.8, 196264.7 6635214.4, 196255.9 6635238.6, 196250.5 6635264.7, 196245.4 6635291.7, 196243.3 6635309, 196242.5 6635315.2, 196241.9 6635316.8, 196241.3 6635318, 196242.6 6635350.4, 196244.3 6635382.9, 196246.7 6635418.6, 196249.3 6635453, 196253.1 6635479.6, 196254.9 6635495.9, 196256.2 6635514.9, 196258.4 6635563, 196260 6635604.1, 196260.1 6635611.4, 196260.4 6635640.3, 196260.3 6635669.9, 196259.4 6635697, 196259 6635712.9, 196255.9 6635743.5, 196251.5 6635769.2, 196245.7 6635797, 196241.8 6635828.4, 196238.1 6635847.7, 196232.8 6635873.2, 196230 6635897.5, 196227.7 6635916.4, 196227.7 6635917.3, 196227.6 6635926.5, 196226.6 6635944.4, 196226.3 6635953.5, 196227.5 6635980.5, 196230.5 6636010.9, 196236.6 6636042, 196243.4 6636069.9, 196250.2 6636098.8, 196257.2 6636127.6, 196263.2 6636155.4, 196269.7 6636183.7, 196276.8 6636212.7, 196282.5 6636241.8, 196289.5 6636271.2, 196292.6 6636283.9, 196296.6 6636299.9, 196303 6636325.6, 196309.8 6636353.1, 196316.3 6636377.3, 196323.9 6636406.2, 196330.6 6636440.6, 196337.6 6636472.2, 196344.5 6636505, 196349.2 6636539.4, 196353.5 6636573.6, 196358 6636609.2, 196364.1 6636647.5, 196370.6 6636683.5, 196379.3 6636718.9, 196390.6 6636753.6, 196402.8 6636785.5, 196413.3 6636815.6, 196425.8 6636841.1, 196436.6 6636863.7, 196438.1 6636866.7, 196447.6 6636884.5, 196454.3 6636898.3, 196465.3 6636924.8, 196475.3 6636953.1, 196485 6636981.1, 196495.2 6637009, 196499.3 6637029.4, 196503.5 6637058.7, 196505.2 6637087.6, 196505.3 6637105.6, 196506.2 6637126.5, 196506.6 6637140.2, 196506.8 6637169.7, 196504.7 6637199.1, 196502.9 6637228.2, 196501.3 6637243, 196500.3 6637272.9, 196500.2 6637289.7, 196499.4 6637312.7, 196496.9 6637339, 196490.2 6637367.4, 196482.2 6637395.6, 196481.3 6637396.6, 196479 6637403, 196466.5 6637428.2, 196452.5 6637453.4, 196446.9 6637461.3, 196445.9 6637462.7, 196444.9 6637464, 196436 6637476.6, 196420 6637496.9, 196409.4 6637509.3, 196394.8 6637529.1, 196383.8 6637547.2, 196383.3 6637548.1, 196374.5 6637567.2, 196368 6637586.3, 196362.6 6637604.4, 196357.6 6637620.7, 196354.5 6637634.7, 196351.6 6637653.6, 196349.1 6637670.4, 196348.9 6637683, 196349.9 6637704.1, 196352.8 6637729.8, 196357 6637754.5, 196365.9 6637784.4, 196372.2 6637801.6, 196377.5 6637818, 196383.3 6637838.5, 196389.4 6637858.2, 196391.2 6637872, 196392.7 6637883, 196394.5 6637906.6, 196393.8 6637929.2, 196392.8 6637952.2, 196390.2 6637973.8, 196387.9 6637988.7, 196384.8 6638008.4, 196382.7 6638028.3, 196382.6 6638048.1, 196381.5 6638065.8, 196382 6638086.1, 196384.4 6638107.9, 196388.4 6638132.1, 196393 6638155.6, 196398.9 6638173.3, 196406.5 6638194.3, 196414.9 6638214.1, 196422.5 6638233.7, 196428.7 6638252.1, 196433.7 6638272.4, 196437.9 6638292.1, 196442 6638305.9, 196443.8 6638321.1, 196445.4 6638342.9, 196446.5 6638363, 196447.4 6638381.3, 196448.5 6638397.6, 196447.2 6638409.8, 196445.5 6638420.8, 196444.1 6638429.9, 196430.1 6638452.8, 196420.6 6638465.4, 196410 6638478.9, 196393.7 6638496.7, 196381.3 6638515.8, 196375.5 6638524.4, 196368.3 6638544.9, 196362.5 6638567.9, 196358.1 6638591.9, 196353.2 6638618.3, 196348.1 6638644.5, 196343.7 6638670.3, 196339.4 6638696.1, 196333.5 6638722.5, 196333.3 6638723.7, 196328.3 6638748, 196322.1 6638773.9, 196321.4 6638776.5, 196319.1 6638787.4, 196316.7 6638798.2, 196316.1 6638801.3, 196314.8 6638807.8, 196311.400024414 6638826.60009766, 196306.900024414 6638852.39990234, 196304.099975586 6638870.39990234, 196300.199951172 6638893, 196296.900024414 6638910.29980469, 196291.800048828 6638927.20019531, 196287.400024414 6638935.60009766, 196281.5 6638949.89990234, 196273.099975586 6638962.70019531, 196265.099975586 6638972.60009766, 196253.800048828 6638984.79980469, 196242.400024414 6638995.20019531, 196233.699951172 6639001.79980469, 196222 6639007.10009766, 196206.300048828 6639013.79980469, 196190.599975586 6639020.79980469, 196178 6639026.70019531, 196167.199951172 6639031.20019531, 196155.699951172 6639037.60009766, 196147.599975586 6639041.79980469, 196144 6639043.39990235, 196138.75 6639047.72021484, 196131.400024414 6639053.89990234, 196126.800048828 6639058.70019531, 196119.199951172 6639071.20019531, 196113.800048828 6639081, 196108.300048828 6639096.79980469, 196104.800048828 6639108, 196102.400024414 6639116.79980469, 196099.599975586 6639133, 196098.400024414 6639147.79980469, 196097.900024414 6639154.70019531, 196095.5 6639175.20019531, 196093.400024414 6639190.20019531, 196092 6639209.90039063, 196091.099975586 6639225.29980469, 196091.640014648 6639236.84960938, 196094.400024414 6639255.20019531, 196098.599975586 6639275.59960938, 196104.900024414 6639291.70019531, 196119.300048828 6639319.70019531, 196133 6639346.09960938, 196146.199951172 6639364.90039062, 196161.800048828 6639384.09960938, 196180.199951172 6639402.40039063, 196198.699951172 6639420.79980469, 196207.699951172 6639428.5, 196217.5 6639443.59960938, 196224.900024414 6639460.59960938, 196232 6639472.59960938, 196244.800048828 6639485.5, 196256.300048828 6639498.5, 196268.5 6639513.90039063, 196281.699951172 6639528.59960938, 196292.800048828 6639540.59960938, 196303.699951172 6639553.29980469, 196312.599975586 6639563.5, 196320.400024414 6639574.09960938, 196326.300048828 6639583.5, 196335.800048828 6639599.40039063, 196342 6639611.90039063, 196349 6639627.29980469, 196355 6639645.59960938, 196357.7 6639657.1, 196360.3 6639671.1, 196362.7 6639684.8, 196365.6 6639703.6, 196367.6 6639719.5, 196369.1 6639732.5, 196370.3 6639749.8, 196370.3 6639752, 196371.6 6639779.8, 196369.5 6639797.7, 196362.5 6639820, 196354.7 6639840.8, 196347.3 6639862.3, 196341.9 6639880.4, 196334.4 6639899.3, 196327.2 6639921.7, 196321.2 6639943.3, 196317.5 6639959.2, 196314.4 6639982.6, 196311.5 6640003.6, 196307.6 6640023.9, 196302.7 6640043.6, 196297.1 6640060.6, 196290.4 6640075.5, 196283.5 6640089.6, 196277 6640101.4, 196272.8 6640110.6, 196268.6 6640120.5, 196267.7 6640125, 196266.2 6640135, 196266.2 6640143, 196267.2 6640156.1, 196268.8 6640168.1, 196270.9 6640180.5, 196272.6 6640192.1, 196272.7 6640202.3, 196272.4629380733 6640216.227388193)\",\"kommune\":631,\"fylke\":6,\"region\":2,\"vegavdeling\":6,\"politidistrikt\":9,\"vegreferanse\":{\"fylke\":6,\"kommune\":631,\"kategori\":\"F\",\"status\":\"V\",\"nummer\":88,\"hp\":2,\"fra_meter\":2363,\"til_meter\":7927}}]}}").getAsJsonObject();
 
         String expectedStartDate = "2010-02-02";
 
         assertEquals(expectedStartDate, GsonUtil.parseStringMember(e, "versjon.startdato"));
     }
-
-    @Test
-    public void testGetQuality() {
-        JsonObject obj = new JsonParser().parse(jsonResponse).getAsJsonObject();
-
-        //JsonObject qualitySource = obj.getAsJsonArray("egenskaper").get(9).getAsJsonObject().getAsJsonObject("kvalitet");
-        JsonObject qualitySource = obj.getAsJsonArray("egenskaper").get(10).getAsJsonObject().getAsJsonObject("kvalitet");
-
-        Quality parsedQuality = GeometryParser.parseQuality(qualitySource);
-        Quality expectedQuality = new Quality(11, 15, 11, 15, null, 0, null);
-
-        assertTrue( parsedQuality.equals( expectedQuality ));
-
-    }
-
 }
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/Helper.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/Helper.java
new file mode 100644
index 0000000..a76e66f
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/Helper.java
@@ -0,0 +1,61 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+
+class Helper {
+
+    private final static String utf8 = StandardCharsets.UTF_8.name();
+
+     static <T> List<T> parsePlainList(String file, Function<JsonObject, T> mapper) throws IOException {
+         try(InputStream resource = Helper.class.getResourceAsStream("/jsonresponse/" + file)) {
+             JsonElement response = JsonParser.parseReader(new InputStreamReader(resource, utf8));
+             JsonArray objekter = response.getAsJsonArray();
+             return parseList(mapper, objekter);
+         }
+     }
+
+    static <T> List<T> parseObjekterList(String file, Function<JsonObject, T> mapper) throws IOException {
+        try(InputStream resource = Helper.class.getResourceAsStream("/jsonresponse/" + file)) {
+            JsonElement response = JsonParser.parseReader(new InputStreamReader(resource, utf8));
+            JsonArray objekter = response.getAsJsonObject().get("objekter").getAsJsonArray();
+            return parseList(mapper, objekter);
+        }
+    }
+
+
+    private static <T> List<T> parseList(Function<JsonObject, T> mapper, JsonArray objekter) {
+        return StreamSupport.stream(objekter.spliterator(), false)
+            .map(JsonElement::getAsJsonObject)
+            .map(mapper)
+            .collect(Collectors.toList());
+    }
+
+    static <T> T parseObject(String file, Function<JsonObject, T> mapper) throws IOException {
+        InputStream resource = Helper.class.getResourceAsStream("/jsonresponse/" + file);
+        JsonElement response = JsonParser.parseReader(new InputStreamReader(resource, utf8));
+        return mapper.apply(response.getAsJsonObject());
+    }
+
+    static <T> List<T> parseList(String file, Function<JsonObject, T> mapper) throws IOException {
+        try(InputStream resource = Helper.class.getResourceAsStream("/jsonresponse/" + file)) {
+            JsonElement response = JsonParser.parseReader(new InputStreamReader(resource, utf8));
+            return StreamSupport.stream(response.getAsJsonArray().spliterator(), false)
+                    .map(JsonElement::getAsJsonObject)
+                    .map(mapper)
+                    .collect(Collectors.toList());
+
+        }
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/PosisjonParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/PosisjonParserTest.java
new file mode 100644
index 0000000..5e4368f
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/PosisjonParserTest.java
@@ -0,0 +1,20 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import no.vegvesen.nvdbapi.client.model.Position;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObject;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.notNullValue;
+
+public class PosisjonParserTest {
+    @Test
+    void parsePosition() throws IOException {
+        Position.Result result = parseObject("posisjon/posisjon.json", PlacementParser::parsePosition);
+        assertThat(result.getRoadRef(), is(notNullValue()));
+    }
+
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/RoadSysRefParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/RoadSysRefParserTest.java
new file mode 100644
index 0000000..cfca1e4
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/RoadSysRefParserTest.java
@@ -0,0 +1,48 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSysRef;
+import no.vegvesen.nvdbapi.client.model.roadnet.roadsysref.RoadSystem;
+import org.junit.jupiter.api.Test;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObject;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.not;
+import static org.hamcrest.Matchers.notNullValue;
+
+public class RoadSysRefParserTest {
+
+    @Test
+    void parseRoadSystemWithNumber() throws Exception {
+        RoadSysRef roadSysRef = parseObject("vegobjekter/vegsystemreferanse_med_nummer.json", RoadSysRefParser::parse);
+        assertThat(roadSysRef, notNullValue());
+        assertThat(roadSysRef.shortForm, equalTo("KV17 S1D1 m0-58"));
+    }
+
+    @Test
+    void parseRoadSystemWithoutNumber() throws Exception {
+        RoadSysRef roadSysRef = parseObject("vegobjekter/vegsystemreferanse_uten_nummer.json", RoadSysRefParser::parse);
+        assertThat(roadSysRef, notNullValue());
+        assertThat(roadSysRef.shortForm, equalTo("KVnull S1D1 m0-58"));
+    }
+
+    @Test
+    void roadSystemWithoutNumberOperations() throws Exception {
+        RoadSysRef roadSysRefOk = parseObject("vegobjekter/vegsystemreferanse_med_nummer.json", RoadSysRefParser::parse);
+        RoadSystem roadSystemOk = roadSysRefOk.getRoadSystem();
+        RoadSysRef roadSysRefMissingNumber = parseObject("vegobjekter/vegsystemreferanse_uten_nummer.json", RoadSysRefParser::parse);
+        RoadSystem roadSystemMissingNumber = roadSysRefMissingNumber.getRoadSystem();
+        RoadSysRef roadSysRefMissingNumberCopy = parseObject("vegobjekter/vegsystemreferanse_uten_nummer.json", RoadSysRefParser::parse);
+        RoadSystem roadSystemMissingNumberCopy = roadSysRefMissingNumberCopy.getRoadSystem();
+
+        assertThat(roadSystemMissingNumber, equalTo(roadSystemMissingNumberCopy));
+        assertThat(roadSystemMissingNumber, not(equalTo(roadSystemOk)));
+
+        assertThat(roadSystemMissingNumber.getCategoryPhaseNumberAsString(), equalTo("KV"));
+
+        assertThat(roadSystemMissingNumber.hashCode(), equalTo(roadSystemMissingNumberCopy.hashCode()));
+        assertThat(roadSystemMissingNumber.hashCode(), not(equalTo(roadSystemOk.hashCode())));
+
+        assertThat(roadSystemMissingNumber.toString(), equalTo("RoadSystem{id=1005921633, version=1, roadNumber=null, roadCategory='K', phase='V'}"));
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/RouteParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/RouteParserTest.java
new file mode 100644
index 0000000..a6d7dad
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/RouteParserTest.java
@@ -0,0 +1,30 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import no.vegvesen.nvdbapi.client.model.roadnet.route.RouteOnRoadNet;
+import no.vegvesen.nvdbapi.client.model.roadnet.route.RouteSegment;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.util.List;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObject;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+
+
+public class RouteParserTest {
+    @Test
+    void parseDeatiledRouteSegments() throws IOException {
+        RouteOnRoadNet route = parseObject("rute/rute_langtformat.json", RouteParser::parseDetailed);
+        List<RouteSegment> detailedRouteSegments = route.getSegments();
+        assertThat(detailedRouteSegments.size(), is(2));
+    }
+
+    @Test
+    void parseBriefRouteSegments() throws IOException {
+        RouteOnRoadNet route = parseObject("rute/rute_kortformat.json", RouteParser::parseBrief);
+        List<RouteSegment> routeSegmentDetaileds = route.getSegments();
+        assertThat(routeSegmentDetaileds.size(), is(2));
+    }
+
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/StatsParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/StatsParserTest.java
new file mode 100644
index 0000000..24ce733
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/StatsParserTest.java
@@ -0,0 +1,16 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import no.vegvesen.nvdbapi.client.model.roadobjects.Statistics;
+import org.junit.jupiter.api.Test;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObject;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+public class StatsParserTest {
+
+    @Test
+    void parseStats() throws Exception {
+        Statistics statistics = parseObject("vegobjekter/105_statistikk.json", RoadObjectParser::parseStatistics);
+        assertNotNull(statistics);
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/StatusParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/StatusParserTest.java
new file mode 100644
index 0000000..4fc5a17
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/StatusParserTest.java
@@ -0,0 +1,17 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import no.vegvesen.nvdbapi.client.model.Status;
+import org.junit.jupiter.api.Test;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObject;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.*;
+
+public class StatusParserTest {
+
+    @Test
+    void parseStatus() throws Exception {
+        Status status = parseObject("status.json", StatusParser::parseStatus);
+        assertThat(status, is(notNullValue()));
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/TransaksjonParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/TransaksjonParserTest.java
new file mode 100644
index 0000000..d2e5476
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/TransaksjonParserTest.java
@@ -0,0 +1,14 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObjekterList;
+
+public class TransaksjonParserTest {
+    @Test
+    void parseTransaksjoner() throws IOException {
+        parseObjekterList("transaksjoner.json", TransactionParser::parseTransaction);
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/VegnettParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/VegnettParserTest.java
new file mode 100644
index 0000000..afb5c88
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/VegnettParserTest.java
@@ -0,0 +1,36 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import no.vegvesen.nvdbapi.client.model.roadnet.*;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.util.List;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObjekterList;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.*;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+public class VegnettParserTest {
+    @Test
+    void parseNodes() throws IOException {
+        List<Node> nodes = parseObjekterList("vegnett/noder.json", RoadNetParser::parseNode);
+        assertThat(nodes.size(), is(not(0)));
+    }
+
+    @Test
+    void parseLinksequences() throws IOException {
+        List<LinkSequence> linkSequences = parseObjekterList("vegnett/veglenkesekvenser.json", RoadNetParser::parseLinkSequence);
+        assertThat(linkSequences.size(), is(not(0)));
+
+        for(Link link : linkSequences.get(0).getLinks()) {
+            assertEquals(LinkType.HOVED, link.getLinkType());
+        }
+    }
+
+    @Test
+    void parseSegmentedLinksequences() throws IOException {
+        List<SegmentedLink> segmentedLinks = parseObjekterList("vegnett/veglenkesekvenser_segmentert.json", SegmentedLinkParser::parse);
+        assertThat(segmentedLinks.size(), is(not(0)));
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/VegobjekterParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/VegobjekterParserTest.java
new file mode 100644
index 0000000..1b5ecd3
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/VegobjekterParserTest.java
@@ -0,0 +1,159 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import java.io.IOException;
+import java.time.LocalDate;
+import java.time.LocalTime;
+import java.time.MonthDay;
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.CsvSource;
+
+import no.vegvesen.nvdbapi.client.model.Direction;
+import no.vegvesen.nvdbapi.client.model.Geometry;
+import no.vegvesen.nvdbapi.client.model.GeometryAttributes;
+import no.vegvesen.nvdbapi.client.model.Projection;
+import no.vegvesen.nvdbapi.client.model.Quality;
+import no.vegvesen.nvdbapi.client.model.SidePosition;
+import no.vegvesen.nvdbapi.client.model.datakatalog.Unit;
+import no.vegvesen.nvdbapi.client.model.roadobjects.Location;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RefLinkExtentPlacement;
+import no.vegvesen.nvdbapi.client.model.roadobjects.RoadObject;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.AssociationAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.Attribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.BlobAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.BooleanAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.DateAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.IntegerAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.IntegerEnumAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.ListAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.RealAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.RealEnumAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.ReflinkExtentAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.ShortDateAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.SpatialAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.StringAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.StringEnumAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.StructAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.TimeAttribute;
+import no.vegvesen.nvdbapi.client.model.roadobjects.attribute.TurnExtent;
+
+import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.empty;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObject;
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObjekterList;
+import static no.vegvesen.nvdbapi.client.gson.Helper.parsePlainList;
+
+public class VegobjekterParserTest {
+
+    @ParameterizedTest
+    @CsvSource({"14","95","105","581"})
+    void parseVegobjekter(String file) throws IOException {
+        List<RoadObject> roadObjects = parseObjekterList("vegobjekter/" + file + ".json", RoadObjectParser::parse);
+        assertThat(roadObjects.size(), is(not(0)));
+
+        for (RoadObject roadObject : roadObjects) {
+            assertThat(roadObject.getLocation().getRoadSysRefs(), is(not(empty())));
+            assertThat(roadObject.getAttributes(), is(not(empty())));
+        }
+    }
+
+    @ParameterizedTest
+    @CsvSource({"punkt", "linje", "sving"})
+    void parseStedfesting(String type) throws IOException {
+        Location location = parseObject("vegobjekter/lokasjon_" + type + ".json",
+            RoadObjectParser::parseLocation);
+    }
+
+    @Test
+    void parseEgenskaper() throws IOException {
+        List<Attribute> attributes = parsePlainList("vegobjekter/egenskaper.json", RoadObjectParser::parseAttribute);
+        assertThat(attributes, contains(
+            new BlobAttribute(1, 213, "bah", "https://bah"),
+            new BooleanAttribute(2, false),
+            new DateAttribute(3, LocalDate.of(2019, 10, 12)),
+            new ShortDateAttribute(4, MonthDay.of(10, 12)),
+            new TimeAttribute(5, LocalTime.of(12, 12)),
+            new SpatialAttribute(6,
+                new Geometry(
+                    "POINT Z(88206.76856 6783844.94758 259.86262)",
+                    Projection.UTM33,
+                    false, true,
+                    new GeometryAttributes(
+                        LocalDate.of(1012, 12, 12),
+                        LocalDate.of(1012, 12, 13),
+                        LocalDate.of(1012, 12, 14),
+                        "blabal",
+                        1847,
+                        "papir",
+                        "Schmosi",
+                        2012,
+                        false,
+                        0.0,
+                        123,
+                        new Quality(95, 5, 1, 1, 2, 2)
+                    )
+                )),
+            new IntegerAttribute(7, 1, new Unit(1, "Meter", "m")),
+            new IntegerEnumAttribute(8, 1, 2),
+            new RealAttribute(9, 1.213),
+            new StructAttribute(10,
+                asList(
+                    new RealEnumAttribute(10001, 1, 2.0),
+                    new RealAttribute(10002, 1.213)
+                )),
+            new StringAttribute(11, "øl"),
+            new StringEnumAttribute(12, 1, "bap"),
+            new ReflinkExtentAttribute(
+                13,
+                384011,
+                Direction.WITH,
+                SidePosition.MIDDLE_RIGHT,
+                singletonList("1"),
+                0.07178555,
+                0.07178555
+            ),
+            new ReflinkExtentAttribute(
+                14,
+                384011,
+                Direction.WITH,
+                SidePosition.MIDDLE_RIGHT,
+                singletonList("1"),
+                0.07178555,
+                0.15652675
+            ),
+            new TurnExtent(15,
+                384011,
+                new RefLinkExtentPlacement(
+                    942450,
+                    0.23585116,
+                    0.23585116,
+                    Direction.WITH,
+                    SidePosition.MIDDLE,
+                    emptyList()
+                ),
+                new RefLinkExtentPlacement(
+                    942694,
+                    0.64558392,
+                    0.64558392,
+                    Direction.WITH,
+                    SidePosition.MIDDLE,
+                    emptyList()
+                )
+            ),
+            new ListAttribute(
+                220016,
+                singletonList(
+                    new AssociationAttribute(200016, 78735746L)
+                ))
+        ));
+    }
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/gson/VegobjekttyperParserTest.java b/src/test/java/no/vegvesen/nvdbapi/client/gson/VegobjekttyperParserTest.java
new file mode 100644
index 0000000..e36fc91
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/gson/VegobjekttyperParserTest.java
@@ -0,0 +1,71 @@
+package no.vegvesen.nvdbapi.client.gson;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.CsvSource;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import no.vegvesen.nvdbapi.client.model.datakatalog.AttributeType;
+import no.vegvesen.nvdbapi.client.model.datakatalog.DataType;
+import no.vegvesen.nvdbapi.client.model.datakatalog.DoubleEnumAttributeType;
+import no.vegvesen.nvdbapi.client.model.datakatalog.EnumAttributeType;
+import no.vegvesen.nvdbapi.client.model.datakatalog.FeatureType;
+import no.vegvesen.nvdbapi.client.model.datakatalog.IntegerEnumAttributeType;
+import no.vegvesen.nvdbapi.client.model.datakatalog.StringEnumAttributeType;
+
+import static java.util.stream.Collectors.toMap;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.notNullValue;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import static no.vegvesen.nvdbapi.client.gson.Helper.parseObject;
+import static no.vegvesen.nvdbapi.client.gson.Helper.parsePlainList;
+
+public class VegobjekttyperParserTest {
+    @ParameterizedTest
+    @CsvSource({"14","95","105","581"})
+    void parseVegobjekttyper(String file) throws IOException {
+        Map<String, DataType> datatyper = parseDatatyper();
+        FeatureType featureType = parseObject("vegobjekttyper/" + file + ".json", e -> FeatureTypeParser.parse(datatyper, e));
+        assertThat(featureType, is(notNullValue()));
+    }
+
+    private Map<String, DataType> parseDatatyper() throws IOException {
+        return parsePlainList("vegobjekttyper/datatyper.json", AttributeTypeParser::parseDataType)
+                .stream()
+                .collect(toMap(DataType::getName, Function.identity()));
+    }
+
+    @ParameterizedTest
+    @MethodSource
+    <T extends AttributeType> void parseAttributeType(String file,
+                                                      int attributetypeId,
+                                                      Class<T> expectedType,
+                                                      Consumer<T> asserts) throws IOException {
+        Map<String, DataType> datatyper = parseDatatyper();
+        FeatureType featureType = parseObject("vegobjekttyper/" + file + ".json", e -> FeatureTypeParser.parse(datatyper, e));
+        T attributeType = featureType.getAttributeType(attributetypeId, expectedType);
+        assertThat(attributeType, notNullValue());
+        asserts.accept(attributeType);
+    }
+
+    static Stream<Arguments> parseAttributeType() {
+        Consumer<EnumAttributeType> enumAsserts = (EnumAttributeType a) -> {
+            assertThat(a.size(), greaterThan(0));
+        };
+        return Stream.of(
+          arguments("14", 10724, StringEnumAttributeType.class, enumAsserts),
+          arguments("14", 4660, DoubleEnumAttributeType.class, enumAsserts),
+          arguments("581", 3947, IntegerEnumAttributeType.class, enumAsserts)
+        );
+    }
+
+}
diff --git a/src/test/java/no/vegvesen/nvdbapi/client/model/roadnet/TopologyLevelTest.java b/src/test/java/no/vegvesen/nvdbapi/client/model/roadnet/TopologyLevelTest.java
new file mode 100644
index 0000000..2c14cea
--- /dev/null
+++ b/src/test/java/no/vegvesen/nvdbapi/client/model/roadnet/TopologyLevelTest.java
@@ -0,0 +1,17 @@
+package no.vegvesen.nvdbapi.client.model.roadnet;
+
+
+import org.junit.jupiter.api.Test;
+
+import static no.vegvesen.nvdbapi.client.model.roadnet.TopologyLevel.KJOREBANE;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.is;
+
+public class TopologyLevelTest {
+
+    @Test
+    public void happyDay() {
+        TopologyLevel from = TopologyLevel.fromValue("Kjørebane");
+        assertThat(from.getDescription(), is(KJOREBANE.getDescription()));
+    }
+}
\ No newline at end of file
